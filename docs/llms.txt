# Sobre este Repositório

Bem-vindo ao meu repositório pessoal de aprendizado de C# e .NET. Esta documentação é um projeto vivo onde organizo minhas anotações, exemplos de código e meu entendimento da linguagem C#, desde conceitos fundamentais até tópicos mais avançados.

O objetivo principal é construir uma base de conhecimento pessoal estruturada e detalhada que solidifique meu aprendizado e possa servir como uma referência rápida no futuro.

## Como Está Organizado

Esta base de conhecimento está dividida principalmente em duas áreas:

1. Tópicos (`/Writerside/topics/`): São artigos detalhados que explicam conceitos específicos de C#. Cada tópico visa ser uma explicação clara e concisa de um recurso, palavra-chave ou conceito de programação.

2. Projetos (`/projects/`): Este diretório contém pequenas aplicações C# práticas. Esses projetos são usados para aplicar o conhecimento teórico dos tópicos de forma prática.

Este projeto é construído usando JetBrains Writerside, que permite formatação rica e uma experiência de documentação estruturada.

## See also

### Writerside documentation

[Recursos Recomendados](references.html)



# Escopo

Em C#, "escopo" refere-se à região do código onde uma variável ou um membro de uma classe pode ser acessado. Entender o escopo é fundamental para escrever um código organizado e livre de erros, pois ele determina o ciclo de vida e a visibilidade das suas variáveis.

O escopo em C# é geralmente definido por blocos de código, que são delimitados por chaves `{}`.

## Níveis de Escopo

### 

1. Escopo de Classe (Campos ou Fields)

Variáveis declaradas diretamente dentro de uma classe, mas fora de qualquer método, são chamadas de campos (fields) ou variáveis de membro. Elas estão disponíveis para todos os métodos (e outros membros) dentro daquela classe.

* Seu ciclo de vida é o mesmo do objeto da classe.

* Podem ser acessadas usando a palavra-chave `this`.

```CSHARP
public class Personagem
{
    // 'nome' e 'pontosDeVida' são campos com escopo de classe.
    private string nome;
    private int pontosDeVida = 100;

    public Personagem(string nomeInicial)
    {
        this.nome = nomeInicial; // Acessando o campo 'nome'
    }

    public void ReceberDano(int dano)
    {
        // Acessando e modificando o campo 'pontosDeVida'
        this.pontosDeVida -= dano;
        Console.WriteLine($"{this.nome} recebeu {dano} de dano e agora tem {this.pontosDeVida} HP.");
    }
}
```

### 2. Escopo de Método (Variáveis Locais)

Variáveis declaradas dentro de um método são chamadas de variáveis locais. Elas só podem ser acessadas dentro do método onde foram declaradas.

* Elas são criadas quando o método é chamado e destruídas quando o método termina.

* Não podem ser acessadas por outros métodos.

```CSHARP
public class Calculadora
{
    public int Somar(int a, int b)
    {
        // 'resultado' é uma variável local com escopo de método.
        int resultado = a + b;
        return resultado;
    }

    public void OutroMetodo()
    {
        // A linha abaixo causaria um erro de compilação, pois 'resultado'
        // não existe neste escopo.
        // Console.WriteLine(resultado); 
    }
}
```

### 3. Escopo de Bloco

Variáveis declaradas dentro de um bloco de código (como um `if`, `for`, `while` ou mesmo um bloco `{}` avulso) só existem dentro daquele bloco.

* Este é o nível de escopo mais restrito.

```CSHARP
public void TestarEscopoDeBloco()
{
    int a = 10;

    if (a > 5)
    {
        // 'b' só existe dentro deste bloco 'if'.
        int b = 20;
        Console.WriteLine(a + b); // Válido: 'a' e 'b' estão em escopo.
    }

    // A linha abaixo causaria um erro de compilação, pois 'b' está fora de escopo.
    // Console.WriteLine(b);
}
```

## 

Sombreamento de Variáveis (Variable Shadowing)

O C# impede que você declare uma variável local com o mesmo nome de outra variável local que já esteja em um escopo externo (pai). Isso evita bugs e confusão.

```CSHARP
int x = 10; // Escopo do método

if (x > 5)
{
    int y = 20; // Escopo do bloco
    // int x = 30; // Erro de compilação! Não se pode declarar 'x' aqui porque já existe no escopo pai.
}
```

No entanto, uma variável local pode ter o mesmo nome de um campo da classe. Nesse caso, a variável local "sombra" (ou esconde) o campo. Para acessar o campo da classe, você deve usar a palavra-chave `this`.

```CSHARP
public class Exemplo
{
    private string nome = "Classe"; // Campo da classe

    public void MeuMetodo(string nome) // Parâmetro do método
    {
        // 'nome' aqui se refere ao parâmetro do método ("Método").
        Console.WriteLine($"Variável local: {nome}");

        // Para acessar o campo da classe, usamos 'this.nome'.
        Console.WriteLine($"Campo da classe: {this.nome}");
    }
}

// Uso:
Exemplo ex = new Exemplo();
ex.MeuMetodo("Método");
// Saída:
// Variável local: Método
// Campo da classe: Classe
```



# Namespaces

Em C#, um `namespace` é um contêiner organizacional para classes e outros namespaces. Sua principal finalidade é fornecer um nível de separação para o código, ajudando a evitar conflitos de nomes e a estruturar grandes projetos de forma lógica.

Pense em um namespace como o sobrenome de uma classe. Você pode ter duas pessoas chamadas "João", mas elas são diferentes se uma for "João Silva" e a outra "João Souza". Da mesma forma, você pode ter duas classes `Cliente`, desde que elas estejam em namespaces diferentes (ex: `MeuApp.Vendas.Cliente` e `MeuApp.Suporte.Cliente`).

## Declaração e Estrutura

Um namespace é declarado com a palavra-chave `namespace`, seguida por um nome e um bloco de código `{}` contendo as classes.

```CSHARP
// O nome do namespace geralmente segue a estrutura do projeto.
namespace MeuApp.Servicos
{
    public class EmailService
    {
        // ... código do serviço de email
    }
}
```

### Relação com a Estrutura de Pastas

Por convenção, a estrutura de namespaces de um projeto espelha a estrutura de pastas. Isso torna a navegação e a localização de arquivos muito mais intuitivas.

* Se você tem um arquivo na pasta `Projeto/Models/User.cs`, o namespace dentro de `User.cs` deve ser `Projeto.Models`.

* Se você tem um arquivo em `Projeto/Services/Payment/PayPalService.cs`, o namespace deve ser `Projeto.Services.Payment`.

As IDEs modernas, como o Visual Studio e o Rider, gerenciam essa estrutura automaticamente ao criar novos arquivos.

## Namespaces Aninhados

Você pode aninhar namespaces para criar hierarquias ainda mais detalhadas.

```CSHARP
namespace MeuApp.Servicos
{
    namespace Notificacoes
    {
        public class PushService { }
    }
}

// A classe PushService pode ser acessada usando seu nome completo:
// MeuApp.Servicos.Notificacoes.PushService service;
```

## O Namespace Global

Qualquer tipo que não é declarado dentro de um namespace reside no namespace global. Isso é geralmente desaconselhado para evitar poluir o escopo global e criar possíveis conflitos com outras bibliotecas.

## Boas Práticas

1. Um Tipo por Arquivo: Mantenha apenas uma classe, struct, interface ou enum por arquivo. O nome do arquivo deve corresponder ao nome do tipo (ex: `Cliente.cs` contém a classe `Cliente`).

2. Espelhe a Estrutura de Pastas: Sempre faça seus namespaces corresponderem à hierarquia de pastas do seu projeto.

3. Nomes Significativos: Use nomes que descrevam claramente a funcionalidade contida no namespace (ex: `MeuApp.Data`, `MeuApp.UI`, `MeuApp.Utilities`).



# A Palavra-Chave using

A palavra-chave `using` em C# é multifacetada e possui três contextos de uso distintos, todos com o objetivo de simplificar o código e gerenciar recursos de forma eficaz.

## 

1. Diretiva `using`: Importando Namespaces

Este é o uso mais comum. A diretiva `using` é colocada no topo de um arquivo de código e permite que você use os tipos de um namespace sem precisar especificar o nome completo do namespace toda vez.

Sem a diretiva `using`, você teria que escrever:

```CSHARP
// Nome completo do tipo é necessário
System.Collections.Generic.List<string> nomes = new System.Collections.Generic.List<string>();
System.Console.WriteLine("Olá");
```

Com a diretiva `using`, o código se torna muito mais limpo e legível:

```CSHARP
// Importamos os namespaces no topo do arquivo
using System;
using System.Collections.Generic;

// Agora podemos usar os tipos diretamente
List<string> nomes = new List<string>();
Console.WriteLine("Olá");
```

Note:

Por convenção, as diretivas `using` são sempre declaradas no início do arquivo.

## 

2. Instrução `using`: Gerenciamento de Recursos (`IDisposable`)

A instrução `using` garante que objetos que implementam a interface `IDisposable` sejam descartados corretamente, liberando recursos não gerenciados (como conexões de banco de dados, arquivos, handles de sistema) assim que não forem mais necessários.

O compilador transforma o bloco `using` em um bloco `try...finally`, garantindo que o método `Dispose()` do objeto seja chamado, mesmo que ocorram exceções.

Sintaxe Tradicional:

```CSHARP
// A classe 'StreamReader' implementa IDisposable
using (System.IO.StreamReader leitor = new System.IO.StreamReader("caminho/para/arquivo.txt"))
{
    string conteudo = leitor.ReadToEnd();
    Console.WriteLine(conteudo);
} // O método leitor.Dispose() é chamado automaticamente aqui, fechando o arquivo.
```

Sintaxe Simplificada (C# 8.0 e superior):

Se a variável declarada com `using` não for mais usada fora do escopo atual, você pode omitir as chaves.

```CSHARP
using System.IO.StreamReader leitor = new System.IO.StreamReader("arquivo.txt");
string conteudo = leitor.ReadToEnd();
Console.WriteLine(conteudo);
// O método leitor.Dispose() será chamado automaticamente no final do escopo (ex: no final do método).
```

## 

3. Diretiva `using static`: Importando Membros Estáticos

Esta diretiva permite que você acesse os membros estáticos (`métodos`, `propriedades`, `constantes`) de uma classe diretamente, sem precisar prefixá-los com o nome da classe.

Sem `using static`:

```CSHARP
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine(Math.PI);
        Console.WriteLine(Math.Pow(2, 3));
    }
}
```

Com `using static`, o código fica mais conciso:

```CSHARP
// Importamos todos os membros estáticos da classe System.Math e System.Console
using static System.Math;
using static System.Console;

class Program
{
    static void Main()
    {
        // Agora podemos chamar os métodos estáticos diretamente
        WriteLine(PI);       // Em vez de Math.PI
        WriteLine(Pow(2, 3)); // Em vez de Math.Pow(2, 3)
    }
}
```

Warning:

Use `using static` com moderação. Embora possa tornar o código mais curto, usá-lo excessivamente pode poluir o escopo e diminuir a legibilidade, tornando difícil saber de qual classe um método estático se origina.



# Palavras-Chave (Keywords)

Palavras-chave (ou keywords) são identificadores reservados que têm um significado especial para o compilador do C#. Elas são os blocos de construção fundamentais da linguagem e não podem ser usadas como nomes de variáveis, métodos ou classes (a menos que sejam prefixadas com `@`, o que é raro e geralmente desaconselhado).

Note:

Você não precisa memorizar todas. As IDEs modernas, como Visual Studio e Rider, destacam as palavras-chave e avisam se você tentar usá-las incorretamente. O objetivo aqui é entender as categorias e as mais comuns.

## Categorias de Palavras-Chave Comuns

### Modificadores de Acesso

Controlam a visibilidade (onde o código pode ser acessado).

* `public`: Acesso não restrito.

* `private`: Acesso limitado à classe que o contém.

* `protected`: Acesso limitado à classe que o contém e a classes derivadas (herança).

* `internal`: Acesso limitado ao assembly atual (ao projeto).

### Declaração de Tipos

Usadas para definir os diferentes tipos de estruturas de dados.

* `class`: Define um tipo de referência que contém dados (campos) e comportamento (métodos).

* `struct`: Define um tipo de valor, geralmente para pequenas estruturas de dados.

* `interface`: Define um contrato (um conjunto de métodos e propriedades) que uma classe ou struct pode implementar.

* `enum`: Define um conjunto de constantes nomeadas (ex: DiasDaSemana).

* `delegate`: Define um tipo que representa uma referência a um método com uma assinatura específica.

### Modificadores de Membros

Alteram o comportamento de membros de uma classe.

* `static`: Indica que um membro pertence ao tipo em si, não a uma instância.

* `const`: Declara um campo cujo valor é uma constante de tempo de compilação.

* `readonly`: Declara um campo cujo valor só pode ser definido na declaração ou no construtor.

* `abstract`: Indica que uma classe ou membro tem uma implementação ausente ou incompleta (deve ser implementado por uma classe derivada).

* `virtual`: Permite que um método em uma classe base seja sobrescrito por uma classe derivada.

* `override`: Sobrescreve um método `virtual` ou `abstract` de uma classe base.

### Nível de Método

Usadas dentro de métodos ou para definir o comportamento de métodos.

* `void`: Especifica que um método não retorna nenhum valor.

* `return`: Retorna o controle (e opcionalmente um valor) do método para quem o chamou.

* `params`: Permite que um método aceite um número variável de argumentos.

* `ref`, `out`, `in`: Modificadores de parâmetro que controlam como os argumentos são passados para os métodos.

### Instruções e Controle de Fluxo

Controlam a ordem em que o código é executado.

* `if`, `else`: Executam código condicionalmente.

* `switch`, `case`, `default`: Executam código com base em uma correspondência de padrões.

* `for`, `foreach`, `while`, `do`: Criam laços (loops).

* `break`: Sai de um laço ou de um `switch`.

* `continue`: Pula para a próxima iteração de um laço.

* `try`, `catch`, `finally`, `throw`: Manipulação de exceções.

### Gerenciamento de Namespaces e Tipos

* `using`: Importa um namespace ou gerencia recursos `IDisposable`.

* `namespace`: Declara um escopo para organizar o código.

* `new`: Cria uma nova instância de um tipo ou oculta um membro de uma classe base.

* `typeof`: Obtém o objeto `System.Type` para um tipo.

Para uma lista exaustiva e detalhada de todas as palavras-chave, a documentação oficial da Microsoft é a fonte definitiva.

[Referência Completa de Palavras-Chave do C# (Microsoft Docs)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/)



# Comentários

Comentários são anotações no código-fonte que são ignoradas pelo compilador. Eles existem exclusivamente para os desenvolvedores, servindo para esclarecer partes complexas do código, deixar lembretes ou gerar documentação externa.

## A Regra de Ouro: Comente o "Porquê", não o "O Quê"

Um bom código deve ser autoexplicativo. O código em si já mostra o que ele está fazendo. Comentários eficazes devem explicar por que o código está fazendo algo de uma maneira específica, especialmente se a lógica não for óbvia.

* Comentário Ruim (redundante): ```CSHARP // Incrementa i em 1 i++; ```

* Comentário Bom (explica a intenção): ```CSHARP // Usamos um algoritmo de ordenação customizado aqui porque os testes de performance // mostraram que ele é 2x mais rápido para o nosso conjunto de dados específico. CustomSort(minhaLista); ```

## Tipos de Comentários

### 

1. Comentários de Linha Única (`//`)

Começam com `//` e continuam até o final da linha. São ideais para notas curtas e explicações pontuais.

```CSHARP
// Verifica se o usuário tem permissão de administrador.
if (user.IsAdmin)
{
    // ...
}
```

### 

2. Comentários de Múltiplas Linhas (`/* ... */`)

Começam com `/*` и terminam com `*/`. Podem abranger várias linhas e são úteis para desativar temporariamente grandes blocos de código ou para comentários mais longos.

```CSHARP
/*
    Este é um método temporário para testes de carga.
    Ele simula a criação de 10.000 usuários e deve ser removido
    antes de enviarmos o código para produção.
*/
public void GerarCargaDeTeste()
{
    // ...
}
```

### 

3. Comentários de Documentação XML (`///`)

Estes são os comentários mais poderosos do C#. Eles começam com `///` e usam tags XML para descrever o que classes, métodos e propriedades fazem. O Visual Studio e outras IDEs usam esses comentários para fornecer o IntelliSense (autocompletar com documentação), e eles podem ser usados para gerar arquivos de documentação HTML automaticamente.

Tags XML Comuns:

* `<summary>`: Um resumo geral do que o membro faz.

* `<param name="nomeDoParametro">`: Descreve um parâmetro do método.

* `<returns>`: Descreve o valor de retorno do método.

* `<exception cref="TipoDaExcecao">`: Descreve uma exceção que o método pode lançar.

* `<remarks>`: Fornece informações adicionais mais detalhadas.

Exemplo Completo:

```CSHARP
/// <summary>
/// Calcula o pagamento mensal de um empréstimo com base na taxa de juros, 
/// número de parcelas e valor do empréstimo.
/// </summary>
/// <param name="taxaAnual">A taxa de juros anual (ex: 0.05 para 5%).</param>
/// <param name="numParcelas">O número total de parcelas.</param>
/// <param name="valorEmprestimo">O valor total do empréstimo.</param>
/// <returns>O valor do pagamento mensal.</returns>
/// <exception cref="ArgumentException">Lançada quando um dos parâmetros numéricos é negativo.</exception>
public double CalcularPagamentoMensal(double taxaAnual, int numParcelas, decimal valorEmprestimo)
{
    if (taxaAnual < 0 || numParcelas < 0 || valorEmprestimo < 0)
    {
        throw new ArgumentException("Parâmetros não podem ser negativos.");
    }
    // ... lógica de cálculo
    return 0.0;
}
```

Ao usar a função `CalcularPagamentoMensal` em outro lugar, a IDE mostrará a `summary`, as descrições dos parâmetros e o que ela retorna, tornando o código muito mais fácil de usar.



# Variáveis

Variavel é um espaço na mémoria que vai guardar um dado

No C# como toda linguagem de programação temos tipos primitivos, por exemplo:

* int - inteiro

* string - texto

* bool - booleano (true ou false)

* double e float - número decimal

Note:

Lembrando que: double e float não são o mesmo pois o double possui uma precisão maior do que o float, mas o float ocupa menos memória.

No c# podemos declarar variaveis assim:

```CSHARP
int idade = 10;
string nome = "Joao";
bool estaAprovado = true;
double salario = 25.98;
float altura; 
altura = 1.76f; 
```

Warning:

Note que para declarar um float devemos colocar a letra f no final da declaração:

```CSHARP
float altura = 1.76f; 
```

## Declarações múltiplas

É possível declarar várias variáveis no mesmo comando separando-as por vírgula.

```CSHARP
int a, b, c;
```

Lembre-se sempre que você precisa inicializar uma variável antes de usá-la. E de que C# é uma linguagem fortemente
tipada, logo, precisamos definir o tipo dela ou seja, você deve especificar o tipo de dados quando declarar uma
variável. Ou podemos usar a inferência de tipos. Exemplo:

```CSHARP
var idade = 10;
var nome = "Joao";
var estaAprovado = true;
var salario = 25.98;
var altura = 1.76f; 
```

Assim o tipo de dado será inferido pelo compilador, deste modo não temos um controle real da tipagem

Note:

Para inferencia de tipos utilizamos a palavra reservada `var`. Mas não podemos utilizar desta forma na hora de criar uma
variavel:

```CSHARP
var x; // isso está errado!
```



# Constantes

Uma constante (`const`) é um campo cujo valor é definido em tempo de compilação e não pode ser alterado durante a execução do programa. Pense nela como um valor fixo e imutável.

Warning:

Regra Fundamental: Uma constante deve obrigatoriamente ser inicializada no momento em que é declarada. Tentar declarar uma constante sem um valor resultará em um erro de compilação.

Exemplo de Declaração Correta:

```CSHARP
const double PI = 3.14159;
const string NOME_EMPRESA = "MinhaApp";
```

Convenção de Nomenclatura: Por convenção, nomes de constantes em C# são escritos em `PascalCase` ou `ALL_CAPS_SNAKE_CASE` para distingui-los claramente de variáveis.

## 

Características das Constantes (`const`)

1. Valor em Tempo de Compilação: O valor de uma `const` é gravado diretamente no assembly do programa. O compilador substitui o uso da constante pelo seu valor literal em todo o código (semelhante a um "localizar e substituir").

2. Tipos Permitidos: Só podem ser dos tipos primitivos do C# (todos os tipos numéricos, `bool`, `char`, `string`) ou um tipo `enum`.

3. Implicitamente Estáticas: Uma `const` é sempre estática (`static`), mesmo que a palavra-chave `static` não seja usada. Ela pertence ao tipo, não a uma instância do objeto.

## 

`const` vs. `readonly`: Qual a Diferença?

Este é um ponto crucial que diferencia desenvolvedores experientes. C# também possui a palavra-chave `readonly`, que parece similar, mas tem um propósito diferente.

* `readonly` (Constante de Tempo de Execução): Um campo `readonly` também não pode ser alterado após sua inicialização. No entanto, sua inicialização pode ocorrer na declaração ou dentro do construtor da classe. Isso permite que cada instância de um objeto tenha um valor `readonly` diferente.

Tabela Comparativa:

| Característica |`const` |`readonly` |
---------------------------------------
| Quando o valor é definido? |Tempo de Compilação |Tempo de Execução (no construtor) |
| Pode ser diferente por instância? |Não (é estático) |Sim (pode ser de instância) |
| Pode ser de qualquer tipo? |Não (só primitivos/enum) |Sim (qualquer tipo, incluindo objetos) |
| Pode ser `static`? |Sim (implicitamente) |Sim (explicitamente, `static readonly`) |

Exemplo Prático:

```CSHARP
public class Circulo
{
    // 'PI' é o mesmo para todos os círculos. É uma constante de compilação.
    public const double PI = 3.14159;

    // 'Raio' e 'DataCriacao' podem ser diferentes para cada objeto Circulo.
    // Seus valores são definidos quando o objeto é criado e não podem ser mudados depois.
    public readonly double Raio;
    public readonly DateTime DataCriacao;

    public Circulo(double raio)
    {
        this.Raio = raio; // Inicialização de campo readonly no construtor
        this.DataCriacao = DateTime.Now;
    }
}

// Uso
Circulo c1 = new Circulo(5.0);
Circulo c2 = new Circulo(10.0);

// c1.Raio é 5.0, c2.Raio é 10.0. Ambos são imutáveis após a criação.
// Tentar fazer 'c1.Raio = 7.0;' resultaria em um erro de compilação.
```

### Quando Usar Qual?

* Use `const`: Para valores que são verdadeiramente universais e imutáveis, conhecidos antes mesmo do programa rodar (ex: `Math.PI`, número de meses no ano, uma string de conexão padrão para um ambiente de teste).

* Use `readonly`: Para valores que são específicos de uma instância de um objeto e que não devem mudar após a sua criação (ex: um ID de usuário, a data de criação de um registro).



# System

Todos os tipos mesmo os built-in são derivados do tipo chamado: `system`

```CSHARP
int a = 10;
Console.WriteLine(a.GetType()); //System.Int32
```

```
Ele é a base para todos os objetos no .NET
```

Como ele está de modo implicito, não precisamos se preocupar em usar



# Tipos Primitivos (Built-in Types)

São os tipos de dados mais básicos que o C# possui. São eles:

* int: Inteiro, pode ser positivo ou negativo.

* float: Ponto flutuante, números com casas decimais.

* double: Double precision floating point number. Números com casas decimais.

* char: Caracteres individuais. Exemplo 'a', 'b' etc...

* bool: Booleano, verdadeiro ou falso.

Os tipos primitivos são usados para armazenar valores simples e podem ser declarados da seguinte forma:

```CSHARP
int myInt = 10;
float myFloat = 3.14f; // O sufixo "f" é usado para indicar que é um número de ponto flutuante.
double myDouble = 2.71828;
char myChar = 'A';
bool myBool = true;
```

Note:

Veja mais: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types)

## Classificação

Eles podem ser classificados em algumas categórias:

* Tipos Simples (Simple Types)

* Enumerados (Enum Types)

* Estruturas (Struct Types)

* Tipos Nulos (Nullable Types)

## Definições

Cada tipo possui sua capacidade em bytes e seu alcance máximo. Por exemplo:

* int: 4 bytes, -231 a 231-1

* float: 4 bytes, ~±1.5 x 10-45 to ±3.4 x 1038

* double: 8 bytes, ~±5.0 x 10-324 to ±1.7 x 10308

* char: 2 bytes, '\u0000' to '\uffff'

* bool: 1 byte, false or true

Warning:

Caso o o valor atribuido exceda o limite do tipo, ocorrerá um erro de overflow

Note:

Você também pode usar as palavras-chave `sizeof` e `typeof` para obter informações sobre esses tipos:

```CSHARP
Console.WriteLine(sizeof(int)); // Output: 4
Console.WriteLine(typeof(float).Name); // Output: Single
```



# Byte

O tipo byte é usado para representar de fato um byte.

Em diversos casos precisamos de uma cadeia de bytes num arquivo para ler ou escrever dados. O tipo byte pode ser usado para isso, pois ele representa um único byte

```CSHARP
byte b = 10;
Console.WriteLine(b);
```

Temos também o `sbyte` que permite valores negativos

Note:

Unsigned e signed:

Valores com sinal como "-" por exemplo, são chamados de signed numbers (números com sinal) e sem sinal são chamados unsigned numbers (números sem sinal).

Ex:

```CSHARP
int signedNumber = -5; //signed number
uint unsignedNumber = 5; //unsigned number
```

## Definições

* byte (8-bit): * escala: 0 a 255

* sbyte (8-bit): * escala: -127 a +127



# Números Inteiros

## Definições

Números inteiros são números que não possuem casas decimais. Exemplos de números inteiros: 1, -20, 356789.

## Classificação:

* short/unshort

* int/uint

* long/ulong

Note:

O `u` do `ushort`, `uint` e `ulong` significa unsigned (sem sinal)

Ou seja, esses tipos só armazenam valores que são possitivos ou zero

## Tabela de Tipos

| Tipo |Intervalo |Tamanho |Tipo .NET |
---------------------------------------
| `sbyte` |-128 a 127 |Inteiro de 8 bits com sinal |System.SByte |
| `byte` |0 a 255 |Inteiro de 8 bits sem sinal |System.Byte |
| `short` |-32,768 a 32,767 |Inteiro de 16 bits com sinal |System.Int16 |
| `ushort` |0 a 65,535 |Inteiro de 16 bits sem sinal |System.UInt16 |
| `int` |-2,147,483,648 a 2,147,483,647 |Inteiro de 32 bits com sinal |System.Int32 |
| `uint` |0 a 4,294,967,295 |Inteiro de 32 bits sem sinal |System.UInt32 |
| `long` |-9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 |Inteiro de 64 bits com sinal |System.Int64 |
| `ulong` |0 a 18,446,744,073,709,551,615 |Inteiro de 64 bits sem sinal |System.UInt64 |

## Referência

[Tipos de números integrais (referência de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)



# Números Reais

Números com casas decimais ou ponto flutuante são chamados de números reais. Em C#, o tipo `double` é usado para representar um número real. O exemplo a seguir mostra como declarar e inicializar uma variável do tipo `double`.

```CSHARP
double x = 3.14; // Declaração e inicialização
```

O valor da variável `x` é `3,14`. A declaração acima pode ser escrita em duas linhas.

```CSHARP
double x; // Declaração
x = 3.14; // Inicialização
```

Além do `double` também existem outros que são diferentes por causa da precisão e tamanho dos dados armazenados. Os outros são:

* `float`: tem menos precisão e menor tamanho.

* `decimal`: tem maior precisão e maior tamanho.

## Exemplos:

```CSHARP
using System;
class Program {
    static void Main(string[] args) {
        double x = 3.14;
        Console.WriteLine(x); // Imprime: 3.14
        
        float y = 2.71f;
        Console.WriteLine(y); // Imprime: 2.71
        
        decimal z = 1.618m;
        Console.WriteLine(z); // Imprime: 1.618
    }
}
```

## Inferencia de Tipos

Quando usamos o `var` sem declarar o tipo explicitamente, ele atribui automaticamente o tipo `double` porque ele estaria no meio entre `float` e `decimal`, mas se fosse muito próximo de `int` ele seria inferido como `int`.

```CSHARP
var x = 3.14; // Inferência de tipo: double
Console.WriteLine(x.GetType()); // Imprime: Double
```

Agora se quisermos dizer que vai ser float ou decimal devemos usar os sufixos `f` ou `m` respectivamente.

```CSHARP
var x = 3.14f; // Inferência de tipo: float
Console.WriteLine(x.GetType()); // Imprime: Single

var y = 3.14m; // Inferência de tipo: decimal
Console.WriteLine(y.GetType()); // Imprime: Decimal
```

## Tabela de Tipos

| Tipo |Intervalo Aproximado |Precisão |Tamanho |Tipo .NET |
------------------------------------------------------------
| `float` |±1.5 x 10⁻⁴⁵ a ±3.4 x 10³⁸ |6-9 dígitos |4 bytes |System.Single |
| `double` |±5.0 x 10⁻³²⁴ a ±1.7 x 10³⁰⁸ |15-17 dígitos |8 bytes |System.Double |
| `decimal` |±1.0 x 10⁻²⁸ a ±7.9 x 10²⁸ |28-29 dígitos |16 bytes |System.Decimal |

Note:

Os três tipos não usam unsigned ou signed, pois possuem tanto assimilação negativa e positiva por padrão

## Referência

[Tipos de ponto flutuante (referência de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)



# Bool

Bool é o tipo de dado booleano (no c# ele se chama bool) e pode receber apenas dois valores: `true` ou `false`.

## Exemplo

```CSHARP
using System;
class Program {
    static void Main(string[] args) {
        bool isTrue = true; // Variável do tipo booleana que recebe valor verdadeiro.
        Console.WriteLine(isTrue); // Imprime no console a variável criada.
    }
}
```

Quando fazemos a inferencia com `var` seguimos a mesma lógica que os outros tipos:

```CSHARP
using System;

class Program {
    static void Main(string[] args) {
        var isFalse = false; // Inferência da variável do tipo booleana que recebe valor falso.
        Console.WriteLine(isFalse);
    }
}
```



# Caracter

É o tipo de caracter que utilizamos para armazenar um  único caracter

Note:

Caracter é um tipo de dado primitivo e representa um único caracter no formato unicode (formato universal para a representação dos caracteres)

Warning:

OBS:
Para declarar uma variável do tipo char, devemos utilizar aspas simples

## Exemplos:

```CSHARP
char letra = 'a';
Console.WriteLine(letra); // imprime: a

char numero = '1';
Console.WriteLine(numero); // imprime: 1

char simbolo = '@';
Console.WriteLine(simbolo); // imprime: @

char espaco = ' ';
Console.WriteLine(espaco); // imprime: espaço em branco

char tabulacao = '\t'; // \t é uma sequência de escape que representa uma tabulação horizontal
Console.WriteLine(tabulacao); // imprime: tabulação horizontal

char novaLinha = '\n'; // \n é uma sequência de escape que representa uma nova linha
Console.WriteLine(novaLinha); // imprime: nova linha

char backspace = '\b'; // \b é uma sequência de escape que representa um caractere de retrocesso
Console.WriteLine(backspace); // imprime: caractere de retrocesso

// unicode
char unicode = '\u0041'; // \u seguido de quatro dígitos hexadecimais representa um caractere Unicode
Console.WriteLine(unicode); // imprime: A
```



# String

As strings são uma cadeia de caracters ou seja são mais de um caracter. Exemplo: "Hello World" é uma string.

Para criar uma variável do tipo string basta usar aspas duplas "" e colocar o texto dentro delas.
Exemplo:

```CSHARP
string nome;
nome = "João";
```

```CSHARP
string nome = "João";
Console.WriteLine(nome); // João
```

Você pode concatenar duas strings usando o operador +, exemplo:

```CSHARP
string nome = "João";
string sobrenome = "Silva";
string nomeCompleto = nome + " " + sobrenome; // João Silva
Console.WriteLine(nomeCompleto);
```

Warning:

IMPORTANTE: Strings SEMPRE serão com aspas duplas ("") e não simples ('')

Mesmo que inicializarmos uma variavel com string e deixar com um caracter e aspas duplas, ela será ainda uma string:

```CSHARP
string letra = "a"; // a
Console.WriteLine(letra.GetType()); // System.String
```



# Var

Var é uma palavra reservada do C#, que permite declarar variáveis sem especificar o tipo de dado. O compilador infere automaticamente o tipo da variável com base no valor atribuído a ela.

Aqui está um exemplo simples:

```CSHARP
var nome = "João";
int idade = 25;
double altura = 1.75;

Console.WriteLine($"Nome: {nome}, Idade: {idade}, Altura: {altura}");
```

Neste exemplo, não precisamos especificar explicitamente os tipos das variáveis `nome`, `idade` e `altura`. O compilador infere que `nome` é do tipo string, `idade` é do tipo int e `altura` é do tipo double.

MAS temos uma questão, o tipo que o compilador inferiu pela primeira vez sobre a variavel não pode ser alterado depois

Então se tivermos, a varivel `nome` como var e sendo inferido que ela é uma string, mas depois quisermos atribuir um inteiro para ela, teremos um erro:

```CSHARP
var nome = "João"; // Inferência de tipo: string
nome = 4; // Erro! Não é possível atribuir um inteiro a uma variável do tipo string.
```

![Erro de conversão implicita string para int](images/Erro%20de%20convers%C3%A3o%20implicita%20string%20para%20int)



# Object

É um tipo de dado genérico que pode aceitar qualquer tipo de valor ou objeto

Usado para por exemplo quando não sabe o tipo da informação ou ela é de varios tipos diferentes

```CSHARP
object obj = 10;
obj = "Hello World";
```

Note:

OBS: Não é recomendado usar pois a conversão entre os tipos deve ser feita manualmente e isso pode gerar erros em tempo de execução.

## Boxing and Unboxing

Boxing: Converte um tipo primitivo em object.

* Exemplo:

```CSHARP
int i = 5; // Tipo primitivo int
object obj = i; // Boxing, converte o tipo int em object
```

Unboxing: Converte um object em um tipo primitivo.

* Exemplo:

```CSHARP
object obj = 5; // Objeto do tipo object com valor inteiro
int i = (int)obj; // Unboxing, converte o objeto em um tipo primitivo int
```

Note:

Podemos pensar nesse boxing como um ato de colocar algo dentro de uma caixa, cujo o conteúdo pode ser qualquer coisa.

E o unboxing seria o ato de tirar algo dessa caixa.

Note:

Uma diferença entre `var`e `object` é que no caso do object você não precisa iniciar um valor por exemplo:

```CSHARP
object obj;
```

E quando fazer uma reatribuição de valor de um tipo diferente não dara problema, diferente do `var`:

```CSHARP
var var = 10;
var = "Hello World"; // Erro: Cannot implicitly convert type 'string' to 'int'
```

No caso do `object`, podemos fazer assim sem problemas:

```CSHARP
object obj = 10;
obj = "Hello World";
```



# Nullable Types

O tipo `null` significa "nulo" ou "vazio". Em C#, o valor padrão de um tipo é sempre definido como nulo. Por exemplo, se você declarar uma variável do tipo inteiro e não atribuir nenhum valor a ela, seu valor será zero.

Note:

Null é diferente de 0 (zero) e uma string vazia ("")". Null indica que a variável não tem nenhum valor válido enquanto 0 é um valor numérico válido.

E todo tipo primitivo ou complexo pode  receber nulo

Podemos marcar como Nullable Type, podemos fazer isso com:

Note:

A sintaxe para criar um tipo Nullable é colocando um ponto de interrogação após o nome do tipo.

```CSHARP
int? x = null;
```



# Valores Parões

Todo tipo built-in possui um valor padrão.

Por exemplo, o valor padrão de `int` é 0 e o valor padrão de `bool` é false.

Note:

O valor padrão de uma variável não inicializada é sempre seu valor padrão.

## Tabela com alguns valores padrões:

| Tipo |Valor Padrão |
----------------------
| int |0 |
| bool |false |
| string |null |
| double |0.0 |
| float |0.0f |
| char |'\0' |
| decimal |0m |
| long |0L |
| short |0 |
| byte |0 |
| ulong |0UL |
| ushort |0U |
| uint |0U |
| sbyte |0S |
| DateTime |1/1/0001 |
| TimeSpan |0:00:00 |
| Guid |00000000-0000-0000-0000-0000000 |



# Alias

Alias, é um apelido que todo tipo no .NET tem por exemplo:

```CSHARP
int i = 0; // int é o alias de System.Int32
System.Int32 j = 1; // aqui estamos usando a classe Int32 diretamente.
```

O mesmo acontece com outros tipos como: `string` e `bool`, etc.

Note:

Você pode ver todos os aliases em [https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/built-in-types](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/built-in-types)



# Casting

Em C#, "casting" (ou conversão explícita) é o processo de instruir o compilador a tratar uma variável de um tipo como se fosse de outro tipo. É uma operação fundamental, mas que deve ser compreendida para evitar perda de dados ou erros em tempo de execução.

O casting é diferente de usar classes utilitárias como `Convert` ou métodos como `Parse`. O casting é uma operação mais direta e de nível mais baixo, usada principalmente entre tipos numericamente compatíveis ou dentro de uma hierarquia de classes (herança).

## Conversão Implícita (Casting Implícito)

A conversão implícita, também conhecida como widening conversion, ocorre automaticamente quando um valor de um tipo "menor" é atribuído a uma variável de um tipo "maior", onde não há risco de perda de dados. É uma operação segura, e o compilador a realiza por você.

```CSHARP
// Um int (32 bits) cabe facilmente em um long (64 bits).
int meuInt = 2147483647;
long meuLong = meuInt; // Conversão implícita, totalmente segura.

// Um int (inteiro) cabe facilmente em um double (ponto flutuante).
int numero = 10;
double meuDouble = numero; // Conversão implícita. O valor se torna 10.0.

Console.WriteLine(meuDouble); // Saída: 10
```

## Conversão Explícita (Casting Explícito)

A conversão explícita, também chamada de narrowing conversion, é necessária quando há risco de perda de dados. Você deve instruir o compilador explicitamente usando a sintaxe de cast `(novoTipo)`. Ao fazer isso, você está dizendo ao compilador: "Eu sei que isso pode falhar ou perder dados, mas eu assumo a responsabilidade."

```CSHARP
double salario = 2599.95;

// Forçar a conversão de double para int. A parte decimal será perdida (truncada).
// Você DEVE usar o (int) para que o código compile.
int salarioInteiro = (int)salario;

Console.WriteLine(salarioInteiro); // Saída: 2599 (a informação .95 foi perdida)

// Outro exemplo de risco: converter um número grande para um tipo menor
long numeroGrande = 3000000000; // 3 bilhões

// int só pode armazenar até ~2.1 bilhões. Isso causará um Overflow.
// O resultado será um número inesperado e incorreto, sem lançar exceção em um contexto unchecked.
int intPequeno = (int)numeroGrande;

Console.WriteLine(intPequeno); // Saída: -1294967296 (lixo de memória)
```

Warning:

O casting explícito de tipos numéricos pode levar à **perda de dados** (truncamento) ou **estouro de capacidade** (overflow), resultando em valores incorretos. Use-o apenas quando tiver certeza de que o valor de origem caberá no tipo de destino.

## Casting em Programação Orientada a Objetos

O casting é essencial ao trabalhar com herança de classes.

```CSHARP
// Cenário de exemplo
public class Animal { }
public class Cachorro : Animal { public void Latir() { } }
public class Gato : Animal { public void Miar() { } }
```

### Upcasting (Implícito e Seguro)

Upcasting é converter uma referência de uma classe derivada (filha) para uma de sua classe base (mãe). Isso é sempre seguro e, portanto, implícito.

```CSHARP
Cachorro meuCachorro = new Cachorro();

// Upcasting: tratando um Cachorro como um Animal genérico.
// Isso é útil para criar listas de diferentes tipos de animais.
Animal animalGenerico = meuCachorro; // Upcasting implícito.
```

### Downcasting (Explícito e Arriscado)

Downcasting é o oposto: tentar converter uma referência de classe base de volta para sua classe derivada original. Isso é arriscado porque o `Animal` genérico poderia ser um `Gato`, e não um `Cachorro`. Tentar um downcast inválido lança uma `InvalidCastException`.

```CSHARP
// ...continuando de cima

// Tentativa de Downcasting
// O compilador exige o (Cachorro) porque a operação pode falhar.
Cachorro cachorroEspecifico = (Cachorro)animalGenerico; 
cachorroEspecifico.Latir(); // Funciona!

// Exemplo de falha
Animal outroAnimal = new Gato();
// A linha abaixo compila, mas lançará uma InvalidCastException em tempo de execução,
// porque um Gato não pode ser tratado como um Cachorro.
// Cachorro caoImpossivel = (Cachorro)outroAnimal; 
```

## 

Alternativas Seguras para Downcasting: `as` e `is`

Para evitar exceções, o C# fornece operadores mais seguros para downcasting.

* `is`: Verifica se a conversão é possível, retornando `true` ou `false`.

* `as`: Tenta a conversão. Se for bem-sucedida, retorna o objeto convertido. Se falhar, retorna `null` em vez de lançar uma exceção.

```CSHARP
Animal animalMisterioso = new Gato();

// Usando 'is' para verificar antes de converter
if (animalMisterioso is Cachorro)
{
    Cachorro caoVerificado = (Cachorro)animalMisterioso; // Seguro, mas verboso
    caoVerificado.Latir();
}
else
{
    Console.WriteLine("O animal misterioso não é um cachorro.");
}

// Usando 'as' para uma conversão segura e concisa (a abordagem preferida)
Cachorro caoComAs = animalMisterioso as Cachorro;
if (caoComAs != null)
{
    caoComAs.Latir();
}
else
{
    Console.WriteLine("A conversão com 'as' falhou, o animal não é um cachorro.");
}
```

## 

Guia Rápido: Casting vs. `Convert` vs. `Parse`

| Operação |Quando Usar |Exemplo |
----------------------------------
| Casting |Entre tipos numéricos ou em hierarquias de classes. |`int i = (int)10.5;` |
| `Convert` |Conversão segura entre muitos tipos base, especialmente com `nulls`. |`int i = Convert.ToInt32(null);` |
| `Parse` |Apenas para converter uma `string` para seu tipo correspondente. |`int i = int.Parse("10");` |



# Implicit Casting

A conversão implicita é quando  podemos executar essa transformação apenas com a passagem de dados

E os tipos são compatíveis entre si, como por exemplo:

* int -> long

* float -> double

* short -> int

* char -> int

## Exemplos:

```CSHARP
float value = 25.8f;
int newValue = (int)value; // Conversão implícita
```

Note:

Nesse caso, estamos atribuindo um valor do tipo float à uma variável do tipo int. O compilador irá realizar a conversão automaticamente, pois o tipo float pode ser convertido em um inteiro sem perda de precisão.



# Explicit Casting

Ocorre quando os tipos não são compativeis e é dada pelo uso do tipo entre parênteses antes da atribuição

## Exemplos:

```CSHARP
int inteiro = 100;
uint inteiroSemSinal = (uint)inteiro; //Conversão de int para uint
```



# Parse

O método `Parse` é uma funcionalidade estática presente na maioria dos tipos de valor do C# (como `int`, `double`, `bool`, `DateTime`, etc.). Sua função específica é converter a representação em string de um valor em uma instância real daquele tipo.

É a ferramenta ideal quando você tem um texto e precisa que ele se torne um tipo de dado funcional.

```CSHARP
string textoNumero = "123";

// O método Parse converte a string "123" para o inteiro 123.
int numero = int.Parse(textoNumero);

Console.WriteLine(numero * 2); // Saída: 246
Console.WriteLine(numero.GetType().Name); // Saída: Int32
```

## 

O Risco do `Parse`: Exceções

O método `Parse` é otimista: ele assume que a conversão será bem-sucedida. Se a string de entrada não estiver em um formato válido ou for nula, ele lançará uma exceção, interrompendo o fluxo normal do programa.

* `FormatException`: A string não corresponde ao formato esperado.

* `ArgumentNullException`: A string fornecida é `null`.

* `OverflowException`: O número na string é grande ou pequeno demais para o tipo de destino.

Para usar `Parse` de forma segura, você deve envolvê-lo em um bloco `try-catch`:

```CSHARP
string entradaUsuario = "não é um número";
try
{
    int resultado = int.Parse(entradaUsuario);
    Console.WriteLine($"Conversão bem-sucedida: {resultado}");
}
catch (FormatException)
{
    Console.WriteLine("Erro: O formato da entrada é inválido.");
}
catch (ArgumentNullException)
{
    Console.WriteLine("Erro: A entrada não pode ser nula.");
}
```

## 

A Alternativa Segura e Eficiente: `TryParse`

Lançar e capturar exceções é um processo computacionalmente caro. Para cenários de validação (como processar input de um usuário), onde uma falha de conversão é um evento esperado, o C# oferece uma alternativa muito mais eficiente: o padrão `TryParse`.

O método `TryParse` tenta realizar a conversão e, em vez de lançar uma exceção, ele retorna um `bool` que indica se a operação foi bem-sucedida. O valor convertido é retornado através de um parâmetro `out`.

```CSHARP
string entradaDoUsuario = "42";

// Tenta converter a string. 
// Se conseguir, 'numeroConvertido' receberá o valor 42 e o método retornará 'true'.
// Se não conseguir, 'numeroConvertido' receberá 0 (valor padrão) e o método retornará 'false'.
if (int.TryParse(entradaDoUsuario, out int numeroConvertido))
{
    // Este bloco só executa se a conversão funcionar
    Console.WriteLine($"Sucesso! O número é {numeroConvertido}");
}
else
{
    // Este bloco só executa se a conversão falhar
    Console.WriteLine("Falha na conversão. Por favor, insira um número válido.");
}
```

### 

Por que `TryParse` é melhor?

1. Performance: Evita o alto custo de criar e gerenciar exceções.

2. Clareza: O código fica mais limpo e a intenção (validar e converter) é mais clara.

3. Simplicidade: Permite a validação e a atribuição em uma única linha dentro de uma condição `if`.

## 

Tabela de Referência de Métodos `Parse` e `TryParse`

Abaixo está uma tabela de referência para os métodos `Parse` e `TryParse` nos tipos mais comuns.

| Tipo |Método `Parse` (Lança Exceção) |Método `TryParse` (Retorna `bool`) |
----------------------------------------------------------------------------
| `int` |`int.Parse(str)` |`int.TryParse(str, out int val)` |
| `long` |`long.Parse(str)` |`long.TryParse(str, out long val)` |
| `double` |`double.Parse(str)` |`double.TryParse(str, out double val)` |
| `decimal` |`decimal.Parse(str)` |`decimal.TryParse(str, out decimal val)` |
| `float` |`float.Parse(str)` |`float.TryParse(str, out float val)` |
| `bool` |`bool.Parse(str)` |`bool.TryParse(str, out bool val)` |
| `DateTime` |`DateTime.Parse(str)` |`DateTime.TryParse(str, out DateTime val)` |
| `Guid` |`Guid.Parse(str)` |`Guid.TryParse(str, out Guid val)` |

## Tópico Avançado: Sensibilidade à Cultura

Um detalhe crucial que diferencia um desenvolvedor sênior é o entendimento sobre cultura (`CultureInfo`). O método `Parse` por padrão utiliza as regras de formatação do sistema operacional onde o código está rodando.

Isso pode causar bugs difíceis de rastrear. Por exemplo, a string `"1,234.56"` representa mil duzentos e trinta e quatro em português, mas em inglês o `.` é o separador decimal.

```CSHARP
using System.Globalization;

string numeroAlemao = "1.234,56"; // Ponto como separador de milhar, vírgula como decimal

// Usando a cultura alemã (de-DE) para interpretar a string corretamente
CultureInfo culturaAlema = new CultureInfo("de-DE");
double valor = double.Parse(numeroAlemao, culturaAlema);

Console.WriteLine(valor); // Saída: 1234.56 (convertido para o formato padrão do sistema)

// A linha abaixo lançaria uma FormatException em um sistema com cultura pt-BR ou en-US
// double valorIncorreto = double.Parse(numeroAlemao); 
```

O `TryParse` também possui sobrecargas que aceitam `CultureInfo` para uma conversão segura e culturalmente correta.

## 

Guia de Decisão: `Parse` vs. `TryParse`

* Use `Parse` quando: * Você tem 100% de certeza que a string é válida (ex: vem de uma fonte interna confiável, como um valor fixo no código ou um banco de dados com dados já validados). * Uma falha na conversão representa um erro excepcional e inesperado no seu sistema.

* Use `TryParse` quando: * A string vem de uma fonte externa e não confiável (input de usuário, arquivo de texto, resposta de API, etc.). * A falha na conversão é um cenário esperado e faz parte da lógica de validação do seu programa.



# Convert

A classe `System.Convert` é uma ferramenta essencial no C#, fornecendo um conjunto de métodos estáticos para realizar conversões entre os tipos de dados base (primitivos). Ela atua como uma solução robusta e explícita, oferecendo mais flexibilidade e segurança em comparação com o casting direto ou os métodos `Parse`.

Pense na classe `Convert` como um tradutor universal para os tipos de dados do .NET.

## 

`Convert` vs. Casting vs. `Parse`

É crucial para um desenvolvedor C# entender quando usar cada mecanismo de conversão.

| Mecanismo |Sintaxe |Uso Principal |Comportamento em Falha |
-------------------------------------------------------------
| Casting |`(novoTipo)valor;` |Entre tipos numéricos compatíveis ou em hierarquias de classes (upcasting/downcasting). |`InvalidCastException` em tempo de execução se a conversão for inválida. |
| Parse |`tipo.Parse(string);` |Exclusivamente para converter uma `string` em seu tipo correspondente. |`FormatException` se a string não estiver no formato correto; `ArgumentNullException` se for nula. |
| Convert |`Convert.ToNovoTipo(valor);` |Entre uma grande variedade de tipos (números, strings, booleanos, objetos, etc.). |`FormatException` para strings mal formatadas; `OverflowException` para estouro de capacidade. |

### 

A Grande Vantagem: Tratamento de `null`

A principal diferença e vantagem da classe `Convert` é a forma como ela lida com valores `null`. Ao contrário do casting ou do `Parse`, que lançam uma exceção, `Convert` retorna o valor padrão do tipo de destino.

```CSHARP
string textoNulo = null;

// Lança ArgumentNullException
// int numeroComParse = int.Parse(textoNulo); 

// Retorna 0 (valor padrão de int)
int numeroComConvert = Convert.ToInt32(textoNulo); 

Console.WriteLine(numeroComConvert); // Saída: 0
```

Esse comportamento torna o `Convert` a escolha mais segura e previsível ao lidar com dados que podem ser nulos, como valores vindos de bancos de dados, APIs ou input do usuário.

## Comportamento de Arredondamento

Ao converter um número de ponto flutuante (como `double` ou `float`) para um inteiro, a classe `Convert` utiliza o "Arredondamento do Banqueiro" (`MidpointRounding.ToEven`). Neste método, números que estão exatamente no meio (como 2.5 ou 3.5) são arredondados para o número par mais próximo.

```CSHARP
double valor1 = 2.5;
double valor2 = 3.5;
double valor3 = 4.6;

Console.WriteLine(Convert.ToInt32(valor1)); // Saída: 2 (arredonda para o par mais próximo)
Console.WriteLine(Convert.ToInt32(valor2)); // Saída: 4 (arredonda para o par mais próximo)
Console.WriteLine(Convert.ToInt32(valor3)); // Saída: 5 (arredondamento normal)
```

## Exemplos de Conversões Comuns

A classe `Convert` é extremamente versátil.

```CSHARP
// De string para int
string strNumero = "123";
int numero = Convert.ToInt32(strNumero);

// De int para string
int valorInt = 456;
string strValor = Convert.ToString(valorInt);

// De double para int (com arredondamento)
double salario = 2589.72;
int salarioInt = Convert.ToInt32(salario); // Resultado: 2590

// De string para booleano (não diferencia maiúsculas/minúsculas)
string strBool = "True";
bool valorBool = Convert.ToBoolean(strBool); // Resultado: true

// De qualquer tipo para string
bool ativo = false;
string strAtivo = Convert.ToString(ativo); // Resultado: "False"

// De object para int (seguro contra nulos)
object objValor = null;
int valorObj = Convert.ToInt32(objValor); // Resultado: 0
```

## 

Tabela de Referência de Métodos `Convert`

Abaixo está uma tabela de referência rápida para os métodos de conversão mais utilizados da classe `Convert`.

| Método |Descrição |Exemplo de Uso |
-------------------------------------
| `Convert.ToBoolean(valor)` |Converte um valor (string, número, etc.) para `bool`. |`bool b = Convert.ToBoolean("true");` |
| `Convert.ToByte(valor)` |Converte um valor para `byte` (inteiro de 8 bits sem sinal). |`byte y = Convert.ToByte(12);` |
| `Convert.ToChar(valor)` |Converte uma string de um caractere ou número para `char`. |`char c = Convert.ToChar('A');` |
| `Convert.ToDateTime(valor)` |Converte uma string (em formato de data/hora válido) para `DateTime`. |`DateTime dt = Convert.ToDateTime("2025-07-14");` |
| `Convert.ToDecimal(valor)` |Converte um valor para `decimal` (alta precisão). |`decimal d = Convert.ToDecimal("123.45");` |
| `Convert.ToDouble(valor)` |Converte um valor para `double` (ponto flutuante de precisão dupla). |`double o = Convert.ToDouble("123.45");` |
| `Convert.ToInt16(valor)` |Converte um valor para `short` (inteiro de 16 bits). |`short s = Convert.ToInt16("123");` |
| `Convert.ToInt32(valor)` |Converte um valor para `int` (inteiro de 32 bits). |`int i = Convert.ToInt32("123");` |
| `Convert.ToInt64(valor)` |Converte um valor para `long` (inteiro de 64 bits). |`long l = Convert.ToInt64("123");` |
| `Convert.ToString(valor)` |Converte qualquer tipo base para sua representação em `string`. |`string str = Convert.ToString(123.45);` |

## Tópico Avançado: Conversão de Base Numérica

Um recurso poderoso e muitas vezes subutilizado da classe `Convert` é a capacidade de converter números entre diferentes bases (binário, octal, decimal, hexadecimal).

```CSHARP
// Convertendo um inteiro para sua representação em string binária e hexadecimal
int numeroDecimal = 255;
string binario = Convert.ToString(numeroDecimal, 2);    // Base 2
string hexadecimal = Convert.ToString(numeroDecimal, 16); // Base 16

Console.WriteLine($"Decimal: {numeroDecimal}");   // Saída: Decimal: 255
Console.WriteLine($"Binário: {binario}");       // Saída: Binário: 11111111
Console.WriteLine($"Hexadecimal: {hexadecimal.ToUpper()}"); // Saída: Hexadecimal: FF

// Convertendo de volta para inteiro
int deBinario = Convert.ToInt32("11111111", 2);
int deHexadecimal = Convert.ToInt32("FF", 16);

Console.WriteLine($"De Binário: {deBinario}");       // Saída: De Binário: 255
Console.WriteLine($"De Hexadecimal: {deHexadecimal}"); // Saída: De Hexadecimal: 255
```

## Tratamento de Exceções

Apesar de sua flexibilidade, `Convert` ainda pode lançar exceções se a conversão for impossível.

* `FormatException`: Ocorre se uma string de entrada não estiver em um formato válido para o tipo de destino.

* `OverflowException`: Ocorre se o número de origem for muito grande (ou muito pequeno) para caber na capacidade do tipo de destino.

É uma boa prática envolver as chamadas de `Convert` em um bloco `try-catch` quando a entrada não for confiável.

```CSHARP
string valorGigante = "9999999999999999999999999999";
try
{
    int resultado = Convert.ToInt32(valorGigante);
    Console.WriteLine(resultado);
}
catch (FormatException ex)
{
    Console.WriteLine("Erro de formato: A string não é um número válido.");
}
catch (OverflowException ex)
{
    Console.WriteLine("Erro de Overflow: O número é grande demais para um inteiro.");
}
```

Tip:

Para cenários onde você espera que a conversão de uma string possa falhar e não quer lidar com exceções, a abordagem `tipo.TryParse()` continua sendo a melhor prática.



# Operadores Aritméticos

Operadores aritméticos são símbolos usados para realizar cálculos matemáticos em operandos numéricos. São a base da manipulação de números em C#.

## Tabela de Operadores Aritméticos

| Operador |Descrição |Exemplo |Resultado |
-------------------------------------------
| `+` |Adição |`5 + 3` |`8` |
| `-` |Subtração |`5 - 3` |`2` |
| `*` |Multiplicação |`5 * 3` |`15` |
| `/` |Divisão |`5 / 3` |`1` |
| `%` |Módulo (Resto da Divisão) |`5 % 3` |`2` |

### A Armadilha da Divisão de Inteiros

Um ponto de atenção crucial em C# é a divisão entre dois números inteiros. O resultado será sempre um inteiro, com a parte decimal sendo truncada (removida), não arredondada.

```CSHARP
int a = 5;
int b = 3;

// Como 'a' e 'b' são inteiros, o resultado é 1, não 1.66.
int resultadoInteiro = a / b; 
Console.WriteLine(resultadoInteiro); // Saída: 1
```

Para obter um resultado com precisão decimal, pelo menos um dos operandos deve ser um tipo de ponto flutuante (`double`, `float`, `decimal`).

```CSHARP
// Convertendo (casting) um dos inteiros para double antes da divisão
double resultadoDouble = (double)a / b;
Console.WriteLine(resultadoDouble); // Saída: 1.66666...
```

## Operadores de Incremento e Decremento

Estes operadores unários modificam uma variável, adicionando ou subtraindo 1. A posição do operador (`++` ou `--`) em relação à variável muda o comportamento da expressão.

* Pós-fixado (`variavel++` ou `variavel--`): O valor da variável é primeiro retornado para a expressão e depois modificado.

* Pré-fixado (`++variavel` ou `--variavel`): O valor da variável é primeiro modificado e depois o novo valor é retornado para a expressão.

```CSHARP
int a = 5;
int b = 5;

// Pós-fixado: 'c' recebe o valor original de 'a' (5), depois 'a' vira 6.
int c = a++; 

// Pré-fixado: 'b' primeiro vira 6, depois 'd' recebe o novo valor de 'b' (6).
int d = ++b;

Console.WriteLine($"a: {a}, c: {c}"); // Saída: a: 6, c: 5
Console.WriteLine($"b: {b}, d: {d}"); // Saída: b: 6, d: 6
```

## Precedência de Operadores

A precedência define a ordem em que as operações são executadas em uma expressão complexa. Operadores com maior precedência são avaliados primeiro.

| Ordem |Categoria |Operadores |
--------------------------------
| 1 |Primário |`()` (Parênteses para forçar a ordem) |
| 2 |Unário |`++` (pré-fixado), `--` (pré-fixado), `+` (positivo), `-` (negativo) |
| 3 |Multiplicativo |`*`, `/`, `%` |
| 4 |Aditivo |`+`, `-` |
| 5 |Pós-fixado |`++` (pós-fixado), `--` (pós-fixado) |

Note:

O operador de exponenciação (`**`) não existe em C#. Para cálculos de potência, utilize o método `Math.Pow(base, expoente)`.

Você pode usar parênteses `()` para forçar uma ordem de avaliação diferente da padrão, o que também melhora a legibilidade do código.

```CSHARP
// Sem parênteses: 2 * 3 = 6, depois 6 + 4 = 10
int resultado1 = 2 * 3 + 4; // resultado1 = 10

// Com parênteses: 3 + 4 = 7, depois 2 * 7 = 14
int resultado2 = 2 * (3 + 4); // resultado2 = 14
```



# Operadores de Atribuição

Operadores de atribuição são usados para designar um valor a uma variável. O operador de atribuição fundamental é o sinal de igual (`=`), que atribui o valor do operando à direita para a variável à esquerda.

```CSHARP
// A variável 'idade' recebe o valor 30.
int idade = 30;

// A variável 'nome' recebe o valor da string "Alice".
string nome = "Alice";
```

## Operadores de Atribuição Composta

C# oferece operadores de atribuição composta que combinam uma operação aritmética com a atribuição. Eles são atalhos úteis que tornam o código mais conciso e, em alguns casos, mais eficiente.

A expressão `x op= y` é, em geral, equivalente a `x = x op y`, onde `op` é um operador aritmético.

### Tabela de Operadores de Atribuição Composta

| Operador |Exemplo |Equivalente a |Descrição |
-----------------------------------------------
| `+=` |`x += y` |`x = x + y` |Adiciona `y` a `x` e atribui o resultado a `x`. |
| `-=` |`x -= y` |`x = x - y` |Subtrai `y` de `x` e atribui o resultado a `x`. |
| `*=` |`x *= y` |`x = x * y` |Multiplica `x` por `y` e atribui o resultado a `x`. |
| `/=` |`x /= y` |`x = x / y` |Divide `x` por `y` e atribui o resultado a `x`. |
| `%=` |`x %= y` |`x = x % y` |Calcula o resto da divisão de `x` por `y` e atribui a `x`. |

### Exemplos Práticos

```CSHARP
int saldo = 100;

saldo += 50; // saldo agora é 150 (100 + 50)
Console.WriteLine($"Após depósito: {saldo}");

saldo -= 30; // saldo agora é 120 (150 - 30)
Console.WriteLine($"Após saque: {saldo}");

int multiplicador = 5;
multiplicador *= 2; // multiplicador agora é 10 (5 * 2)
Console.WriteLine($"Multiplicado: {multiplicador}");

int dividendo = 20;
dividendo /= 4; // dividendo agora é 5 (20 / 4)
Console.WriteLine($"Dividido: {dividendo}");

int resto = 10;
resto %= 3; // resto agora é 1 (10 % 3)
Console.WriteLine($"Resto: {resto}");
```

Note:

O uso de operadores de atribuição composta é considerado uma boa prática em C#, pois pode levar a um código mais limpo e fácil de ler, especialmente em operações de atualização de variáveis.



# Operadores de Comparação

Operadores de comparação (ou relacionais) são usados para comparar dois operandos. O resultado de uma operação de comparação é sempre um valor booleano: `true` ou `false`. Eles são a base para a tomada de decisões e o controle de fluxo em C#, sendo essenciais em estruturas como `if`, `while` e `for`.

## Tabela de Operadores de Comparação

| Operador |Descrição |Exemplo (com `a = 5`, `b = 10`) |Resultado |
-------------------------------------------------------------------
| `==` |Igual a |`a == 5` |`true` |
| `!=` |Diferente de |`a != b` |`true` |
| `<` |Menor que |`a < b` |`true` |
| `>` |Maior que |`a > b` |`false` |
| `<=` |Menor ou igual a |`a <= 5` |`true` |
| `>=` |Maior ou igual a |`b >= 10` |`true` |

## Exemplos de Uso no Controle de Fluxo

O principal uso dos operadores de comparação é em declarações condicionais para direcionar o fluxo do programa.

```CSHARP
int idade = 18;

// Usando '==' para verificar igualdade
if (idade == 18)
{
    Console.WriteLine("Tem exatamente 18 anos.");
}

// Usando '>=' para verificar maioridade
if (idade >= 18)
{
    Console.WriteLine("É maior de idade.");
}

// Usando '!=' para verificar diferença
string nome = "Alice";
if (nome != "Bob")
{
    Console.WriteLine("O nome não é Bob.");
}

// Usando em um loop 'while'
int contador = 0;
while (contador < 5)
{
    Console.WriteLine($"O contador é {contador}");
    contador++; // Essencial para evitar um loop infinito
}
```

## Comparando Tipos de Referência vs. Tipos de Valor

É crucial entender a diferença ao usar `==` com tipos de valor e tipos de referência.

* Tipos de Valor (`int`, `double`, `bool`, `struct`): O operador `==` compara os valores reais contidos nas variáveis. ```CSHARP int a = 10; int b = 10; Console.WriteLine(a == b); // Saída: true (porque 10 é igual a 10) ```

* Tipos de Referência (`string`, `class`, `array`): Por padrão, o operador `==` compara as referências de memória, ou seja, ele verifica se as duas variáveis apontam para o mesmo objeto na memória, e não se seus conteúdos são iguais. ```CSHARP public class Pessoa { public string Nome { get; set; } } Pessoa p1 = new Pessoa { Nome = "Alex" }; Pessoa p2 = new Pessoa { Nome = "Alex" }; Pessoa p3 = p1; Console.WriteLine(p1 == p2); // Saída: false (são dois objetos diferentes na memória) Console.WriteLine(p1 == p3); // Saída: true (ambos apontam para o mesmo objeto) ```

Note:

O tipo `string` é uma exceção especial. Embora seja um tipo de referência, o operador `==` foi sobrecarregado para comparar o **conteúdo** das strings, não suas referências. Portanto, `"hello" == "hello"` retorna `true`, que é o comportamento que a maioria dos desenvolvedores espera.



# Operadores Lógicos e Condicionais

Em C#, operadores lógicos e condicionais são usados para trabalhar com valores booleanos (`true`/`false`) e para tomar decisões baseadas em condições. Eles são a cola que une as comparações para criar regras de negócio e fluxos de controle complexos.

## Operadores Lógicos Condicionais (Short-Circuiting)

Estes são os operadores lógicos mais comuns. Eles são chamados de "condicionais" ou "short-circuiting" porque só avaliam o segundo operando se for estritamente necessário.

| Operador |Nome |Exemplo |Descrição |
--------------------------------------
| `&&` |E (AND) |`expr1 && expr2` |Retorna `true` somente se ambas as expressões forem `true`. |
| `\|\|` |OU (OR) |`expr1 \|\| expr2` |Retorna `true` se pelo menos uma das expressões for `true`. |
| `!` |NÃO (NOT) |`!expr1` |Inverte o valor booleano da expressão (de `true` para `false` e vice-versa). |

### A Importância do Short-Circuiting

* `&&` (E): Se a primeira expressão (`expr1`) for `false`, o resultado da operação será sempre `false`, independentemente da segunda expressão. Portanto, `expr2` não é avaliada. Isso é útil para evitar erros. ```CSHARP string nome = null; // A segunda verificação (nome.Length > 0) nunca é executada, evitando uma NullReferenceException. if (nome != null && nome.Length > 0) { Console.WriteLine("Nome válido."); } else { Console.WriteLine("Nome inválido ou nulo."); } ```

* `||` (OU): Se a primeira expressão (`expr1`) for `true`, o resultado da operação será sempre `true`. Portanto, `expr2` não é avaliada. Isso pode ser usado para otimização. ```CSHARP bool usuarioAdmin = true; // A função VerificarPermissao() nunca é chamada, economizando processamento. if (usuarioAdmin || VerificarPermissao()) { Console.WriteLine("Acesso concedido."); } ```

## Operadores Condicionais

### 

Operador Ternário (`? :`)

O operador condicional ternário é um atalho conciso para uma instrução `if-else`. Ele avalia uma condição booleana e retorna um de dois valores.

Sintaxe: `condição ? valor_se_verdadeiro : valor_se_falso;`

```CSHARP
int idade = 20;
string status = (idade >= 18) ? "Maior de idade" : "Menor de idade";

Console.WriteLine(status); // Saída: Maior de idade

// O código acima é um atalho para:
// string status;
// if (idade >= 18)
// {
//     status = "Maior de idade";
// }
// else
// {
//     status = "Menor de idade";
// }
```

### 

Operador de Coalescência Nula (`??`)

Este operador é usado para fornecer um valor padrão para tipos de referência ou tipos de valor anuláveis. Ele retorna o operando da esquerda se ele não for nulo; caso contrário, ele retorna o operando da direita.

```CSHARP
string nomeDoBanco = null;

// Se nomeDoBanco for nulo, use "Convidado". Caso contrário, use o próprio valor.
string nomeUsuario = nomeDoBanco ?? "Convidado";

Console.WriteLine(nomeUsuario); // Saída: Convidado

string nomeValido = "Alice";
nomeUsuario = nomeValido ?? "Convidado";
Console.WriteLine(nomeUsuario); // Saída: Alice
```

## Tópico Avançado: Operadores Lógicos Booleanos e Bitwise

C# também possui operadores que parecem lógicos, mas têm um propósito diferente e mais específico. É crucial não confundi-los com os operadores condicionais `&&` e `||`.

### 

Operadores Lógicos Booleanos (`&` e `|`)

Estes operadores são similares a `&&` e `||`, mas com uma diferença fundamental: eles sempre avaliam ambos os operandos, ou seja, não fazem short-circuiting. Seu uso é raro em lógica condicional do dia a dia.

| Operador |Nome |Exemplo |Descrição |
--------------------------------------
| `&` |E (AND) Lógico |`expr1 & expr2` |Retorna `true` se ambas forem `true`. Sempre avalia as duas expressões. |
| `\|` |OU (OR) Lógico |`expr1 \| expr2` |Retorna `true` se uma delas for `true`. Sempre avalia as duas expressões. |
| `^` |OU Exclusivo (XOR) |`expr1 ^ expr2` |Retorna `true` se apenas uma das expressões for `true`. |

### 

Operadores Bitwise (`&`, `|`, `^`, `~`, `<<`, `>>`)

Quando usados com tipos de dados inteiros (`int`, `long`, `byte`, etc.), estes símbolos atuam como operadores bitwise. Eles manipulam a representação binária (os bits) dos números, sendo usados em cenários de baixo nível, como manipulação de flags, criptografia ou otimizações de performance.

* `&` (AND): Compara os bits de dois números. Um bit de resultado é 1 somente se ambos os bits correspondentes forem 1.

* `|` (OR): Compara os bits. Um bit de resultado é 1 se pelo menos um dos bits correspondentes for 1.

* `^` (XOR): Compara os bits. Um bit de resultado é 1 se os bits correspondentes forem diferentes.

* `~` (NOT): Inverte todos os bits de um número.

* `<<` (Shift Left): Desloca os bits para a esquerda, preenchendo com zeros (multiplicação por 2).

* `>>` (Shift Right): Desloca os bits para a direita (divisão por 2).

```CSHARP
// Exemplo de Bitwise AND
//   5 = 0101 (binário)
//   3 = 0011 (binário)
// -------------------
// AND = 0001 (binário) = 1 (decimal)
int resultado = 5 & 3;
Console.WriteLine(resultado); // Saída: 1
```



# Estruturas Condicionais

Estruturas condicionais permitem que um programa execute diferentes blocos de código com base em condições booleanas (`true` ou `false`). Elas são a principal maneira de criar lógica e tomar decisões em C#.

## 

A Estrutura `if`

A instrução `if` é a estrutura condicional mais fundamental. Ela executa um bloco de código somente se a condição especificada for `true`.

Sintaxe:

```
if (condição)
{
    // Bloco de código a ser executado se a condição for verdadeira.
}
```

Exemplo:

```CSHARP
int idade = 20;
if (idade >= 18)
{
    Console.WriteLine("Você é maior de idade.");
}
```

## 

A Estrutura `if-else`

A instrução `else` pode ser adicionada a um `if` para executar um bloco de código alternativo quando a condição do `if` for `false`.

Sintaxe:

```
if (condição)
{
    // Bloco de código se a condição for verdadeira.
}
else
{
    // Bloco de código se a condição for falsa.
}
```

Exemplo:

```CSHARP
int temperatura = 15;
if (temperatura > 25)
{
    Console.WriteLine("Está calor.");
}
else
{
    Console.WriteLine("Não está calor.");
}
```

## 

A Estrutura `if-else if-else`

Para testar múltiplas condições em sequência, você pode usar a estrutura `else if`. O C# avaliará as condições na ordem em que aparecem e executará o primeiro bloco de código cuja condição seja `true`. O bloco `else` final é opcional e serve como uma condição "pega-tudo" se nenhuma das anteriores for satisfeita.

Sintaxe:

```
if (condição1)
{
    // Bloco 1
}
else if (condição2)
{
    // Bloco 2
}
else
{
    // Bloco 3 (opcional)
}
```

Exemplo:

```CSHARP
int numero = 0;

if (numero > 0)
{
    Console.WriteLine("O número é positivo.");
}
else if (numero < 0)
{
    Console.WriteLine("O número é negativo.");
}
else
{
    Console.WriteLine("O número é zero.");
}
```

## Variações de Sintaxe e Boas Práticas

### 

Omissão de Chaves (`{}`)

Em C#, se o bloco de código dentro de uma instrução `if`, `else if` ou `else` contém apenas uma única linha de comando, as chaves `{}` são opcionais.

Exemplo:

```CSHARP
int temperatura = 30;

if (temperatura > 25)
    Console.WriteLine("Está calor.");
else
    Console.WriteLine("Não está calor.");
```

Warning:

Cuidado com a omissão de chaves!

Embora a sintaxe seja permitida, ela é uma fonte comum de bugs. Se você adicionar uma segunda linha de código ao `if` ou `else` sem adicionar as chaves, apenas a primeira linha será condicional. A segunda linha será executada incondicionalmente, o que pode levar a um comportamento inesperado.

Exemplo de Bug:

```CSHARP
bool usuarioLogado = false;

if (usuarioLogado)
    Console.WriteLine("Bem-vindo!");
    RenderizarPainelDeControle(); // Esta linha será executada SEMPRE, mesmo se o usuário não estiver logado!
```

Boa Prática: Para evitar erros e melhorar a legibilidade e a manutenção do código, é altamente recomendável sempre usar chaves, mesmo para blocos de uma única linha.

```CSHARP
// Forma segura e recomendada
if (usuarioLogado)
{
    Console.WriteLine("Bem-vindo!");
}
```

## 

A Instrução `switch`

A instrução `switch` é uma alternativa à estrutura `if-else if-else`, ideal para quando você precisa comparar uma única variável contra uma lista de valores constantes.

* `case`: Define um valor a ser comparado com a variável do `switch`.

* `break`: É obrigatório ao final de cada `case` para sair do `switch` e impedir a execução do próximo `case` (fall-through).

* `default`: É opcional e funciona como o `else` final, sendo executado se nenhum `case` corresponder.

Exemplo:

```CSHARP
int diaDaSemana = 3;
string nomeDoDia;

switch (diaDaSemana)
{
    case 1:
        nomeDoDia = "Domingo";
        break;
    case 2:
        nomeDoDia = "Segunda-feira";
        break;
    case 3:
        nomeDoDia = "Terça-feira";
        break;
    // ... outros casos
    default:
        nomeDoDia = "Dia inválido";
        break;
}

Console.WriteLine(nomeDoDia); // Saída: Terça-feira
```

## 

Expressões `switch` (C# 8.0 e superior)

Versões mais recentes do C# introduziram a expressão `switch`, uma forma mais moderna e concisa que é especialmente útil para atribuir um valor a uma variável com base em uma condição.

* É uma expressão, o que significa que ela retorna um valor.

* Usa a sintaxe `=>` (lambda).

* Não precisa de `case` ou `break`.

* Usa o descarte (`_`) para o caso `default`.

* Suporta pattern matching avançado.

Exemplo:

```CSHARP
int diaDaSemana = 3;

string nomeDoDia = diaDaSemana switch
{
    1 => "Domingo",
    2 => "Segunda-feira",
    3 => "Terça-feira",
    4 => "Quarta-feira",
    5 => "Quinta-feira",
    6 => "Sexta-feira",
    7 => "Sábado",
    _ => "Dia inválido" // Caso default
};

Console.WriteLine(nomeDoDia); // Saída: Terça-feira
```

### 

Quando Usar `if` vs. `switch`

* Use `if-else if`: Para condições complexas, comparações de intervalos (ex: `idade > 18 && idade < 60`) ou quando múltiplas variáveis estão envolvidas.

* Use `switch`: Para comparar uma única variável contra um conjunto de valores constantes e distintos. A expressão `switch` é a abordagem moderna e preferida quando disponível.



# Laço de Repetição for

O laço `for` em C# é uma estrutura de controle de fluxo que permite executar um bloco de código repetidamente. É ideal para situações em que o número de iterações é conhecido antes do início do loop.

A estrutura do `for` é composta por três partes principais, separadas por ponto e vírgula, que controlam a execução do laço:

1. Inicializador (`initializer`): Executado apenas uma vez, no início do laço. Geralmente, é aqui que uma variável de controle do laço é declarada e inicializada.

2. Condição (`condition`): Avaliada antes de cada iteração. Se a condição for `true`, o bloco de código dentro do laço é executado. Se for `false`, o laço é encerrado.

3. Iterador (`iterator`): Executado ao final de cada iteração. Normalmente, é usado para incrementar ou decrementar a variável de controle do laço.

## Sintaxe

A sintaxe básica do laço `for` é a seguinte:

```CSHARP
for (inicializador; condição; iterador)
{
    // Bloco de código a ser executado
}
```

### Exemplo Prático

O exemplo mais comum é iterar um número fixo de vezes. O código abaixo imprime os números de 0 a 9 no console.

```CSHARP
// Imprime os números de 0 a 9
for (int i = 0; i < 10; i++)
{
    Console.WriteLine($"O valor de i é: {i}");
}
```

Análise do Exemplo:

* `int i = 0;`: A variável `i` é declarada e inicializada com `0`. Isso acontece apenas uma vez.

* `i < 10;`: Antes de cada iteração, o programa verifica se `i` é menor que `10`.

* `i++`: Ao final de cada iteração, o valor de `i` é incrementado em 1.

* `Console.WriteLine(...)`: Este é o corpo do laço, que é executado enquanto a condição `i < 10` for verdadeira.

## Casos de Uso e Variações

### Laço Infinito

É possível criar um laço infinito omitindo todas as três partes da declaração `for`. Nesses casos, é preciso ter um mecanismo de saída dentro do corpo do laço, como a instrução `break`.

```CSHARP
for (;;)
{
    Console.WriteLine("Este é um laço infinito! Pressione 's' para sair.");
    if (Console.ReadKey().KeyChar == 's')
    {
        break; // Encerra o laço
    }
    Console.WriteLine();
}
```

### Múltiplas Variáveis

Você pode inicializar e iterar múltiplas variáveis dentro de um laço `for`.

```CSHARP
for (int i = 0, j = 10; i <= 10; i++, j--)
{
    Console.WriteLine($"i = {i}, j = {j}");
}
```

### Omitindo Partes

Qualquer uma das partes do `for` (inicializador, condição ou iterador) pode ser omitida, desde que a lógica seja controlada de outra forma.

```CSHARP
int i = 0;
for (; i < 5; )
{
    Console.WriteLine(i);
    i++; // O iterador é movido para dentro do corpo do laço
}
```

O laço `for` é uma ferramenta poderosa e flexível para controlar a repetição de tarefas em seus programas C#.



# Laço de Repetição while

O laço `while` em C# é uma estrutura de controle que executa um bloco de código repetidamente enquanto uma determinada condição booleana for `true`. Diferente do laço `for`, o `while` é ideal para situações em que o número de iterações não é conhecido de antemão.

A principal característica do `while` é que a condição é testada antes da execução do bloco de código. Se a condição for `false` na primeira verificação, o corpo do laço nunca será executado.

## Sintaxe

A sintaxe do laço `while` é simples e direta:

```CSHARP
while (condição)
{
    // Bloco de código a ser executado
}
```

* `condição`: Uma expressão booleana (`true` ou `false`). O laço continua enquanto esta expressão for `true`.

### Exemplo Prático

Vamos supor que queremos ler a entrada do usuário até que ele digite a palavra "sair".

```CSHARP
string entrada = "";
while (entrada.ToLower() != "sair")
{
    Console.Write("Digite algo (ou 'sair' para terminar): ");
    entrada = Console.ReadLine();
    Console.WriteLine($"Você digitou: {entrada}");
}

Console.WriteLine("Programa encerrado.");
```

Análise do Exemplo:

1. A variável `entrada` é inicializada como uma string vazia.

2. A condição `entrada.ToLower() != "sair"` é verificada. Na primeira vez, `"" != "sair"` é `true`, então o laço começa.

3. Dentro do laço, o programa solicita a entrada do usuário e a armazena na variável `entrada`.

4. O laço se repete, e a condição é verificada novamente com o novo valor de `entrada`.

5. Quando o usuário finalmente digita "sair", a condição se torna `false`, e o laço é encerrado.

## Cuidado com Laços Infinitos

Um erro comum ao usar o `while` é criar um laço infinito. Isso acontece se a condição de parada nunca for alcançada. É crucial garantir que alguma variável dentro da condição seja modificada no corpo do laço para que, em algum momento, a condição se torne `false`.

Exemplo de laço infinito (EVITAR):

```CSHARP
int i = 0;
while (i < 10)
{
    // Erro: a variável 'i' nunca é incrementada.
    // Este laço executará para sempre.
    Console.WriteLine("Isso é um laço infinito!");
}
```

Para corrigir, basta adicionar o iterador:

```CSHARP
int i = 0;
while (i < 10)
{
    Console.WriteLine(i);
    i++; // Correção: garante que o laço terminará
}
```

O laço `while` é fundamental para algoritmos onde a repetição depende de um estado que muda durante a execução, como processamento de dados, interação com o usuário ou espera por um evento.



# Laço de Repetição do-while

O laço `do-while` é uma variação do laço `while`. A principal e mais importante diferença é que o `do-while` garante que o bloco de código seja executado pelo menos uma vez.

Isso ocorre porque a condição booleana é verificada ao final de cada iteração, e não no início.

## Sintaxe

A sintaxe do `do-while` reflete essa característica: o bloco `do` vem antes da verificação `while`.

```CSHARP
do
{
    // Bloco de código a ser executado
} while (condição);
```

* `do { ... }`: O bloco de código que será executado.

* `while (condição)`: A expressão booleana que é avaliada no final de cada iteração. Se for `true`, o laço continua; se for `false`, ele termina. Note o ponto e vírgula obrigatório no final.

### Exemplo Prático

O `do-while` é especialmente útil para menus de opções ou para validar a entrada do usuário, onde você precisa executar a ação (mostrar o menu, pedir a entrada) pelo menos uma vez.

Neste exemplo, o programa pede ao usuário para inserir um número entre 1 e 10. O laço continuará até que uma entrada válida seja fornecida.

```CSHARP
int numero;
do
{
    Console.Write("Digite um número entre 1 e 10: ");
    string entrada = Console.ReadLine();
    // Tenta converter a entrada para um inteiro.
    // int.TryParse retorna true se a conversão for bem-sucedida.
    int.TryParse(entrada, out numero);

    if (numero < 1 || numero > 10)
    {
        Console.WriteLine("Entrada inválida. Tente novamente.");
    }

} while (numero < 1 || numero > 10);

Console.WriteLine($"Ótimo! Você digitou o número válido: {numero}");
```

Análise do Exemplo:

1. O bloco `do` é executado imediatamente. O programa solicita um número sem qualquer verificação prévia.

2. A entrada do usuário é lida e o programa tenta convertê-la para um inteiro.

3. Ao final do bloco, a condição `while (numero < 1 || numero > 10)` é verificada.

4. Se o número estiver fora do intervalo desejado (ou se `TryParse` falhar, deixando `numero` como `0`), a condição será `true`, e o laço se repetirá.

5. O laço só termina quando o usuário digita um número válido entre 1 e 10.

## 

`while` vs. `do-while`: Qual Usar?

* Use `while` quando você não tem certeza se o laço precisa ser executado. A execução depende inteiramente da condição inicial. * Exemplo: Processar itens em uma lista. Se a lista estiver vazia, o laço não executa.

* Use `do-while` quando você precisa que o corpo do laço seja executado pelo menos uma vez, independentemente da condição. * Exemplo: Apresentar um menu de opções ao usuário. O menu deve ser exibido antes que o usuário possa fazer uma escolha.



# Funções (Métodos com Retorno)

Em programação, uma "função" é um bloco de código reutilizável que executa uma tarefa e retorna um valor. Em C#, o termo técnico é método com tipo de retorno. A principal finalidade de uma função é processar dados de entrada e produzir um resultado, sem (idealmente) causar efeitos colaterais em outras partes do programa.

## Declaração

A sintaxe para declarar um método com retorno é:

```CSHARP
[modificador_de_acesso] static [tipo_de_retorno] [NomeDaFuncao]([parametros])
{
    // Corpo da função
    return [valor_a_retornar];
}
```

* `[tipo_de_retorno]`: O tipo de dado que a função irá retornar (`int`, `string`, `bool`, ou um tipo complexo). Não pode ser `void`.

* `return`: A palavra-chave que envia o resultado de volta e encerra a função. O valor retornado deve ser compatível com o `tipo_de_retorno`.

### Exemplo: Função Pura

Uma função "pura" é aquela cujo resultado depende exclusivamente de seus parâmetros de entrada, sem interagir com ou modificar estados externos. Elas são previsíveis e fáceis de testar.

```CSHARP
// Função pura que calcula o preço com desconto
public static decimal CalcularPrecoFinal(decimal precoOriginal, decimal percentualDesconto)
{
    decimal valorDesconto = precoOriginal * (percentualDesconto / 100);
    return precoOriginal - valorDesconto;
}

// Uso
decimal preco = CalcularPrecoFinal(150.0m, 10.0m); // Retorna 135.0m
```

## Parâmetros Avançados

### 

Passagem por Referência: `ref` vs. `out`

Por padrão, os tipos de valor (como `int`, `double`, `bool`) são passados para métodos por valor (pass-by-value). Isso significa que o método recebe uma cópia da variável, e qualquer alteração dentro do método não afeta a variável original.

As palavras-chave `ref` e `out` mudam esse comportamento, permitindo passar a variável por referência (pass-by-reference). O método recebe uma referência à localização da variável na memória, permitindo que ele modifique o valor original. Embora pareçam semelhantes, eles têm propósitos e regras diferentes.

#### 

A Palavra-Chave `ref`

Usa-se `ref` quando você quer que um método leia e potencialmente modifique uma variável existente.

Contrato do `ref`:

1. A variável deve ser inicializada pelo código que chama o método antes de ser passada.

2. O método pode ler o valor do parâmetro antes de modificá-lo.

Caso de Uso: Ideal para quando uma função precisa alterar o estado de uma variável de entrada. Pense em um fluxo de dados bidirecional: o valor entra no método e pode sair modificado.

```CSHARP
// Função que adiciona juros a um saldo existente
public static void AdicionarJuros(ref decimal saldo, decimal taxaDeJuros)
{
    decimal juros = saldo * taxaDeJuros;
    saldo += juros; // Modifica a variável original
}

// Uso
decimal minhaPoupanca = 1000m;
AdicionarJuros(ref minhaPoupanca, 0.05m);
Console.WriteLine(minhaPoupanca); // Saída: 1050
```

#### 

A Palavra-Chave `out`

Usa-se `out` quando o propósito principal de um método é retornar múltiplos valores ou quando uma operação de "tentativa" (como `TryParse`) precisa retornar um status de sucesso (`bool`) e o resultado da operação.

Contrato do `out`:

1. A variável passada como `out` não precisa ser inicializada antes da chamada.

2. O método é obrigado a atribuir um valor ao parâmetro `out` antes de retornar.

3. O método não pode ler o valor do parâmetro `out` antes de atribuir um valor a ele.

Caso de Uso: Perfeito para quando uma função precisa "produzir" um valor sem ter um valor de entrada. O fluxo de dados é unidirecional: o valor apenas sai do método.

```CSHARP
// Função que tenta dividir e retorna o quociente e o resto
public static bool TentarDividir(int dividendo, int divisor, out int quociente, out int resto)
{
    quociente = 0;
    resto = 0;
    if (divisor == 0)
    {
        return false; // Falha na operação
    }

    quociente = dividendo / divisor;
    resto = dividendo % divisor;
    return true; // Sucesso
}

// Uso
if (TentarDividir(10, 3, out int q, out int r))
{
    Console.WriteLine($"Quociente: {q}, Resto: {r}"); // Saída: Quociente: 3, Resto: 1
}
```

### 

Tabela Comparativa: `ref` vs. `out`

| Característica |`ref` |`out` |
--------------------------------
| Propósito |Modificar uma variável existente. |Retornar um ou mais valores. |
| Inicialização |Obrigatória antes da chamada. |Não necessária antes da chamada. |
| Atribuição no Método |Opcional. |Obrigatória antes do retorno. |
| Fluxo de Dados |Bidirecional (Entrada e Saída). |Unidirecional (Apenas Saída). |

### Parâmetros Opcionais e Argumentos Nomeados

Você pode atribuir valores padrão aos parâmetros, tornando-os opcionais. Para evitar ambiguidade, você pode usar argumentos nomeados na chamada da função.

```CSHARP
// 'logCompleto' é um parâmetro opcional
public static void RegistrarLog(string mensagem, bool logCompleto = false)
{
    string timestamp = DateTime.Now.ToString();
    if (logCompleto)
    {
        Console.WriteLine($"[LOG COMPLETO - {timestamp}] {mensagem}");
    }
    else
    {
        Console.WriteLine($"[LOG - {timestamp}] {mensagem}");
    }
}

// Uso
RegistrarLog("Iniciando processo..."); // Usa o valor padrão (false)
RegistrarLog("Erro crítico!", true); // Passa o valor explicitamente
RegistrarLog(logCompleto: true, mensagem: "Ordem invertida com argumentos nomeados.");
```

## Funções Recursivas

Uma função recursiva é aquela que chama a si mesma. É uma técnica poderosa para resolver problemas que podem ser divididos em subproblemas menores e idênticos. É crucial ter uma condição de parada para evitar um loop infinito (stack overflow).

```CSHARP
// Calcula o fatorial de um número usando recursão
public static int Fatorial(int n)
{
    // Condição de parada
    if (n == 0)
    {
        return 1;
    }
    
    // Chamada recursiva
    return n * Fatorial(n - 1);
}

// Uso
int resultado = Fatorial(5); // 5 * 4 * 3 * 2 * 1 = 120
```

## 

Expression-Bodied Members (`=>`)

Para funções que contêm apenas uma única instrução `return`, você pode usar uma sintaxe mais concisa com `=>`.

```CSHARP
// Função de soma reescrita
public static int Somar(int a, int b) => a + b;

// Função Fatorial reescrita com expressão condicional ternária
public static int Fatorial(int n) => n == 0 ? 1 : n * Fatorial(n - 1);
```



# Procedimentos

Em C#, o termo "procedimento" é mais conhecido como um método que não retorna nenhum valor, indicado pela palavra-chave `void`. O propósito principal de um método `void` é executar uma ação e causar um efeito colateral (side effect), como modificar o estado de uma variável externa, imprimir algo no console, ou interagir com um banco de dados.

A principal característica é que eles executam uma tarefa, mas não retornam um valor para o código que os chamou.

## Declaração

A sintaxe para declarar um método `void` é a seguinte:

```CSHARP
[modificador_de_acesso] static void [NomeDoMetodo]([parametros])
{
    // Corpo do método: código a ser executado
}
```

* `[modificador_de_acesso]`: Define a visibilidade (`public`, `private`, etc.).

* `static`: Indica que o método pertence à própria classe e pode ser chamado sem criar uma instância.

* `void`: Palavra-chave que especifica que o método não retorna valor.

* `[NomeDoMetodo]`: O nome do método, que deve ser um verbo ou frase verbal que descreva a ação (ex: `CalcularImpostos`, `ImprimirRelatorio`).

* `[parametros]`: A lista de dados que o método recebe para trabalhar.

### Exemplo: Método com Parâmetros

Métodos `void` frequentemente usam parâmetros para direcionar sua ação.

```CSHARP
// Declaração de um método que saúda um usuário
public static void SaudarUsuario(string nome)
{
    Console.WriteLine($"Olá, {nome}! Bem-vindo ao sistema.");
}

// Chamada ao método
SaudarUsuario("Ana"); // Saída: Olá, Ana! Bem-vindo ao sistema.
```

## 

Modificando Dados Externos com `ref`

Mesmo sem retornar um valor, um método `void` pode modificar variáveis que foram passadas a ele por referência usando a palavra-chave `ref`. Isso permite que o método altere o valor da variável original.

Tip:

Atenção: A variável passada como `ref` deve ser inicializada antes da chamada do método.

```CSHARP
// Método que troca os valores de duas variáveis
public static void TrocarValores(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// Uso
int x = 5;
int y = 10;
Console.WriteLine($"Antes: x = {x}, y = {y}");

TrocarValores(ref x, ref y);

Console.WriteLine($"Depois: x = {x}, y = {y}"); // Saída: Depois: x = 10, y = 5
```

## 

A Instrução `return` em Métodos `void`

Embora métodos `void` não retornem um valor, você pode usar a instrução `return;` para encerrar a execução do método prematuramente. Isso é uma técnica de controle de fluxo valiosa, conhecida como early exit.

```CSHARP
public static void ProcessarPedido(int quantidade)
{
    if (quantidade <= 0)
    {
        Console.WriteLine("Erro: A quantidade deve ser positiva.");
        return; // Sai do método imediatamente
    }

    if (quantidade > 100)
    {
        Console.WriteLine("Erro: Pedido excede o limite de estoque.");
        return; // Outro ponto de saída
    }

    // Este código só será executado se as validações passarem
    Console.WriteLine($"Pedido de {quantidade} unidades processado com sucesso.");
}
```

Note:

Em C#, tanto os métodos que retornam valor (funções) quanto os que não retornam (procedimentos `void`) são chamados genericamente de métodos. A escolha entre um método `void` e um com retorno depende da sua intenção: você quer realizar uma ação (`void`) ou obter um valor (com retorno)?



# Structs

Tipos de dados estruturado, servem apenas para definir a estrutura

Sendo tipo de valor

Armazenam apenas outros tipos de dados, e é definido pela palavra:

```CSHARP
struct NomeDaEstrutura{
    //Aqui vai as propriedades da estrutura
}
```

Composto por metodos e propriedades

Nome sempre com letras maiuscula

* Igual para propriedades e métodos

Criado apartir da palavra `new`

* Neste momento que temos os valores iniciais das propriedades

Exemplo:

```CSHARP
struct Pessoa{
    public string nome;
}
Pessoa pessoa = new Pessoa();
pessoa.nome = "João";
Console.WriteLine(pessoa.nome);
```

Também podemos criar um construtor padrão para inicializar o objeto:

```CSHARP
struct Pessoa{
    public string nome;
    public int idade;
    public Pessoa(string nome){
        this.nome = nome;
    }
}
Pessoa pessoa = new Pessoa("João");
Console.WriteLine(pessoa.nome);
```

E assim criamos metodos dentro do struct:

```CSHARP
struct Pessoa{
    public string nome;
    public int idade;
    public void MostrarDados(){
        Console.WriteLine($"Nome: {nome} Idade: {idade}");
    }
}
Pessoa pessoa = new Pessoa("João", 20);
pessoa.MostrarDados();
```

Podemos também usar o método `ToString()` para retornar uma string com os dados do objeto:

```CSHARP
struct Pessoa{
    public string nome;
    public int idade;
    public override string ToString(){
        return $"Nome: {nome} Idade: {idade}";
    }
}
Pessoa pessoa = new Pessoa("João", 20);
Console.WriteLine(pessoa.ToString());
```



# Enums

Um Enum serve para fornecer uma melhor visualização do código e também facilitar a leitura e entendimento de um código.

Usados em listas curtas e Usados em dados fixos:

* Hard Coded

Note:

No .NET a conveção é usar o PascalCase e começar com a letra maiúscula E sempre

Exemplo:

```CSHARP
class Program {
    enum StatusPedido {
        AguardandoPagamento,
        Pago,
        Cancelado
    }
    
    static void Main(string[] args) 
    {
        StatusPedido statusAtual = StatusPedido.AguardandoPagamento;
        Console.WriteLine(statusAtual); // Aguardando Pagamento
    }
}
```



# Stack vs. Heap: Gerenciamento de Memória em C#

Todo programa .NET utiliza duas áreas de memória fundamentais para sua execução: a Stack (Pilha) e a Heap (Monte). Compreender como elas funcionam e o que é armazenado em cada uma é crucial para escrever código eficiente e prever seu comportamento, especialmente no que diz respeito a performance e ciclo de vida das variáveis.

## A Stack (Pilha)

A Stack é uma estrutura de dados do tipo LIFO (Last-In, First-Out), ou seja, o último item a entrar é o primeiro a sair. É uma área de memória extremamente rápida e eficiente, usada para gerenciar o fluxo de execução do programa.

O que é armazenado na Stack?

1. Tipos de Valor (`Value Types`): Variáveis locais de tipos como `int`, `double`, `bool`, `char`, e `structs` são armazenadas diretamente na Stack.

2. Parâmetros de Métodos: Os valores passados como argumentos para um método são colocados na Stack.

3. Referências a Objetos: Quando você cria um objeto (um tipo de referência), o objeto em si vai para a Heap, mas a variável que aponta para ele (a referência/ponteiro) é armazenada na Stack.

4. Controle de Execução: A Stack gerencia qual método está em execução no momento. Cada chamada de método cria um "quadro" (stack frame) que contém suas variáveis locais e parâmetros. Quando o método termina, seu quadro é removido da pilha.

Características Principais:

* Velocidade: Alocação e desalocação são instantâneas (apenas o ponteiro da Stack é movido).

* Tamanho Fixo: A memória para um quadro de pilha é alocada no início da chamada do método.

* Gerenciamento Automático: A memória é liberada automaticamente quando a variável sai de escopo (o método termina). O Garbage Collector não atua na Stack.

* Limitação de Tamanho: A Stack tem um tamanho limitado. Chamadas recursivas infinitas podem causar um `StackOverflowException`.

### Diagrama da Stack

```TEXT
// Código
void MetodoA() {
    int x = 10;
    MetodoB();
}

void MetodoB() {
    bool y = true;
}
```

```TEXT
      STACK (Durante a execução de MetodoB)
+--------------------+
| Frame do MetodoB:  |  <-- Topo da Stack
|   y = true         |
+--------------------+
| Frame do MetodoA:  |
|   x = 10           |
+--------------------+
| ... (outros frames) ...
+--------------------+
```

## A Heap (Monte)

A Heap é uma área de memória maior e mais flexível, usada para alocação dinâmica. É aqui que os objetos (instâncias de classes) residem.

O que é armazenado na Heap?

1. Instâncias de Tipos de Referência (`Reference Types`): Qualquer objeto criado com a palavra-chave `new` (como instâncias de `class`, `arrays`, `string`, `delegates`) é alocado na Heap.

Características Principais:

* Alocação Dinâmica: Objetos podem ser alocados e desalocados em qualquer ordem.

* Velocidade: A alocação na Heap é mais lenta que na Stack, pois o sistema precisa encontrar um bloco de memória livre que seja grande o suficiente.

* Gerenciamento pelo Garbage Collector (GC): A memória na Heap não é liberada automaticamente. O GC é um processo que roda em segundo plano, identifica objetos na Heap que não são mais referenciados por nenhuma variável na Stack e libera o espaço que eles ocupavam.

* Tamanho Maior: A Heap é muito maior que a Stack, limitada apenas pela memória virtual disponível no sistema.

## Exemplo Combinado: Stack e Heap em Ação

Vamos analisar um exemplo que usa ambos os tipos e visualizar a memória.

```CSHARP
public class Estudante // Reference Type
{
    public int Matricula { get; set; }
}

public void Executar()
{
    int idade = 25; // Value Type
    Estudante aluno = new Estudante(); // Reference Type
    aluno.Matricula = 101;
}
```

### Diagrama da Memória Durante a Execução

```TEXT
          STACK                                  HEAP
+-------------------------+          +----------------------------+
| Frame do método Executar: |
|                         |
|   idade = 25            |          // Objeto alocado na Heap
|                         |
|   aluno (ref: 0xA1B2)   |--------->+ Objeto Estudante (0xA1B2)  |
|                         |          |   - Matricula: 101         |
+-------------------------+          +----------------------------+
| ... (outros frames) ... |
+-------------------------+
```

Análise:

1. A variável `idade` (tipo `int`) é um tipo de valor, então seu dado (`25`) é armazenado diretamente na Stack.

2. A variável `aluno` é uma referência. Ela também fica na Stack, mas seu valor não é o objeto em si, e sim o endereço (`0xA1B2`) onde o objeto `Estudante` foi alocado na Heap.

3. O objeto `Estudante` real, com seu campo `Matricula`, reside na Heap.

## Tabela Comparativa

| Característica |Stack (Pilha) |Heap (Monte) |
-----------------------------------------------
| Velocidade |Muito Rápida |Mais Lenta |
| Gerenciamento |Automático (LIFO) |Garbage Collector (GC) |
| Armazena |Tipos de Valor, Referências |Instâncias de Tipos de Referência |
| Ciclo de Vida |Curto (limitado ao escopo do método) |Longo (até não ser mais referenciado) |
| Tamanho |Pequeno e Fixo (por thread) |Grande e Dinâmico |



# Tipos de Valor (Value Types)

No C#, todo tipo é classificado como um tipo de valor ou um tipo de referência. Entender a diferença é fundamental para prever o comportamento do seu código e gerenciar a memória de forma eficiente.

Tipos de valor são aqueles cujas variáveis contêm diretamente o seu dado. A variável e o valor são uma coisa só.

## Como Funciona a Memória?

Tipos de valor são, na maioria das vezes, armazenados em uma área da memória chamada Stack (Pilha). A Stack é uma estrutura de dados altamente eficiente, do tipo LIFO (Last-In, First-Out), que gerencia a memória de forma muito rápida. Quando uma variável de tipo de valor é declarada dentro de um método, um espaço é alocado na Stack para armazenar seu valor.

### Diagrama: Variável na Stack

Imagine a Stack como uma pilha de caixas. Cada vez que você declara uma variável, uma nova caixa é colocada no topo, contendo o valor.

```TEXT
      STACK
+------------------+
|                  |  <-- Topo da Stack
+------------------+
|   idade = 30     |
+------------------+
|   saldo = 150.75 |
+------------------+
| ...outras vars...|
+------------------+
```

## Comportamento na Atribuição

Esta é a característica mais importante dos tipos de valor. Quando você atribui uma variável de tipo de valor a outra, o valor é copiado. O resultado são duas variáveis completamente independentes, cada uma com sua própria cópia do dado.

### Exemplo de Código

```CSHARP
// 1. 'a' é criado na Stack com o valor 10.
int a = 10;

// 2. O valor de 'a' é COPIADO para a nova variável 'b'.
int b = a;

Console.WriteLine($"a: {a}, b: {b}"); // Saída: a: 10, b: 10

// 3. Modificamos apenas 'b'.
b = 20;

// 4. A variável 'a' permanece inalterada, pois elas são independentes.
Console.WriteLine($"Após a mudança, a: {a}, b: {b}"); // Saída: a: 10, b: 20
```

### Diagrama: Cópia de Valor

Após a atribuição `int b = a;`, a Stack fica assim:

```TEXT
      STACK
+------------------+
|                  |  <-- Topo da Stack
+------------------+
|      b = 10      |  (Cópia independente)
+------------------+
|      a = 10      |
+------------------+
| ...outras vars...|
+------------------+
```

Quando `b` é alterado para `20`, apenas a sua "caixa" na Stack é afetada.

## O Garbage Collector e a Stack

O Garbage Collector (Coletor de Lixo) do .NET é responsável por limpar a memória na Heap, mas ele não gerencia a Stack. A memória da Stack é liberada automaticamente quando uma variável sai de escopo (por exemplo, quando o método onde ela foi declarada termina sua execução). Esse gerenciamento automático é o que torna a alocação e desalocação na Stack extremamente rápidas.

## Exemplos de Tipos de Valor

* Tipos numéricos primitivos: `int`, `double`, `float`, `decimal`, `long`, `byte`, etc.

* `bool`: O tipo booleano `true`/`false`.

* `char`: Um único caractere Unicode.

* `struct`: Estruturas definidas pelo usuário. São a forma de criar seus próprios tipos de valor complexos.

* `enum`: Enumerações, que representam um conjunto de constantes nomeadas.



# Tipos de Referência (Reference Types)

Tipos de referência são um dos dois pilares fundamentais do sistema de tipos do C#. Diferente dos tipos de valor, uma variável de tipo de referência não armazena o dado diretamente. Em vez disso, ela armazena um endereço de memória (uma referência ou ponteiro) que aponta para o local onde o objeto real está armazenado. Esse local é uma área da memória chamada Heap.

## Como Funciona a Memória?

A gestão da memória para tipos de referência envolve duas áreas:

1. Stack: A variável em si é criada na Stack. Ela é leve e contém apenas o endereço de memória do objeto.

2. Heap: O objeto real, com todos os seus dados, é alocado na Heap. A Heap é uma área de memória maior e mais flexível, gerenciada por um processo chamado Garbage Collector (Coletor de Lixo).

### Diagrama: Variável e Objeto na Memória

Quando você cria um objeto, a variável na Stack aponta para o objeto na Heap.

```TEXT
      STACK                         HEAP
+------------------+      +-------------------------+
|                  |      |                         |
|  minhaConta      |----->|  Objeto Conta           |
| (Endereço: 0x2A) |      |  (Endereço: 0x2A)       |
|                  |      |  - Saldo: 1000          |
+------------------+      |  - Titular: "Ana"       |
|                  |      |                         |
+------------------+      +-------------------------+
```

## Comportamento na Atribuição

Esta é a diferença mais crucial. Quando você atribui uma variável de referência a outra, você não está copiando o objeto, mas sim copiando o endereço de memória.

O resultado é que ambas as variáveis passam a apontar para o mesmo objeto na Heap. Qualquer modificação feita através de uma variável será visível através da outra.

### Exemplo de Código

```CSHARP
// Vamos supor que temos uma classe simples
public class ContaBancaria
{
    public decimal Saldo { get; set; }
}

// 1. Criamos uma instância. 'contaA' aponta para um novo objeto.
var contaA = new ContaBancaria { Saldo = 1000 };

// 2. Copiamos a referência. Agora 'contaB' aponta para o MESMO objeto que 'contaA'.
var contaB = contaA;

Console.WriteLine($"Saldo (contaA): {contaA.Saldo}"); // Saída: 1000
Console.WriteLine($"Saldo (contaB): {contaB.Saldo}"); // Saída: 1000

// 3. Modificamos o objeto usando 'contaB'.
contaB.Saldo = 500;

// 4. A mudança é refletida em 'contaA', pois ambas apontam para o mesmo lugar.
Console.WriteLine($"Saldo (contaA) após mudança: {contaA.Saldo}"); // Saída: 500
Console.WriteLine($"Saldo (contaB) após mudança: {contaB.Saldo}"); // Saída: 500
```

### Diagrama: Cópia de Referência

Após `var contaB = contaA;`, a situação da memória é a seguinte:

```TEXT
      STACK                         HEAP
+------------------+      +-------------------------+
|                  |      |                         |
|      contaA      |----->|  Objeto Conta           |
| (Endereço: 0x5B) |      |  (Endereço: 0x5B)       |
+------------------+      |  - Saldo: 1000          |
|                  |      |                         |
|      contaB      |----->|                         |
| (Endereço: 0x5B) |      +-------------------------+
|                  |
+------------------+
```

## O Garbage Collector (GC)

Como a Heap é gerenciada dinamicamente, precisamos de um mecanismo para limpar objetos que não são mais necessários. É aqui que entra o Garbage Collector.

O GC periodicamente verifica a Heap em busca de objetos que não possuem mais nenhuma referência apontando para eles. Quando encontra esses objetos "órfãos", ele os remove e libera a memória para que possa ser reutilizada.

Se no nosso exemplo fizermos `contaA = null;` e `contaB = null;`, o objeto `ContaBancaria` na Heap se tornaria elegível para a coleta de lixo.

## Exemplos de Tipos de Referência

* `class`: O exemplo mais comum. Todas as classes que você cria são tipos de referência.

* `object`: O tipo base para todos os outros tipos no .NET.

* `string`: Embora às vezes se comporte como um tipo de valor (devido à sua imutabilidade), `string` é um tipo de referência.

* Arrays: Vetores e matrizes (ex: `int[]`, `string[]`) são sempre tipos de referência.

* Delegates e Interfaces.



# GUIDs

Imagine que você está em um evento muito grande, com milhares de pessoas. Para garantir que cada pessoa seja facilmente identificada e que não haja confusão, a organização decide dar a cada participante um crachá com um número de identificação completamente único. Não importa o quão grande o evento seja, ou mesmo se houver outros eventos semelhantes em outros lugares do mundo, o seu número de crachá será exclusivo.

No mundo da programação, especialmente em sistemas complexos e distribuídos, precisamos de algo parecido: identificadores que sejam praticamente garantidos como únicos, não apenas dentro do seu programa, mas globalmente. É aí que entram os GUIDs.

## O que são GUIDs?

GUID é a sigla para Globally Unique IDentifier (Identificador Globalmente Único). No contexto do C# e de muitas outras tecnologias, um GUID é um número de 128 bits que é gerado de uma forma que o torna extremamente improvável de ser duplicado.

Vamos desmistificar alguns termos:

* Bit: A menor unidade de informação em um computador, representando um 0 ou um 1.

* Byte: Um grupo de 8 bits.

* Integer (Número Inteiro): Um número sem casas decimais.

* 128-bit integer (16 bytes): Isso significa que um GUID é um número inteiro muito grande, composto por 128 "zeros e uns". Como cada byte tem 8 bits, 128 bits equivalem a 16 bytes (128 / 8 = 16). Essa quantidade massiva de bits permite uma gama gigantesca de combinações, tornando a chance de dois GUIDs serem idênticos por acaso praticamente nula.

Um GUID é frequentemente representado como uma sequência hexadecimal (base 16) de 32 dígitos, agrupados em blocos separados por hífens, como este exemplo: `044e69f7-fe93-4e98-ae0d-f650b37f31ff`.

## Como Gerar um GUID em C#

Em C#, a geração de um GUID é muito simples, graças à estrutura `Guid` e ao seu método `NewGuid()`.

```CSHARP
// Declara uma variável 'id' e atribui a ela um novo GUID gerado.
// 'var' é uma palavra-chave em C# que permite ao compilador inferir o tipo da variável
// com base no valor que está sendo atribuído a ela. Neste caso, o tipo será 'Guid'.
var id = Guid.NewGuid();

// O resultado será algo assim:
// → 044e69f7-fe93-4e98-ae0d-f650b37f31ff

// 'System.Console.WriteLine()' é um método padrão em C# usado para exibir
// informações no console (a janela de texto onde seu programa é executado).
// Aqui, ele converte o GUID para uma string e o imprime.
System.Console.WriteLine("" + id);
```

## Quando Usar GUIDs?

GUIDs são extremamente úteis em diversas situações, como:

* Identificadores de Banco de Dados: Em vez de usar números sequenciais (que podem ser adivinhados ou expor informações sobre o número de registros), GUIDs fornecem identificadores únicos e imprevisíveis para registros.

* Sistemas Distribuídos: Quando você tem dados sendo criados em diferentes servidores ou locais que precisam ser sincronizados, GUIDs garantem que cada item tenha um identificador único, evitando conflitos.

* Chaves de API ou Tokens: Para gerar chaves de acesso ou tokens temporários que precisam ser únicos e difíceis de adivinhar.

* Nomes de Arquivos Temporários: Para criar nomes de arquivos que são garantidos como únicos, evitando sobrescrever arquivos existentes.

Em resumo, sempre que você precisar de um identificador que seja globalmente único e que não dependa de um sistema centralizado para garantir sua exclusividade, um GUID é uma excelente escolha.



# Interpolação de Strings

Imagine que você está escrevendo uma carta e quer incluir informações específicas, como a data, o nome do destinatário e o valor de um produto. Em vez de escrever tudo manualmente cada vez, você usa "espaços em branco" ou "marcadores" na carta e depois preenche esses espaços com as informações corretas.

No mundo da programação, a interpolação de strings é exatamente isso: a capacidade de combinar texto fixo (a "carta") com valores de variáveis (as "informações específicas") para criar uma única frase ou mensagem. Em C#, existem algumas maneiras de fazer isso, cada uma com suas vantagens.

## 

1. Concatenação de Strings (`+`)

A forma mais básica de juntar strings é usando o operador de adição (`+`). É como colar pedaços de papel com fita adesiva.

```
// Declara uma variável 'price' do tipo double (número com casas decimais).
var price = 12.2;

// Concatena a string "O preço é " com o valor da variável 'price'.
// O C# automaticamente converte o número 'price' para texto (string) para que possa ser combinado.
var texto = "O preço é " + price;

// 'Console.WriteLine()' é um comando para exibir texto na tela (no console).
Console.WriteLine(texto); // Saída: O preço é 12.2
```

Explicação:

* `string` (cadeia de caracteres): Uma sequência de caracteres (letras, números, símbolos) usada para representar texto.

* `var` (palavra-chave): Permite que o compilador C# descubra o tipo da variável automaticamente com base no valor que você atribui a ela.

* `+` (operador de concatenação): Quando usado com strings, ele as une, criando uma nova string. Se um dos lados não for uma string, o C# tenta convertê-lo para string antes de unir.

Vantagens: Simples e fácil de entender para operações básicas.
Desvantagens: Pode se tornar difícil de ler e manter quando há muitas variáveis ou quando a string resultante é muito longa. Em cenários de alta performance com muitas concatenações em loop, pode ser menos eficiente.

## 

2. Formatação de Strings (`string.Format`)

O método `string.Format` oferece uma maneira mais estruturada de construir strings. Ele usa "marcadores de posição" numerados (`{0}`, `{1}`, etc.) que são preenchidos pelos valores das variáveis que você fornece.

```
var price = 10.2;
var productName = "Notebook";

// Usa string.Format para criar uma string formatada.
// {0} será substituído pelo primeiro argumento após a string de formato (price).
// {1} será substituído pelo segundo argumento (productName).
var textoFormatado = string.Format("O preço do {1} é {0:C} apenas na promoção!", price, productName);

Console.WriteLine(textoFormatado); // Saída (exemplo, pode variar com a cultura): O preço do Notebook é R$ 10,20 apenas na promoção!
```

Explicação:

* `string.Format()` (método): Uma função que permite criar strings complexas usando um padrão e substituindo marcadores de posição por valores.

* `{0}`, `{1}` (marcadores de posição): Indicam onde os valores das variáveis serão inseridos. O número dentro das chaves corresponde à posição do argumento na lista após a string de formato (começando do 0).

* `{0:C}` (especificador de formato): O `:C` é um "especificador de formato" que indica que o número deve ser formatado como uma moeda, usando o símbolo da moeda e o número de casas decimais apropriados para a cultura atual do sistema (por exemplo, R$ 10,20 no Brasil).

Vantagens: Melhor legibilidade que a concatenação para strings complexas, permite formatação de valores (como moeda, datas).
Desvantagens: Ainda pode ser um pouco verboso e os marcadores numerados podem dificultar a leitura se houver muitos.

## 

3. Interpolação de Strings (`$""`) - A Forma Moderna

Introduzida no C# 6, a interpolação de strings é a maneira mais legível e concisa de combinar strings e variáveis. Você prefixa a string com um cifrão (`$`) e pode inserir variáveis diretamente dentro das chaves `{}`.

```
var price = 1500.00;
var productName = "Smartphone";
var discount = 0.10; // 10% de desconto

// Calcula o preço com desconto
var finalPrice = price * (1 - discount);

// Usa a interpolação de strings ($"") para criar uma mensagem clara.
// As variáveis são inseridas diretamente dentro das chaves {}.
// Também podemos usar especificadores de formato, como {finalPrice:C} para moeda.
var mensagem = $"O {productName} custa {price:C}. Com {discount:P0} de desconto, o preço final é {finalPrice:C}.";

Console.WriteLine(mensagem); // Saída (exemplo): O Smartphone custa R$ 1.500,00. Com 10% de desconto, o preço final é R$ 1.350,00.
```

Explicação:

* `$""` (string interpolada): O `$` antes das aspas duplas indica que a string é uma string interpolada.

* `{variável}` (expressão): Dentro de uma string interpolada, você pode colocar o nome de uma variável ou até mesmo uma expressão (como `price * (1 - discount)`) diretamente dentro das chaves `{}`. O C# automaticamente converte o valor para texto.

* `{discount:P0}` (especificador de formato): O `:P0` formata o número como uma porcentagem (`P`) sem casas decimais (`0`).

Vantagens: Excelente legibilidade, concisa, fácil de usar, e permite a mesma flexibilidade de formatação que `string.Format`. É a abordagem recomendada para a maioria dos casos em C# moderno.

Em resumo, a interpolação de strings (`$""`) é a ferramenta mais poderosa e amigável para combinar texto e dados em C#. Ela torna seu código mais limpo e fácil de entender, especialmente quando você está construindo mensagens complexas.



# Comparar Strings

Imagine que você tem duas caixas de brinquedos e quer saber se elas são iguais ou se uma contém um tipo específico de brinquedo. No mundo da programação, comparar strings é muito parecido: você quer verificar se dois textos são idênticos, ou se um texto contém uma parte específica de outro texto. Em C#, temos métodos dedicados para isso.

## 

`CompareTo()`: Comparação "Dicionário"

O método `CompareTo()` é como organizar palavras em um dicionário. Ele compara a string atual com outra string que você fornece, caractere por caractere, para determinar a ordem lexicográfica (a ordem em que as palavras apareceriam em um dicionário).

Como funciona:

* Ele é um método que você chama a partir de uma string (por exemplo, `minhaString.CompareTo(outraString)`).

* Ele é case-sensitive (sensível a maiúsculas e minúsculas). Isso significa que "Maçã" é diferente de "maçã".

* Ele retorna um número inteiro: * `0`: Se as strings são exatamente iguais. * Um número menor que 0: Se a string atual vem antes da string comparada na ordem do dicionário. * Um número maior que 0: Se a string atual vem depois da string comparada na ordem do dicionário.

Exemplo de Código:

```
string palavra1 = "Banana";
string palavra2 = "banana";
string palavra3 = "Abacaxi";
string palavra4 = "Banana";

// Comparação case-sensitive
int resultado1 = palavra1.CompareTo(palavra2); // "Banana" vs "banana"
Console.WriteLine($"'Banana'.CompareTo('banana') retorna: {resultado1}");
// Saída: Um número diferente de 0 (porque 'B' é diferente de 'b')

int resultado2 = palavra1.CompareTo(palavra4); // "Banana" vs "Banana"
Console.WriteLine($"'Banana'.CompareTo('Banana') retorna: {resultado2}");
// Saída: 0 (porque são idênticas)

int resultado3 = palavra1.CompareTo(palavra3); // "Banana" vs "Abacaxi"
Console.WriteLine($"'Banana'.CompareTo('Abacaxi') retorna: {resultado3}");
// Saída: Um número maior que 0 (porque 'Banana' vem depois de 'Abacaxi')
```

Termos Técnicos:

* Lexicográfico: Refere-se à ordem alfabética ou de dicionário.

* Case-sensitive (sensível a maiúsculas e minúsculas): Significa que a comparação diferencia letras maiúsculas de minúsculas.

## 

`Contains()`: Verificando a Presença

O método `Contains()` é como verificar se uma caixa de brinquedos contém um brinquedo específico. Ele verifica se uma determinada sequência de caracteres (uma "substring") está presente dentro da string atual.

Como funciona:

* Ele é um método que você chama a partir de uma string (por exemplo, `minhaFrase.Contains(palavraChave)`).

* Ele também é case-sensitive.

* Ele retorna um valor booleano: * `true`: Se a substring for encontrada. * `false`: Se a substring não for encontrada.

Exemplo de Código:

```
string frase = "O rato roeu a roupa do rei de Roma.";
string palavraChave1 = "rato";
string palavraChave2 = "Rei"; // Com 'R' maiúsculo
string palavraChave3 = "gato";

bool contem1 = frase.Contains(palavraChave1);
Console.WriteLine($"A frase contém '{palavraChave1}'? {contem1}");
// Saída: True

bool contem2 = frase.Contains(palavraChave2);
Console.WriteLine($"A frase contém '{palavraChave2}'? {contem2}");
// Saída: False (porque 'Rei' com 'R' maiúsculo não está na frase, apenas 'rei' com 'r' minúsculo)

bool contem3 = frase.Contains(palavraChave3);
Console.WriteLine($"A frase contém '{palavraChave3}'? {contem3}");
// Saída: False
```

Termos Técnicos:

* Substring: Uma parte de uma string. Por exemplo, "rato" é uma substring de "O rato roeu...".

* Booleano: Um tipo de dado que pode ter apenas dois valores: `true` (verdadeiro) ou `false` (falso).

## Equals

Tip:

Serve não somente para strings

text.Equals(text2)

## Comparação Ignorando Maiúsculas/Minúsculas (Case-Insensitive)

Muitas vezes, você não quer que a comparação seja sensível a maiúsculas e minúsculas. Para isso, você pode converter ambas as strings para o mesmo caso (tudo maiúsculo ou tudo minúsculo) antes de comparar.

Exemplo para `CompareTo()` e `Contains()`:

```
string textoOriginal = "Olá Mundo";
string textoComparar = "olá mundo";

// Para CompareTo()
// Converte ambas para minúsculas antes de comparar
bool saoIguaisIgnorandoCase = (textoOriginal.ToLower().CompareTo(textoComparar.ToLower()) == 0);
Console.WriteLine($"'Olá Mundo' e 'olá mundo' são iguais (ignorando case)? {saoIguaisIgnorandoCase}");
// Saída: True

// Para Contains()
// Converte ambas para minúsculas antes de verificar
bool contemIgnorandoCase = textoOriginal.ToLower().Contains(textoComparar.ToLower());
Console.WriteLine($"'Olá Mundo' contém 'olá mundo' (ignorando case)? {contemIgnorandoCase}");
// Saída: True
```

Termos Técnicos:

* `ToLower()` (método): Um método de string que retorna uma nova string com todos os caracteres convertidos para minúsculas.

* `ToUpper()` (método): Um método de string que retorna uma nova string com todos os caracteres convertidos para maiúsculas.

Compreender como e quando usar `CompareTo()` e `Contains()` (e como lidar com a sensibilidade a maiúsculas e minúsculas) é fundamental para manipular textos de forma eficaz em seus programas C#.



# Início e Fim de Strings

Imagine que você tem uma lista de nomes de arquivos e quer encontrar todos os arquivos que começam com "relatorio" ou que terminam com ".pdf". Em programação, para fazer esse tipo de verificação em textos (strings), usamos métodos específicos que nos dizem se uma string começa ou termina com uma determinada sequência de caracteres.

## 

`StartsWith()`: Verificando o Início

O método `StartsWith()` é como perguntar: "Esta frase começa com esta palavra?". Ele verifica se a string atual começa com a substring especificada.

Como funciona:

* Você chama `StartsWith()` a partir de uma string, passando a substring que você quer verificar como argumento.

* Ele é case-sensitive (sensível a maiúsculas e minúsculas). Isso significa que "Relatorio" é diferente de "relatorio".

* Ele retorna um valor booleano: * `true`: Se a string começa com a substring. * `false`: Se a string não começa com a substring.

Exemplo de Código:

```
string nomeArquivo = "relatorio_vendas_2024.xlsx";

bool comecaComRelatorio = nomeArquivo.StartsWith("relatorio");
Console.WriteLine($"'{nomeArquivo}' começa com 'relatorio'? {comecaComRelatorio}");
// Saída: True

bool comecaComRelatorioMaiusculo = nomeArquivo.StartsWith("Relatorio");
Console.WriteLine($"'{nomeArquivo}' começa com 'Relatorio'? {comecaComRelatorioMaiusculo}");
// Saída: False (por causa do 'R' maiúsculo)

string url = "https://www.exemplo.com";
bool comecaComHttps = url.StartsWith("https://");
Console.WriteLine($"'{url}' começa com 'https://'? {comecaComHttps}");
// Saída: True
```

Termos Técnicos:

* Substring: Uma parte de uma string. Por exemplo, "relatorio" é uma substring de "relatorio_vendas_2024.xlsx".

* Booleano: Um tipo de dado que pode ter apenas dois valores: `true` (verdadeiro) ou `false` (falso).

* Case-sensitive (sensível a maiúsculas e minúsculas): Significa que a comparação diferencia letras maiúsculas de minúsculas.

## 

`EndsWith()`: Verificando o Fim

O método `EndsWith()` é o oposto de `StartsWith()`. Ele é como perguntar: "Esta frase termina com esta palavra?". Ele verifica se a string atual termina com a substring especificada.

Como funciona:

* Você chama `EndsWith()` a partir de uma string, passando a substring que você quer verificar como argumento.

* Ele também é case-sensitive.

* Ele retorna um valor booleano: * `true`: Se a string termina com a substring. * `false`: Se a string não termina com a substring.

Exemplo de Código:

```
string nomeArquivo = "documento_final.pdf";

bool terminaComPdf = nomeArquivo.EndsWith(".pdf");
Console.WriteLine($"'{nomeArquivo}' termina com '.pdf'? {terminaComPdf}");
// Saída: True

bool terminaComDoc = nomeArquivo.EndsWith(".doc");
Console.WriteLine($"'{nomeArquivo}' termina com '.doc'? {terminaComDoc}");
// Saída: False

string email = "usuario@dominio.com.br";
bool terminaComBr = email.EndsWith(".br");
Console.WriteLine($"'{email}' termina com '.br'? {terminaComBr}");
// Saída: True
```

## Comparação Ignorando Maiúsculas/Minúsculas (Case-Insensitive)

Assim como em outras comparações de strings, muitas vezes você pode querer verificar o início ou o fim de uma string sem se preocupar com a diferença entre letras maiúsculas e minúsculas. Para isso, você pode converter tanto a string original quanto a substring para o mesmo caso (tudo minúsculo ou tudo maiúsculo) antes de usar `StartsWith()` ou `EndsWith()`.

Exemplo:

```
string titulo = "A Grande Aventura";
string prefixo = "a grande"; // Minúsculo

// Verificação case-sensitive (retorna False)
bool comecaCaseSensitive = titulo.StartsWith(prefixo);
Console.WriteLine($"'{titulo}' começa com '{prefixo}' (case-sensitive)? {comecaCaseSensitive}");
// Saída: False

// Verificação case-insensitive (retorna True)
bool comecaCaseInsensitive = titulo.ToLower().StartsWith(prefixo.ToLower());
Console.WriteLine($"'{titulo}' começa com '{prefixo}' (case-insensitive)? {comecaCaseInsensitive}");
// Saída: True

string caminho = "/home/usuario/documentos/relatorio.PDF";
string extensao = ".pdf"; // Minúsculo

// Verificação case-sensitive (retorna False)
bool terminaCaseSensitive = caminho.EndsWith(extensao);
Console.WriteLine($"'{caminho}' termina com '{extensao}' (case-sensitive)? {terminaCaseSensitive}");
// Saída: False

// Verificação case-insensitive (retorna True)
bool terminaCaseInsensitive = caminho.ToLower().EndsWith(extensao.ToLower());
Console.WriteLine($"'{caminho}' termina com '{extensao}' (case-insensitive)? {terminaCaseInsensitive}");
// Saída: True
```

Termos Técnicos:

* `ToLower()` (método): Um método de string que retorna uma nova string com todos os caracteres convertidos para minúsculas.

* `ToUpper()` (método): Um método de string que retorna uma nova string com todos os caracteres convertidos para maiúsculas.

Dominar `StartsWith()` e `EndsWith()` é essencial para tarefas comuns de manipulação de strings, como validação de entrada de usuário, análise de nomes de arquivos e URLs, e filtragem de dados.



# Índices em Strings

Pense em uma fila de pessoas. Para saber quem é o primeiro, o segundo, e assim por diante, você atribui um número a cada posição. Em programação, as strings funcionam de forma parecida: cada caractere dentro de uma string tem uma posição, e essa posição é chamada de índice.

## O que é um Índice?

Um índice é um número inteiro que representa a posição de um caractere dentro de uma string. É como o endereço de cada letra. A característica mais importante dos índices na maioria das linguagens de programação (incluindo C#) é que eles são baseados em zero.

### Índices Baseados em Zero

Isso significa que:

* O primeiro caractere de uma string está no índice `0`.

* O segundo caractere está no índice `1`.

* O terceiro caractere está no índice `2`.

* E assim por diante.

Se uma string tem `N` caracteres, o último caractere estará no índice `N-1`.

Exemplo:

Para a string `"Hello"`:

* `H` está no índice `0`

* `e` está no índice `1`

* `l` está no índice `2`

* `l` está no índice `3`

* `o` está no índice `4`

Este diagrama Mermaid ilustra como os índices são usados para acessar caracteres individuais em uma string. Cada nó representa um passo lógico, mostrando a string original e como cada índice aponta para um caractere específico.

```MERMAID
graph TD
    A[String: Hello] --> B{Index 0};
    B --> C[Character: 'H'];
    A --> D{Index 1};
    D --> E[Character: 'e'];
    A --> F{Index 2};
    F --> G[Character: 'l'];
    A --> H{Index 3};
    H --> I[Character: 'l'];
    A --> J{Index 4};
    J --> K[Character: 'o'];
```

## Acessando Caracteres Usando Índices

Você pode acessar um caractere específico em uma string usando seu índice. Isso é útil quando você precisa trabalhar com uma parte exata do texto.

```
string productName = "Smartphone";
char firstLetter = productName[0]; // Accesses the character at index 0 (S)
char fifthLetter = productName[4]; // Accesses the character at index 4 (t)
char lastLetter = productName[productName.Length - 1]; // Accesses the last character (e)

Console.WriteLine($"First letter: {firstLetter}"); // Output: First letter: S
Console.WriteLine($"Fifth letter: {fifthLetter}"); // Output: Fifth letter: t
Console.WriteLine($"Last letter: {lastLetter}"); // Output: Last letter: e
```

## 

Encontrando o Índice de um Substring (`IndexOf`)

Frequentemente, você precisará saber onde uma sequência de caracteres (uma substring) começa dentro de uma string maior. O método `IndexOf()` é usado para isso. Ele retorna o índice da primeira ocorrência da substring que você está procurando.

* Se a substring for encontrada, ele retorna o índice inicial da primeira ocorrência.

* Se a substring não for encontrada, ele retorna `-1`.

```
string emailAddress = "user.name@example.com";

// Finding the index of the '@' symbol
int atSymbolIndex = emailAddress.IndexOf("@");
Console.WriteLine($"'@' symbol found at index: {atSymbolIndex}"); // Output: '@' symbol found at index: 9

// Finding the index of ".com"
int dotComIndex = emailAddress.IndexOf(".com");
Console.WriteLine($"'.com' found at index: {dotComIndex}"); // Output: '.com' found at index: 16

// Trying to find a substring that doesn't exist
int notFoundIndex = emailAddress.IndexOf("xyz");
Console.WriteLine($"'xyz' found at index: {notFoundIndex}"); // Output: 'xyz' found at index: -1

// Using the index to extract a part of the string
// For example, extracting the domain name
if (atSymbolIndex != -1)
{
    string domain = emailAddress.Substring(atSymbolIndex + 1);
    Console.WriteLine($"Domain: {domain}"); // Output: Domain: example.com
}
```

## 

`LastIndexOf()`: Encontrando a Última Ocorrência

Se você precisar encontrar a última ocorrência de um caractere ou substring, pode usar o método `LastIndexOf()`. Ele funciona de forma semelhante ao `IndexOf()`, mas busca do final para o início da string.

```
string filePath = "/home/user/documents/report.pdf";

// Finding the index of the last '/' to get the file name
int lastSlashIndex = filePath.LastIndexOf("/");
Console.WriteLine($"Last slash found at index: {lastSlashIndex}"); // Output: Last slash found at index: 20

if (lastSlashIndex != -1)
{
    string fileName = filePath.Substring(lastSlashIndex + 1);
    Console.WriteLine($"File Name: {fileName}"); // Output: File Name: report.pdf
}
```

Compreender os índices é fundamental para manipular e extrair informações de strings de forma eficaz em qualquer aplicação.



# Outros Métodos

Imagine que você é um editor de texto e precisa realizar diversas operações em frases e palavras: contar caracteres, substituir termos, inserir novas informações, remover trechos indesejados ou até mesmo dividir um parágrafo em sentenças. No C#, as strings são como esses textos, e a linguagem oferece um conjunto robusto de métodos para manipular e transformar esses dados de forma eficiente.

Este documento abordará alguns métodos de string fundamentais que complementam as operações já discutidas, permitindo um controle ainda maior sobre o conteúdo textual.

## 

1. Obtendo o Comprimento da String (`.Length`)

A propriedade `.Length` é como um contador de caracteres. Ela retorna o número total de caracteres em uma string, incluindo letras, números, símbolos e espaços.

```CSHARP
string productName = "Laptop Pro X";
int length = productName.Length; // Result: 12
Console.WriteLine($"Product Name: {productName}, Length: {length}");

string emptyString = "";
int emptyLength = emptyString.Length; // Result: 0
Console.WriteLine($"Empty String Length: {emptyLength}");
```

Termos Técnicos:

* Propriedade: Um membro de uma classe ou struct que fornece um mecanismo flexível para ler, gravar ou computar o valor de um campo privado.

## 

2. Substituindo Conteúdo (`.Replace()`)

O método `.Replace()` é como uma ferramenta de "localizar e substituir" em um editor de texto. Ele cria uma nova string onde todas as ocorrências de uma substring específica são substituídas por outra substring.

```CSHARP
string originalSentence = "The quick brown fox jumps over the lazy fox.";
string newSentence = originalSentence.Replace("fox", "dog"); // Result: "The quick brown dog jumps over the lazy dog."
Console.WriteLine($"Original: {originalSentence}");
Console.WriteLine($"Replaced: {newSentence}");

string productCode = "PROD-ABC-123";
string updatedCode = productCode.Replace("-", "_"); // Result: "PROD_ABC_123"
Console.WriteLine($"Original Code: {productCode}, Updated Code: {updatedCode}");
```

Termos Técnicos:

* Substring: Uma sequência contígua de caracteres dentro de uma string maior.

## 

3. Inserindo Conteúdo (`.Insert()`)

O método `.Insert()` permite que você adicione uma substring em uma posição específica dentro de uma string existente, criando uma nova string com o conteúdo inserido.

```CSHARP
string baseString = "Hello!";
string insertedString = baseString.Insert(5, " World"); // Inserts " World" at index 5. Result: "Hello World!"
Console.WriteLine($"Base String: {baseString}");
Console.WriteLine($"Inserted String: {insertedString}");

string url = "www.example.com";
string fullUrl = url.Insert(0, "https://"); // Inserts "https://" at the beginning (index 0). Result: "https://www.example.com"
Console.WriteLine($"Full URL: {fullUrl}");
```

Termos Técnicos:

* Índice: A posição baseada em zero de um caractere dentro de uma string.

## 

4. Removendo Conteúdo (`.Remove()`)

O método `.Remove()` é usado para criar uma nova string, removendo um número especificado de caracteres a partir de um índice inicial. Você pode remover até o final da string ou um número específico de caracteres.

```CSHARP
string originalText = "This is a sample text.";

// Remove from index 8 to the end
string removedToEnd = originalText.Remove(8); // Result: "This is "
Console.WriteLine($"Removed to End: {removedToEnd}");

// Remove 7 characters starting from index 8
string removedSpecific = originalText.Remove(8, 7); // Result: "This is text."
Console.WriteLine($"Removed Specific: {removedSpecific}");
```

## 

5. Removendo Espaços em Branco (`.Trim()`, `.TrimStart()`, `.TrimEnd()`)

Estes métodos são úteis para "limpar" strings, removendo espaços em branco (e outros caracteres de espaço, como tabulações e quebras de linha) do início, do fim ou de ambas as extremidades de uma string. Eles também retornam uma nova string.

```CSHARP
string paddedText = "   Some text with spaces   ";

string trimmedText = paddedText.Trim(); // Result: "Some text with spaces"
Console.WriteLine($"Original: '{paddedText}'");
Console.WriteLine($"Trimmed: '{trimmedText}'");

string trimmedStart = paddedText.TrimStart(); // Result: "Some text with spaces   "
Console.WriteLine($"Trimmed Start: '{trimmedStart}'");

string trimmedEnd = paddedText.TrimEnd(); // Result: "   Some text with spaces"
Console.WriteLine($"Trimmed End: '{trimmedEnd}'");
```

## 

6. Dividindo Strings (`.Split()`)

O método `.Split()` é como pegar uma tesoura e cortar uma string em pedaços menores, com base em um ou mais delimitadores (caracteres ou strings que indicam onde cortar). Ele retorna um array de strings.

```CSHARP
string csvData = "apple,banana,orange,grape";
string[] fruits = csvData.Split(','); // Splits by comma
Console.WriteLine("Fruits:");
foreach (string fruit in fruits)
{
    Console.WriteLine($"- {fruit.Trim()}"); // Using Trim() to remove potential spaces after comma
}

string sentence = "Hello World from C#";
string[] words = sentence.Split(' '); // Splits by space
Console.WriteLine("Words:");
foreach (string word in words)
{
    Console.WriteLine($"- {word}");
}
```

Termos Técnicos:

* Delimitador: Um caractere ou sequência de caracteres que marca o limite entre regiões ou elementos de dados.

* Array: Uma estrutura de dados que armazena uma coleção de itens do mesmo tipo em uma sequência contígua de locais de memória.

## 

7. Juntando Strings (`string.Join()`)

O método estático `string.Join()` é o inverso de `.Split()`. Ele pega uma coleção de strings (como um array) e as concatena em uma única string, inserindo um separador entre cada elemento.

```CSHARP
string[] parts = { "data", "science", "project" };
string fileName = string.Join("_", parts); // Result: "data_science_project"
Console.WriteLine($"File Name: {fileName}");

string[] tags = { "programming", "c#", "development" };
string tagList = string.Join(", ", tags); // Result: "programming, c#, development"
Console.WriteLine($"Tag List: {tagList}");
```

Termos Técnicos:

* Método Estático: Um método que pertence à própria classe, e não a uma instância específica da classe. Você o chama usando o nome da classe (ex: `string.Join`).

## Conclusão

Compreender e utilizar esses métodos de manipulação de strings é crucial para qualquer desenvolvedor C#. Eles fornecem as ferramentas necessárias para processar, formatar e extrair informações de dados textuais, que são onipresentes em quase todas as aplicações. A prática com esses métodos solidificará sua capacidade de trabalhar com strings de forma eficaz e elegante.



# Manipulando Strings: Formatação e Validação Adicional

Imagine que você está organizando uma planilha de dados e precisa garantir que todos os códigos de produto tenham o mesmo número de dígitos, preenchendo com zeros à esquerda se necessário. Ou talvez você esteja processando dados de entrada de usuários e precisa verificar se um campo de texto está realmente vazio, e não apenas cheio de espaços. No C#, além dos métodos de manipulação de texto que já vimos, existem outras ferramentas poderosas para formatar e validar strings, garantindo a consistência e a robustez dos seus dados.

Este documento abordará métodos adicionais que são cruciais para tarefas comuns de formatação e validação de strings.

## 

1. Preenchendo Strings (`.PadLeft()`, `.PadRight()`)

Estes métodos são como preencher um campo com caracteres específicos para atingir um comprimento total desejado. Eles são frequentemente usados para formatação de saída, como alinhar texto ou preencher números com zeros à esquerda.

### 

`.PadLeft()`: Preenche à Esquerda

Adiciona caracteres (por padrão, espaços) ao início de uma string até que ela atinja um comprimento total especificado.

```CSHARP
string productId = "123";
// Pad with spaces to a total length of 5
string paddedProductId = productId.PadLeft(5); // Result: "  123"
Console.WriteLine($"Padded Product ID (spaces): '{paddedProductId}'");

// Pad with zeros to a total length of 5
string zeroPaddedId = productId.PadLeft(5, '0'); // Result: "00123"
Console.WriteLine($"Padded Product ID (zeros): '{zeroPaddedId}'");

string amount = "45.75";
// Pad with spaces to a total length of 10 for alignment
string paddedAmount = amount.PadLeft(10); // Result: "    45.75"
Console.WriteLine($"Padded Amount: '{paddedAmount}'");
```

### 

`.PadRight()`: Preenche à Direita

Adiciona caracteres (por padrão, espaços) ao final de uma string até que ela atinja um comprimento total especificado.

```CSHARP
string itemName = "Pen";
// Pad with spaces to a total length of 10
string paddedItemName = itemName.PadRight(10); // Result: "Pen       "
Console.WriteLine($"Padded Item Name (spaces): '{paddedItemName}'");

string status = "Active";
// Pad with hyphens to a total length of 15
string paddedStatus = status.PadRight(15, '-'); // Result: "Active---------"
Console.WriteLine($"Padded Status: '{paddedStatus}'");
```

Termos Técnicos:

* Padding: O processo de adicionar caracteres a uma string para que ela atinja um comprimento específico.

## 

2. Verificando Strings Vazias ou Nulas (`string.IsNullOrEmpty()`, `string.IsNullOrWhiteSpace()`)

Esses métodos estáticos são essenciais para validar entradas de usuário e evitar erros de referência nula ou processamento de strings sem conteúdo significativo.

### 

`string.IsNullOrEmpty()`: Verifica Nulo ou Vazio

Retorna `true` se a string for `null` (não aponta para nenhum objeto) ou uma string vazia (`""`).

```CSHARP
string userName = null;
string email = "";
string address = "123 Main St";

bool isUserNameEmpty = string.IsNullOrEmpty(userName); // Result: true
Console.WriteLine($"Is UserName null or empty? {isUserNameEmpty}");

bool isEmailEmpty = string.IsNullOrEmpty(email); // Result: true
Console.WriteLine($"Is Email null or empty? {isEmailEmpty}");

bool isAddressEmpty = string.IsNullOrEmpty(address); // Result: false
Console.WriteLine($"Is Address null or empty? {isAddressEmpty}");
```

### 

`string.IsNullOrWhiteSpace()`: Verifica Nulo, Vazio ou Apenas Espaços

Retorna `true` se a string for `null`, vazia (`""`), ou consistir apenas em caracteres de espaço em branco (espaços, tabulações, quebras de linha, etc.). Este é geralmente o método preferido para validar entradas de texto, pois considera strings como `"   "` como inválidas.

```CSHARP
string input1 = null;
string input2 = "";
string input3 = "   "; // Only spaces
string input4 = "Hello";

bool isInput1Invalid = string.IsNullOrWhiteSpace(input1); // Result: true
Console.WriteLine($"Is Input1 null, empty or whitespace? {isInput1Invalid}");

bool isInput2Invalid = string.IsNullOrWhiteSpace(input2); // Result: true
Console.WriteLine($"Is Input2 null, empty or whitespace? {isInput2Invalid}");

bool isInput3Invalid = string.IsNullOrWhiteSpace(input3); // Result: true
Console.WriteLine($"Is Input3 null, empty or whitespace? {isInput3Invalid}");

bool isInput4Invalid = string.IsNullOrWhiteSpace(input4); // Result: false
Console.WriteLine($"Is Input4 null, empty or whitespace? {isInput4Invalid}");
```

Termos Técnicos:

* `null`: Um valor que indica que uma variável não está apontando para nenhum objeto na memória.

* Espaço em branco (Whitespace): Caracteres que representam espaço horizontal ou vertical, como espaço, tabulação, nova linha, etc.

## 

3. Convertendo para Array de Caracteres (`.ToCharArray()`)

O método `.ToCharArray()` é útil quando você precisa processar uma string caractere por caractere, ou quando uma API espera um array de caracteres em vez de uma string. Ele cria um novo array de caracteres a partir da string.

```CSHARP
string password = "P@ssw0rd!";
char[] passwordChars = password.ToCharArray();

Console.WriteLine("Password characters:");
foreach (char c in passwordChars)
{
    Console.Write($"{c} ");
}
Console.WriteLine(); // New line for formatting

// Example: Reversing a string using ToCharArray()
string originalWord = "developer";
char[] wordChars = originalWord.ToCharArray();
Array.Reverse(wordChars); // Reverses the array in place
string reversedWord = new string(wordChars); // Creates a new string from the char array
Console.WriteLine($"Original: {originalWord}, Reversed: {reversedWord}");
```

Termos Técnicos:

* Array de Caracteres (`char[]`): Uma coleção ordenada de caracteres individuais.

## Conclusão

Os métodos `PadLeft()`, `PadRight()`, `IsNullOrEmpty()`, `IsNullOrWhiteSpace()` e `ToCharArray()` são ferramentas valiosas no arsenal de qualquer desenvolvedor C#. Eles permitem um controle preciso sobre a formatação e a validação de strings, contribuindo para a criação de aplicações mais robustas e com melhor apresentação de dados. Dominar essas funcionalidades é um passo importante para se tornar proficiente na manipulação de texto em C#.



# Manipulação Avançada de Strings no C#

Imagine que você está trabalhando com dados complexos: talvez precise comparar nomes de usuários de forma que "joão" e "João" sejam considerados iguais, ou extrair partes de um log de sistema que contém múltiplos delimitadores, ou ainda otimizar o armazenamento de textos repetitivos. O C# oferece um conjunto de métodos de string mais avançados que permitem lidar com esses cenários, proporcionando maior controle e eficiência.

Este documento explora 15 métodos e conceitos úteis que aprofundam suas habilidades na manipulação de strings, indo além do básico.

## 

1. Comparação Avançada com `string.Equals()` e `string.Compare()`

Enquanto `==` e `CompareTo()` fazem comparações básicas, `string.Equals()` e `string.Compare()` com o enum `StringComparison` oferecem controle preciso sobre como as strings são comparadas, incluindo sensibilidade a maiúsculas/minúsculas e cultura.

### 

`string.Equals(string, StringComparison)`

Compara duas strings usando regras de comparação específicas.

```CSHARP
string user1 = "john.doe";
string user2 = "John.Doe";

// Case-sensitive comparison (default)
bool areEqualCaseSensitive = string.Equals(user1, user2, StringComparison.Ordinal); // Result: false
Console.WriteLine($"'{user1}' equals '{user2}' (Ordinal): {areEqualCaseSensitive}");

// Case-insensitive comparison
bool areEqualCaseInsensitive = string.Equals(user1, user2, StringComparison.OrdinalIgnoreCase); // Result: true
Console.WriteLine($"'{user1}' equals '{user2}' (OrdinalIgnoreCase): {areEqualCaseInsensitive}");

// Culture-sensitive comparison (e.g., for 'i' vs 'İ' in Turkish)
string turkishI = "istanbul";
string turkishCapitalI = "İstanbul";
bool cultureSensitive = string.Equals(turkishI, turkishCapitalI, StringComparison.CurrentCultureIgnoreCase); // Result: true (in Turkish culture)
Console.WriteLine($"'{turkishI}' equals '{turkishCapitalI}' (CurrentCultureIgnoreCase): {cultureSensitive}");
```

### 

`string.Compare(string, string, StringComparison)`

Compara duas strings e retorna um inteiro indicando sua ordem relativa, similar a `CompareTo()`, mas com opções de comparação.

```CSHARP
string city1 = "São Paulo";
string city2 = "Sao Paulo";

// Culture-sensitive comparison (might treat 'ã' differently)
int resultCulture = string.Compare(city1, city2, StringComparison.CurrentCulture); // Result depends on culture
Console.WriteLine($"Compare '{city1}' and '{city2}' (CurrentCulture): {resultCulture}");

// Ordinal comparison (byte-by-byte, 'ã' is different from 'a')
int resultOrdinal = string.Compare(city1, city2, StringComparison.Ordinal); // Result: non-zero
Console.WriteLine($"Compare '{city1}' and '{city2}' (Ordinal): {resultOrdinal}");
```

Termos Técnicos:

* `StringComparison` Enum: Uma enumeração que define as regras para comparações de strings (e.g., `Ordinal`, `OrdinalIgnoreCase`, `CurrentCulture`, `InvariantCulture`).

* Ordinal Comparison: Uma comparação byte-a-byte, sem considerar regras linguísticas ou culturais. É a mais rápida e segura para comparações de segurança (senhas, caminhos de arquivo).

* Culture-Sensitive Comparison: Uma comparação que leva em conta as regras linguísticas e culturais do sistema atual ou de uma cultura específica.

## 

2. Removendo Caracteres Específicos com `Trim(char[])`

O método `Trim()` que você já conhece remove espaços em branco. A sobrecarga `Trim(char[])` permite remover um conjunto específico de caracteres do início e do fim de uma string.

```CSHARP
string data = "###ProductCode-123###";
char[] trimChars = { '#' };
string cleanedData = data.Trim(trimChars); // Result: "ProductCode-123"
Console.WriteLine($"Original: '{data}', Cleaned: '{cleanedData}'");

string path = "/path/to/file/";
char[] slash = { '/' };
string cleanedPath = path.Trim(slash); // Result: "path/to/file"
Console.WriteLine($"Original Path: '{path}', Cleaned Path: '{cleanedPath}'");
```

## 

3. Divisão Avançada com `Split(char[], int, StringSplitOptions)`

O `Split()` básico divide por um delimitador. As sobrecargas permitem controlar o número máximo de substrings retornadas e como lidar com entradas vazias.

```CSHARP
string logEntry = "ERROR:::File not found:::2023-01-15";

// Split into at most 2 parts, removing empty entries
string[] parts = logEntry.Split(new[] { ":::" }, 2, StringSplitOptions.RemoveEmptyEntries);
// Result: ["ERROR", "File not found:::2023-01-15"]
Console.WriteLine("Log Parts (max 2):");
foreach (string part in parts)
{
    Console.WriteLine($"- {part}");
}

string csvLine = "apple,,orange,";
// Split and remove empty entries
string[] items = csvLine.Split(',', StringSplitOptions.RemoveEmptyEntries);
// Result: ["apple", "orange"]
Console.WriteLine("CSV Items (RemoveEmptyEntries):");
foreach (string item in items)
{
    Console.WriteLine($"- {item}");
}
```

Termos Técnicos:

* `StringSplitOptions` Enum: Controla o comportamento do método `Split()`, como `RemoveEmptyEntries` (ignora substrings vazias) ou `None` (inclui substrings vazias).

## 

4. Unindo Coleções com `string.Join(string, IEnumerable<string>)`

Enquanto `string.Join()` já foi abordado, a sobrecarga que aceita `IEnumerable<string>` é extremamente útil para unir qualquer coleção de strings (como `List<string>`, `HashSet<string>`) sem precisar convertê-las para um array primeiro.

```CSHARP
using System.Collections.Generic;

List<string> tags = new List<string> { "programming", "csharp", "backend" };
string tagString = string.Join("; ", tags); // Result: "programming; csharp; backend"
Console.WriteLine($"Joined Tags: {tagString}");

HashSet<string> uniqueUsers = new HashSet<string> { "alice", "bob", "charlie" };
string userList = string.Join(", ", uniqueUsers); // Result: "alice, bob, charlie" (order may vary)
Console.WriteLine($"Joined Users: {userList}");
```

Termos Técnicos:

* `IEnumerable<T>`: Uma interface que representa uma coleção de elementos que podem ser iterados (percorridos).

## 

5. Verificando Caracteres Únicos com `Contains(char)`

Embora `Contains(string)` verifique substrings, `Contains(char)` é uma sobrecarga mais eficiente para verificar a presença de um único caractere.

```CSHARP
string email = "user@example.com";
bool hasAtSymbol = email.Contains('@'); // Result: true
Console.WriteLine($"Email '{email}' contains '@'? {hasAtSymbol}");

string phoneNumber = "123-456-7890";
bool hasDash = phoneNumber.Contains('-'); // Result: true
Console.WriteLine($"Phone number '{phoneNumber}' contains '-'? {hasDash}");
```

## 

6. Encontrando Qualquer Caractere de um Conjunto (`IndexOfAny()`, `LastIndexOfAny()`)

Estes métodos são como procurar por qualquer um de vários itens em uma lista. Eles retornam o índice da primeira (ou última) ocorrência de qualquer caractere presente em um array de caracteres fornecido.

### 

`IndexOfAny(char[])`

```CSHARP
string text = "Hello, World! How are you?";
char[] delimiters = { ',', '!', '?' };
int firstDelimiterIndex = text.IndexOfAny(delimiters); // Result: 5 (index of ',')
Console.WriteLine($"First delimiter found at index: {firstDelimiterIndex}");
```

### 

`LastIndexOfAny(char[])`

```CSHARP
string textWithMultipleDelimiters = "Item1;Item2,Item3|Item4";
char[] separators = { ';', ',', '|' };
int lastSeparatorIndex = textWithMultipleDelimiters.LastIndexOfAny(separators); // Result: 17 (index of '|')
Console.WriteLine($"Last separator found at index: {lastSeparatorIndex}");
```

## 

7. Convertendo Parte da String para Array de Caracteres (`ToCharArray(int, int)`)

Enquanto `ToCharArray()` converte a string inteira, esta sobrecarga permite converter apenas uma porção da string para um array de caracteres.

```CSHARP
string fullAddress = "123 Main Street, Anytown";
// Get characters for "Main Street"
char[] streetChars = fullAddress.ToCharArray(4, 11); // Start at index 4, take 11 characters
string streetName = new string(streetChars); // Convert char array back to string
Console.WriteLine($"Street Name: {streetName}");
```

## 

8. Entendendo `string.Clone()` (Imutabilidade)

O método `Clone()` retorna uma nova referência para a mesma instância da string. Devido à imutabilidade das strings em C#, clonar uma string não cria uma cópia separada do conteúdo, mas sim uma nova referência para o mesmo objeto na memória. Isso é importante para entender o comportamento de strings.

```CSHARP
string originalString = "Immutable";
string clonedString = (string)originalString.Clone();

bool areSameReference = ReferenceEquals(originalString, clonedString); // Result: true
Console.WriteLine($"Are original and cloned strings the same reference? {areSameReference}");

// Modifying 'clonedString' actually creates a new string due to imutability
clonedString = clonedString + " Text";
Console.WriteLine($"Original: {originalString}, Cloned (modified): {clonedString}");
```

Termos Técnicos:

* Imutabilidade: Uma propriedade de um objeto cujo estado não pode ser modificado após sua criação.

* `ReferenceEquals()`: Um método estático que verifica se duas referências de objeto apontam para a mesma instância na memória.

## 

9. Copiando Conteúdo para Array de Caracteres (`CopyTo()`)

O método `CopyTo()` permite copiar uma parte ou a totalidade dos caracteres de uma string para um array de caracteres existente, a partir de um índice específico no array de destino.

```CSHARP
string source = "Hello World";
char[] destination = new char[10]; // Create a char array to copy into

// Copy 5 characters from 'source' starting at index 0, to 'destination' starting at index 0
source.CopyTo(0, destination, 0, 5); // Result: destination = ['H', 'e', 'l', 'l', 'o', ' ', ' ', ' ', ' ', ' ']
Console.WriteLine($"Copied characters: {new string(destination)}");
```

## 

10. Obtendo o Código Hash (`GetHashCode()`)

O método `GetHashCode()` retorna um código hash numérico para a string. Isso é fundamental para o funcionamento de coleções baseadas em hash, como `Dictionary<TKey, TValue>` e `HashSet<T>`, onde as strings são usadas como chaves. Strings iguais (com base em `Equals()`) devem ter o mesmo código hash.

```CSHARP
string key1 = "ProductA";
string key2 = "ProductA";
string key3 = "productA";

int hash1 = key1.GetHashCode();
int hash2 = key2.GetHashCode();
int hash3 = key3.GetHashCode();

Console.WriteLine($"Hash for '{key1}': {hash1}");
Console.WriteLine($"Hash for '{key2}': {hash2}");
Console.WriteLine($"Hash for '{key3}': {hash3}");
// hash1 and hash2 will be the same. hash3 will likely be different due to case-sensitivity.
```

Termos Técnicos:

* Código Hash: Um valor numérico gerado a partir de um objeto, usado para identificar o objeto em estruturas de dados baseadas em hash. Idealmente, objetos iguais devem ter o mesmo código hash.

## 

11. Normalização Unicode (`Normalize()`, `IsNormalized()`)

Caracteres Unicode podem ter múltiplas representações binárias (formas de composição). A normalização garante que strings com o mesmo significado tenham a mesma representação binária, o que é crucial para comparações e buscas corretas em sistemas que lidam com múltiplos idiomas.

### 

`Normalize()`

Retorna uma nova string que é a forma normalizada da string atual.

```CSHARP
string combinedChar = "e\u0301"; // 'e' followed by combining acute accent
string precomposedChar = "\u00E9"; // 'é' as a single character

Console.WriteLine($"Combined: {combinedChar}, Length: {combinedChar.Length}"); // Length: 2
Console.WriteLine($"Precomposed: {precomposedChar}, Length: {precomposedChar.Length}"); // Length: 1

// Normalize to Form C (Canonical Composition)
string normalizedCombined = combinedChar.Normalize(System.Text.NormalizationForm.FormC);
Console.WriteLine($"Normalized Combined: {normalizedCombined}, Length: {normalizedCombined.Length}"); // Length: 1, same as precomposed

bool areEqualAfterNormalize = string.Equals(normalizedCombined, precomposedChar); // Result: true
Console.WriteLine($"Are equal after normalization? {areEqualAfterNormalize}");
```

### 

`IsNormalized()`

Verifica se a string já está em uma forma de normalização específica.

```CSHARP
string text1 = "résumé"; // Already normalized (Form C)
string text2 = "re\u0301sume"; // 'e' followed by combining acute accent

bool isText1Normalized = text1.IsNormalized(System.Text.NormalizationForm.FormC); // Result: true
Console.WriteLine($"'{text1}' is normalized (FormC)? {isText1Normalized}");

bool isText2Normalized = text2.IsNormalized(System.Text.NormalizationForm.FormC); // Result: false
Console.WriteLine($"'{text2}' is normalized (FormC)? {isText2Normalized}");
```

Termos Técnicos:

* Unicode: Um padrão de codificação de caracteres que visa representar todos os caracteres de todos os sistemas de escrita do mundo.

* Normalização Unicode: O processo de transformar strings Unicode em uma forma canônica para garantir que strings com o mesmo significado tenham a mesma representação binária.

* `NormalizationForm` Enum: Define as diferentes formas de normalização Unicode (e.g., `FormC`, `FormD`).

## 

12. Comparação Ordinal Pura com `string.CompareOrdinal()`

Este método compara strings caractere por caractere, com base em seus valores Unicode (ordem binária), sem aplicar regras de cultura ou maiúsculas/minúsculas. É a comparação mais rápida e é usada quando a equivalência linguística não é um fator, como em hashes ou caminhos de arquivo.

```CSHARP
string path1 = "C:\\Users\\file.txt";
string path2 = "c:\\users\\file.txt";

// Ordinal comparison (case-sensitive, byte-by-byte)
int ordinalResult = string.CompareOrdinal(path1, path2); // Result: non-zero (due to 'C' vs 'c')
Console.WriteLine($"CompareOrdinal '{path1}' and '{path2}': {ordinalResult}");

string s1 = "apple";
string s2 = "Apple";
int ordinalResult2 = string.CompareOrdinal(s1, s2); // Result: non-zero
Console.WriteLine($"CompareOrdinal '{s1}' and '{s2}': {ordinalResult2}");
```

## 

13. Formatação Avançada com `string.Format` (Revisão de Especificadores)

Embora `string.Format` e interpolação de strings tenham sido introduzidos, a profundidade dos especificadores de formato é vasta. Aqui, focamos em alguns exemplos avançados para números e datas.

### Formatação Numérica

```CSHARP
double price = 12345.6789;
Console.WriteLine($"Currency (C): {string.Format("{0:C}", price)}"); // Result: R$12,345.68 (culture-dependent)
Console.WriteLine($"Number (N2): {string.Format("{0:N2}", price)}"); // Result: 12,345.68 (culture-dependent)
Console.WriteLine($"Percentage (P1): {string.Format("{0:P1}", 0.75)}"); // Result: 75.0%
Console.WriteLine($"Custom (000.00): {string.Format("{0:000.00}", 12.3)}"); // Result: 012.30
```

### Formatação de Data e Hora

```CSHARP
DateTime now = DateTime.Now;
Console.WriteLine($"Short Date (d): {string.Format("{0:d}", now)}"); // Result: 26/07/2025 (culture-dependent)
Console.WriteLine($"Long Date (D): {string.Format("{0:D}", now)}"); // Result: sábado, 26 de julho de 2025 (culture-dependent)
Console.WriteLine($"Full Date/Time (F): {string.Format("{0:F}", now)}"); // Result: sábado, 26 de julho de 2025 10:30:00 (culture-dependent)
Console.WriteLine($"Custom (yyyy-MM-dd HH:mm): {string.Format("{0:yyyy-MM-dd HH:mm}", now)}"); // Result: 2025-07-26 10:30
```

Termos Técnicos:

* Especificadores de Formato: Caracteres ou sequências de caracteres que controlam como um valor é convertido para sua representação de string (e.g., `C` para moeda, `N` para número, `d` para data curta).

## Conclusão

Dominar esses métodos e conceitos avançados de manipulação de strings no C# é um diferencial para qualquer desenvolvedor. Eles permitem escrever código mais robusto, eficiente e adaptável a diferentes cenários, desde a validação de dados até a internacionalização de aplicações. A prática contínua com esses recursos solidificará sua expertise em lidar com dados textuais de forma profissional.



# Mais Métodos e Conceitos

No desenvolvimento de software, a manipulação de texto é uma tarefa constante. À medida que os sistemas crescem em complexidade e performance se torna um fator crítico, é essencial ir além dos métodos básicos de string e explorar ferramentas mais poderosas e eficientes. Este documento apresenta uma seleção de métodos e conceitos avançados que permitem um controle mais granular e otimizado sobre as operações com strings no C#.

## 

1. Otimização de Memória: String Pooling (`string.Intern()`, `string.IsInterned()`)

Imagine que você tem uma biblioteca com muitos livros, e vários deles têm o mesmo título. Em vez de ter várias cópias físicas do mesmo título, a biblioteca decide ter apenas uma cópia e várias referências a ela. No C#, o string pooling (ou interning) funciona de forma semelhante para otimizar o uso de memória, especialmente para strings literais e strings frequentemente repetidas.

Quando uma string é interned, o Common Language Runtime (CLR) a armazena em um pool interno. Se outra string com o mesmo valor for criada, em vez de alocar nova memória, o CLR retorna uma referência à instância existente no pool.

### 

`string.Intern(string str)`

Adiciona a string especificada ao pool de interning. Se a string já estiver no pool, retorna a referência à instância existente.

### 

`string.IsInterned(string str)`

Verifica se a string especificada já está no pool de interning. Retorna a referência à instância interned se estiver, caso contrário, retorna `null`.

```CSHARP
string s1 = "Hello World";
string s2 = "Hello World";
string s3 = new StringBuilder().Append("Hello").Append(" World").ToString();

// s1 and s2 are string literals, they are automatically interned by the CLR
bool areSameReference1 = ReferenceEquals(s1, s2); // Result: true
Console.WriteLine($"s1 and s2 are same reference: {areSameReference1}");

// s3 is created at runtime, so it's a new object
bool areSameReference2 = ReferenceEquals(s1, s3); // Result: false
Console.WriteLine($"s1 and s3 are same reference (before intern): {areSameReference2}");

// Intern s3
string s3Interned = string.Intern(s3);

bool areSameReference3 = ReferenceEquals(s1, s3Interned); // Result: true
Console.WriteLine($"s1 and s3Interned are same reference (after intern): {areSameReference3}");

// Check if a string is interned
string internedCheck1 = string.IsInterned(s1); // Result: "Hello World"
string internedCheck2 = string.IsInterned(s3); // Result: "Hello World" (after s3 was interned)
string internedCheck3 = string.IsInterned("Another String"); // Result: null (if not interned yet)
Console.WriteLine($"Is s1 interned? {internedCheck1 != null}");
Console.WriteLine($"Is s3 interned? {internedCheck2 != null}");
Console.WriteLine($"Is 'Another String' interned? {internedCheck3 != null}");
```

Termos Técnicos:

* String Pooling (Interning): Um mecanismo de otimização de memória onde strings com o mesmo valor são armazenadas como uma única instância na memória.

* CLR (Common Language Runtime): O ambiente de execução do .NET que gerencia a execução de programas.

* `ReferenceEquals()`: Um método estático que verifica se duas referências de objeto apontam para a mesma instância na memória.

## 

2. Construção Eficiente de Strings: `StringBuilder`

Imagine que você está construindo uma parede tijolo por tijolo. Se você tivesse que demolir a parede inteira e reconstruí-la do zero a cada novo tijolo, seria muito ineficiente. Strings em C# são imutáveis, o que significa que cada operação que "modifica" uma string na verdade cria uma nova. Para cenários onde você precisa realizar muitas concatenações ou modificações em uma string, `StringBuilder` é a ferramenta ideal, pois ela permite a modificação eficiente de uma sequência de caracteres sem criar novas instâncias de string a cada operação.

```CSHARP
using System.Text;

StringBuilder sb = new StringBuilder();

sb.Append("Hello");
sb.Append(" World");
sb.AppendLine(" from StringBuilder!"); // Appends text and a new line
sb.AppendFormat("The current time is {0:HH:mm:ss}", DateTime.Now); // Appends formatted text

Console.WriteLine($"StringBuilder content: {sb.ToString()}");

sb.Insert(6, "Big "); // Insert "Big " at index 6
Console.WriteLine($"After Insert: {sb.ToString()}");

sb.Replace("World", "Universe"); // Replace "World" with "Universe"
Console.WriteLine($"After Replace: {sb.ToString()}");

sb.Remove(0, 6); // Remove 6 characters from the beginning
Console.WriteLine($"After Remove: {sb.ToString()}");

// Get the final string
string finalString = sb.ToString();
Console.WriteLine($"Final String: {finalString}");
```

Termos Técnicos:

* Mutabilidade: A capacidade de um objeto ter seu estado alterado após sua criação.

* `System.Text` Namespace: O namespace que contém classes para manipulação de caracteres e codificações de texto, incluindo `StringBuilder`.

## 

3. Comparação de Strings com Opções de Cultura (`string.Compare(string, string, bool, CultureInfo)`)

Embora `string.Compare` com `StringComparison` tenha sido abordado, a sobrecarga que aceita um `CultureInfo` permite especificar explicitamente as regras de comparação cultural, o que é vital para aplicações globalizadas.

```CSHARP
using System.Globalization;

string strA = "Straße";
string strB = "strasse";

// Case-insensitive comparison using German culture
int resultGerman = string.Compare(strA, strB, true, new CultureInfo("de-DE"));
Console.WriteLine($"Compare '{strA}' and '{strB}' (German, ignore case): {resultGerman}");
// In German, 'ß' is often treated as 'ss' for case-insensitive comparisons, so result might be 0.

string strC = "file";
string strD = "File";

// Case-sensitive comparison using InvariantCulture
int resultInvariant = string.Compare(strC, strD, false, CultureInfo.InvariantCulture);
Console.WriteLine($"Compare '{strC}' and '{strD}' (Invariant, case-sensitive): {resultInvariant}");
```

Termos Técnicos:

* `CultureInfo`: Uma classe que fornece informações sobre uma cultura específica, incluindo convenções de formatação de data, hora, números e regras de comparação de strings.

* `InvariantCulture`: Uma cultura que é independente de qualquer cultura específica. É usada para operações que devem produzir resultados consistentes, independentemente das configurações de cultura do usuário.

## 

4. Verificando o Tipo de Caractere (`char.IsDigit()`, `char.IsLetter()`, etc.)

Imagine que você está validando uma senha e precisa garantir que ela contenha pelo menos um número, uma letra e um símbolo. A classe `char` (que representa um único caractere) oferece métodos estáticos para verificar a categoria de um caractere, o que é muito útil para validação e análise de texto.

```CSHARP
string password = "P@ssw0rd1!";

bool hasDigit = false;
bool hasLetter = false;
bool hasSymbol = false;

foreach (char c in password)
{
    if (char.IsDigit(c))
    {
        hasDigit = true;
    }
    else if (char.IsLetter(c))
    {
        hasLetter = true;
    }
    else if (char.IsSymbol(c) || char.IsPunctuation(c))
    {
        hasSymbol = true;
    }
}

Console.WriteLine($"Password '{password}' has digit: {hasDigit}");
Console.WriteLine($"Password '{password}' has letter: {hasLetter}");
Console.WriteLine($"Password '{password}' has symbol/punctuation: {hasSymbol}");

// Other useful char methods:
Console.WriteLine($"Is ' ' whitespace? {char.IsWhiteSpace(' ')}");
Console.WriteLine($"Is 'A' upper? {char.IsUpper('A')}");
Console.WriteLine($"Is 'a' lower? {char.IsLower('a')}");
```

Termos Técnicos:

* `char` (tipo): Um tipo de dado que representa um único caractere Unicode.

* Métodos Estáticos da Classe `char`: Funções que operam em caracteres e são chamadas diretamente na classe `char` (e.g., `char.IsDigit()`).

## 

5. Removendo Caracteres Específicos com `TrimStart(char[])` e `TrimEnd(char[])`

Complementando o `Trim(char[])` já visto, estes métodos permitem remover um conjunto específico de caracteres apenas do início (`TrimStart`) ou apenas do final (`TrimEnd`) de uma string.

```CSHARP
string rawInput = "###DATA###";
char[] trimChars = { '#' };

string startTrimmed = rawInput.TrimStart(trimChars); // Result: "DATA###"
Console.WriteLine($"Trimmed Start: '{startTrimmed}'");

string endTrimmed = rawInput.TrimEnd(trimChars); // Result: "###DATA"
Console.WriteLine($"Trimmed End: '{endTrimmed}'");
```

## 

6. Verificando se a String é Numérica (`double.TryParse()`, `int.TryParse()`, etc.)

Em vez de apenas verificar se um caractere é um dígito, muitas vezes você precisa saber se uma string inteira pode ser convertida para um tipo numérico. Os métodos `TryParse()` são a maneira segura e eficiente de fazer isso, evitando exceções.

```CSHARP
string priceText = "123.45";
string quantityText = "50";
string invalidText = "abc";

// Try parsing to double
if (double.TryParse(priceText, out double price))
{
    Console.WriteLine($"Price parsed: {price}");
}
else
{
    Console.WriteLine($"Could not parse price: {priceText}");
}

// Try parsing to int
if (int.TryParse(quantityText, out int quantity))
{
    Console.WriteLine($"Quantity parsed: {quantity}");
}
else
{
    Console.WriteLine($"Could not parse quantity: {quantityText}");
}

// Invalid parse attempt
if (!int.TryParse(invalidText, out int parsedInvalid))
{
    Console.WriteLine($"Successfully failed to parse: {invalidText}");
}
```

Termos Técnicos:

* `TryParse()`: Um padrão de método em .NET que tenta converter uma string para um tipo específico e retorna um booleano indicando o sucesso, sem lançar uma exceção em caso de falha.

* `out` Keyword: Uma palavra-chave em C# usada para passar argumentos para métodos por referência, permitindo que o método retorne valores através desses argumentos.

## 

7. Comparação de Strings com RegEx (`Regex.IsMatch()`)

Para padrões de busca e validação mais complexos do que `Contains()` ou `StartsWith()`, Expressões Regulares (RegEx) são a ferramenta. `Regex.IsMatch()` verifica se uma string corresponde a um padrão RegEx.

```CSHARP
using System.Text.RegularExpressions;

string emailAddress = "test@example.com";
string invalidEmail = "test@example";

// Regex pattern for a simple email validation
string emailPattern = @"^[^@\s]+@[^@\s]+\.[^@\s]+$";

bool isValidEmail1 = Regex.IsMatch(emailAddress, emailPattern);
Console.WriteLine($"'{emailAddress}' is valid email: {isValidEmail1}");

bool isValidEmail2 = Regex.IsMatch(invalidEmail, emailPattern);
Console.WriteLine($"'{invalidEmail}' is valid email: {isValidEmail2}");

// Check for a specific format, e.g., a product code like ABC-1234
string productCode = "XYZ-9876";
string productPattern = @"^[A-Z]{3}-\d{4}$";
bool isProductCodeValid = Regex.IsMatch(productCode, productPattern);
Console.WriteLine($"'{productCode}' matches product pattern: {isProductCodeValid}");
```

Termos Técnicos:

* Expressão Regular (RegEx): Uma sequência de caracteres que define um padrão de busca. Usada para encontrar, substituir e validar texto que corresponde a esse padrão.

* `System.Text.RegularExpressions` Namespace: O namespace que contém classes para trabalhar com expressões regulares.

## 

8. Substituição com RegEx (`Regex.Replace()`)

Além de verificar, RegEx também pode ser usado para substituir partes de uma string que correspondem a um padrão.

```CSHARP
string logLine = "User: JohnDoe, IP: 192.168.1.100, Status: Success";
// Replace IP addresses with [REDACTED]
string redactedLog = Regex.Replace(logLine, @"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b", "[REDACTED]");
Console.WriteLine($"Redacted Log: {redactedLog}");

string phoneNumber = "(11) 98765-4321";
// Remove all non-digit characters
string cleanedPhoneNumber = Regex.Replace(phoneNumber, @"\D", ""); // \D matches any non-digit character
Console.WriteLine($"Cleaned Phone Number: {cleanedPhoneNumber}");
```

## 

9. Extração com RegEx (`Regex.Match()`, `Regex.Matches()`)

Para extrair informações específicas de uma string que seguem um padrão, `Regex.Match()` (para a primeira ocorrência) e `Regex.Matches()` (para todas as ocorrências) são poderosos.

```CSHARP
string textWithPrices = "Item A: $10.50, Item B: $25.00, Item C: $5.99";
string pricePattern = @"\$(\d+\.\d{2})"; // Pattern to capture prices like $XX.YY

// Find all matches
MatchCollection matches = Regex.Matches(textWithPrices, pricePattern);
Console.WriteLine("Extracted Prices:");
foreach (Match match in matches)
{
    // Group 1 contains the captured price without the dollar sign
    Console.WriteLine($"- {match.Groups[1].Value}");
}
```

## 

10. Verificando se a String é Nula ou Vazia de Forma Concisa (`string.IsNullOrEmpty()` com operador `??`)

Embora `string.IsNullOrEmpty()` tenha sido abordado, a combinação com o operador de coalescência nula (`??`) é uma prática comum para fornecer um valor padrão quando uma string é nula ou vazia.

```CSHARP
string userName = null;
string defaultName = "Guest";

string displayUserName = userName ?? defaultName; // If userName is null, use defaultName
Console.WriteLine($"Display User Name (null): {displayUserName}");

string email = "";
string defaultEmail = "no_email@example.com";

// This won't work directly with ?? for empty strings, as ?? only checks for null
string displayEmail = email ?? defaultEmail; // Result: "" (email is not null)
Console.WriteLine($"Display Email (empty, with ??): {displayEmail}");

// Correct way to handle null or empty
string finalEmail = string.IsNullOrEmpty(email) ? defaultEmail : email;
Console.WriteLine($"Display Email (empty, with IsNullOrEmpty): {finalEmail}");
```

Termos Técnicos:

* Operador de Coalescência Nula (`??`): Um operador que retorna o operando esquerdo se ele não for nulo; caso contrário, retorna o operando direito.

## 

11. Criando Strings a Partir de Caracteres Repetidos (`new string(char, int)`)

Um construtor de string útil para criar uma string composta por um caractere repetido um certo número de vezes.

```CSHARP
string separator = new string('-', 20); // Result: "--------------------"
Console.WriteLine(separator);

string padding = new string(' ', 10); // Result: "          "
Console.WriteLine($"Padded text: {padding}Hello");
```

## 

12. Comparando Strings para Igualdade de Conteúdo (`string.Equals(object)`)

Embora `string.Equals(string, StringComparison)` seja mais poderoso, a sobrecarga `string.Equals(object)` é a que é chamada quando você usa `myString.Equals(anotherObject)`. É importante entender que ela compara o conteúdo da string, não a referência, e é segura para usar com objetos que podem não ser strings.

```CSHARP
string s1 = "Test";
object o1 = "Test";
object o2 = new StringBuilder("Test").ToString();

bool equalsObject1 = s1.Equals(o1); // Result: true
Console.WriteLine($"s1 equals o1: {equalsObject1}");

bool equalsObject2 = s1.Equals(o2); // Result: true
Console.WriteLine($"s1 equals o2: {equalsObject2}");

object o3 = 123; // Not a string
bool equalsObject3 = s1.Equals(o3); // Result: false
Console.WriteLine($"s1 equals o3: {equalsObject3}");
```

## 

13. Obtendo um Substring de um Caractere (`string.Substring(int, int)` com `IndexOf`)

Uma aplicação prática de `Substring` e `IndexOf` é extrair texto entre dois delimitadores ou a partir de um delimitador até o final.

```CSHARP
string logMessage = "[INFO] User logged in at 2025-07-26";

// Extract message content (after first ']')
int startIndex = logMessage.IndexOf("]") + 2; // +2 to skip ']' and space
string messageContent = logMessage.Substring(startIndex);
Console.WriteLine($"Log Content: {messageContent}");

string dataRecord = "ID:123;Name:Alice;Status:Active";
// Extract Name
int nameStartIndex = dataRecord.IndexOf("Name:") + "Name:".Length;
int nameEndIndex = dataRecord.IndexOf(";", nameStartIndex);
string name = dataRecord.Substring(nameStartIndex, nameEndIndex - nameStartIndex);
Console.WriteLine($"Extracted Name: {name}");
```

## 

14. Verificando se a String é Vazia (`string.IsEmpty` - C# 11+)

Para versões mais recentes do C# (11 e superior), a propriedade `string.IsEmpty` foi introduzida para uma verificação mais clara e performática de strings vazias, sem a necessidade de verificar `null` separadamente.

```CSHARP
string emptyString = "";
string nonEmptyString = "data";

// Requires C# 11 or later
// bool isEmpty1 = emptyString.IsEmpty; // Result: true
// bool isEmpty2 = nonEmptyString.IsEmpty; // Result: false
// Console.WriteLine($"Is empty string empty? {isEmpty1}");
// Console.WriteLine($"Is non-empty string empty? {isEmpty2}");

// For older C# versions, use Length == 0
bool isEmptyLegacy1 = emptyString.Length == 0; // Result: true
bool isEmptyLegacy2 = nonEmptyString.Length == 0; // Result: false
Console.WriteLine($"Is empty string empty (legacy)? {isEmptyLegacy1}");
Console.WriteLine($"Is non-empty string empty (legacy)? {isEmptyLegacy2}");
```

Termos Técnicos:

* C# 11+: Indica que a funcionalidade está disponível a partir da versão 11 da linguagem C#.

## 

15. Usando `ReadOnlySpan<char>` para Performance (C# 7.2+)

Para operações de string de alta performance que não envolvem alocação de memória (como leitura de substrings sem copiá-las), `ReadOnlySpan<char>` é uma ferramenta avançada. Ele permite trabalhar com uma "visão" de uma parte da memória sem criar uma nova string.

```CSHARP
// This is an advanced topic for performance-critical scenarios.
// Requires .NET Core 2.1+ or .NET Standard 2.1+ and C# 7.2+

string largeLog = "[2025-07-26 10:30:00 INFO] User 'Alice' logged in from IP 192.168.1.10.";

// Get a span over the log message without allocating a new string
ReadOnlySpan<char> logSpan = largeLog.AsSpan();

// Find the start and end of the username
int userStartIndex = logSpan.IndexOf("User '") + "User '".Length;
int userEndIndex = logSpan.IndexOf("' logged");

if (userStartIndex != -1 && userEndIndex != -1)
{
    // Create a new span for the username (no allocation for the span itself)
    ReadOnlySpan<char> usernameSpan = logSpan.Slice(userStartIndex, userEndIndex - userStartIndex);
    Console.WriteLine($"Username (from Span): {usernameSpan.ToString()}"); // .ToString() allocates a string if needed
}

// Example: Parsing a date from a string without allocating substrings
string dateString = "2025-07-26";
ReadOnlySpan<char> dateSpan = dateString.AsSpan();

int year = int.Parse(dateSpan.Slice(0, 4));
int month = int.Parse(dateSpan.Slice(5, 2));
int day = int.Parse(dateSpan.Slice(8, 2));

Console.WriteLine($"Parsed Date (from Span): Year={year}, Month={month}, Day={day}");
```

Termos Técnicos:

* `ReadOnlySpan<T>`: Um tipo de referência que pode apontar para uma região contígua de memória. É usado para operações de alta performance que evitam alocações de memória desnecessárias.

* Alocação de Memória: O processo de reservar um espaço na memória do computador para armazenar dados.

## Conclusão

Este conjunto de métodos e conceitos avançados de string no C# equipa você com as ferramentas necessárias para lidar com cenários de manipulação de texto mais complexos e otimizados. Desde a gestão de memória com string pooling até a construção eficiente com `StringBuilder` e a performance de `ReadOnlySpan<char>`, dominar esses recursos é um passo significativo para se tornar um desenvolvedor C# proficiente e capaz de construir aplicações de alta qualidade.



# StringBuilder: Construindo Strings de Forma Eficiente no C#

Imagine que você está construindo uma casa e, a cada novo tijolo que você adiciona, você tivesse que demolir a parede inteira e reconstruí-la do zero, apenas para incluir o novo tijolo. Isso seria incrivelmente ineficiente e demorado, certo? No mundo da programação C#, as strings (`string`) funcionam de forma semelhante: elas são imutáveis.

Isso significa que, uma vez que uma string é criada, seu conteúdo não pode ser alterado. Quando você realiza uma operação que parece modificar uma string (como concatenar duas strings com o operador `+`), o que realmente acontece é que uma nova string é criada na memória com o resultado da operação, e a string original permanece intocada. Para poucas operações, isso não é um problema. Mas quando você precisa realizar muitas concatenações ou modificações em uma string, especialmente dentro de loops, essa criação constante de novas strings pode levar a um consumo excessivo de memória e impactar negativamente a performance da sua aplicação.

É aí que entra o `StringBuilder`.

## 

O que é `StringBuilder`?

`StringBuilder` é uma classe no C# (localizada no namespace `System.Text`) que representa uma sequência de caracteres mutável. Ao contrário da `string` imutável, um `StringBuilder` permite que você adicione, remova, substitua ou insira caracteres sem criar um novo objeto na memória a cada operação. Ele gerencia um buffer interno de caracteres que cresce dinamicamente conforme necessário, tornando-o muito mais eficiente para cenários de manipulação intensiva de strings.

## 

Por que usar `StringBuilder`?

O principal motivo para usar `StringBuilder` é a performance e a eficiência de memória, especialmente em situações onde:

* Você precisa concatenar um grande número de strings.

* Você está construindo uma string dentro de um loop.

* Você precisa realizar muitas operações de inserção, remoção ou substituição em uma string.

Ao usar `StringBuilder`, você evita a alocação desnecessária de memória e a cópia de dados que ocorrem com a manipulação de strings imutáveis, resultando em um código mais rápido e com menor pegada de memória.

## 

Métodos Comuns do `StringBuilder`

Vamos explorar os métodos mais utilizados da classe `StringBuilder`:

### 

1. `Append()`: Adicionando Texto

Adiciona uma representação de string de um objeto ou o conteúdo de outra string ao final da instância atual do `StringBuilder`.

```CSHARP
using System.Text;

StringBuilder logBuilder = new StringBuilder();
logBuilder.Append("User logged in.");
logBuilder.Append(" IP Address: ");
logBuilder.Append("192.168.1.100");

Console.WriteLine(logBuilder.ToString()); // Result: User logged in. IP Address: 192.168.1.100
```

### 

2. `AppendLine()`: Adicionando Texto com Nova Linha

Adiciona uma representação de string de um objeto ou o conteúdo de outra string, seguida por um terminador de linha, ao final da instância atual do `StringBuilder`.

```CSHARP
StringBuilder reportBuilder = new StringBuilder();
reportBuilder.AppendLine("Daily Sales Report");
reportBuilder.AppendLine("------------------");
reportBuilder.AppendLine("Product A: 150 units");
reportBuilder.AppendLine("Product B: 200 units");

Console.WriteLine(reportBuilder.ToString());
/* Result:
Daily Sales Report
------------------
Product A: 150 units
Product B: 200 units
*/
```

### 

3. `AppendFormat()`: Adicionando Texto Formatado

Adiciona uma string formatada ao final da instância atual do `StringBuilder`, usando a mesma sintaxe de formatação de `string.Format()`.

```CSHARP
StringBuilder messageBuilder = new StringBuilder();
double price = 99.99;
int quantity = 3;

messageBuilder.AppendFormat("Item: {0}, Price: {1:C}, Quantity: {2}", "Laptop", price, quantity);

Console.WriteLine(messageBuilder.ToString()); // Result: Item: Laptop, Price: $99.99, Quantity: 3 (currency symbol depends on culture)
```

### 

4. `Insert()`: Inserindo Texto

Insere uma representação de string de um objeto ou o conteúdo de outra string em uma posição específica dentro da instância atual do `StringBuilder`.

```CSHARP
StringBuilder sentenceBuilder = new StringBuilder("Hello World!");
sentenceBuilder.Insert(6, "Big "); // Insert "Big " at index 6

Console.WriteLine(sentenceBuilder.ToString()); // Result: Hello Big World!
```

### 

5. `Remove()`: Removendo Caracteres

Remove um número especificado de caracteres de uma posição inicial dentro da instância atual do `StringBuilder`.

```CSHARP
StringBuilder dataBuilder = new StringBuilder("This is some temporary data.");
dataBuilder.Remove(8, 10); // Remove 10 characters starting from index 8 ("some tempor")

Console.WriteLine(dataBuilder.ToString()); // Result: This is ary data.
```

### 

6. `Replace()`: Substituindo Texto

Substitui todas as ocorrências de uma substring por outra substring dentro da instância atual do `StringBuilder`.

```CSHARP
StringBuilder textBuilder = new StringBuilder("The quick brown fox jumps over the lazy fox.");
textBuilder.Replace("fox", "dog");

Console.WriteLine(textBuilder.ToString()); // Result: The quick brown dog jumps over the lazy dog.
```

### 

7. `ToString()`: Convertendo para `string`

Converte o conteúdo atual do `StringBuilder` em uma nova instância de `string`. Esta é a etapa final para obter a string imutável que você pode usar em outras partes do seu código ou exibir.

```CSHARP
StringBuilder finalMessageBuilder = new StringBuilder();
finalMessageBuilder.Append("Operation completed successfully.");

string finalResult = finalMessageBuilder.ToString();
Console.WriteLine(finalResult); // Result: Operation completed successfully.
```

## 

Quando usar `StringBuilder` vs. Concatenação de `string`

| Característica |`string` Concatenation (`+`) |`StringBuilder` |
-----------------------------------------------------------------
| Mutabilidade |Imutável (cria nova string a cada modificação) |Mutável (modifica o buffer interno) |
| Performance |Menor para muitas operações (criação de objetos e cópias) |Maior para muitas operações (modifica no lugar) |
| Uso de Memória |Maior (muitas strings intermediárias) |Menor (reutiliza o mesmo buffer) |
| Cenários Ideais |Poucas concatenações, strings pequenas, operações simples |Muitas concatenações, construção de strings em loops, strings grandes, modificações frequentes |

Regra Geral: Se você espera realizar 5 ou mais operações de concatenação ou modificação em uma string, considere usar `StringBuilder`. Para menos que isso, a concatenação simples de `string` pode ser mais legível e o impacto na performance é insignificante.

## Conclusão

`StringBuilder` é uma ferramenta poderosa e essencial no arsenal de qualquer desenvolvedor C# que lida com manipulação de texto. Compreender sua finalidade e saber quando utilizá-lo pode levar a melhorias significativas na performance e no uso de memória de suas aplicações, especialmente em cenários de alta demanda por processamento de strings. Ao dominar o `StringBuilder`, você escreve um código mais eficiente e robusto.



# Datas

Manipular datas e horas é uma das tarefas mais comuns e, surpreendentemente, uma das mais complexas na programação. Um simples carimbo de data pode esconder armadilhas relacionadas a fusos horários, formatação e performance.

Este guia vai além do básico do `DateTime` e apresenta as ferramentas e práticas recomendadas para manipular datas e horas em C# de forma profissional e robusta.

## A Família de Tipos de Data e Hora

O .NET oferece uma família de tipos para trabalhar com datas e horas. É crucial escolher a ferramenta certa para cada trabalho.

| Tipo |Descrição |Quando Usar |
--------------------------------
| `DateTime` |Representa um ponto no tempo, geralmente expresso como uma data e hora do dia. |Usado para necessidades simples, mas pode ser ambíguo em relação ao fuso horário. |
| `DateTimeOffset` |Representa um ponto no tempo, incluindo um deslocamento (offset) do Tempo Universal Coordenado (UTC). |Recomendado para a maioria dos casos, especialmente em APIs e bancos de dados, pois não é ambíguo. |
| `TimeSpan` |Representa uma duração ou intervalo de tempo. |Para medir o tempo entre dois pontos ou representar uma quantidade de tempo (ex: 24 horas). |
| `DateOnly` |(.NET 6+) Representa apenas a parte da data, sem a hora. |Quando você só precisa do dia, mês e ano (ex: data de nascimento). |
| `TimeOnly` |(.NET 6+) Representa apenas a hora do dia, sem a data. |Quando você só precisa da hora (ex: horário de funcionamento de uma loja). |
| `TimeZoneInfo` |Representa um fuso horário. |Para converter datas e horas entre diferentes fusos horários. |

## 

O `DateTime` e sua Armadilha: `DateTime.Kind`

O `DateTime` parece simples, mas ele carrega uma propriedade traiçoeira chamada `Kind`. Ela define como o valor da data deve ser interpretado em relação ao fuso horário e pode ser de três tipos:

* `DateTimeKind.Utc`: A data e hora são expressas em Tempo Universal Coordenado. É um padrão global, o mesmo em todo o mundo.

* `DateTimeKind.Local`: A data e hora estão no fuso horário local da máquina onde o código está rodando. Isso pode variar de servidor para servidor.

* `DateTimeKind.Unspecified`: O fuso horário não foi especificado. Este é o padrão para datas criadas manualmente e a principal fonte de bugs.

### 

Exemplo de Bug com `DateTimeKind.Unspecified`

Imagine que um usuário no Brasil (UTC-3) agenda uma tarefa para as `14:00`. Você salva isso no banco de dados como `new DateTime(2025, 10, 20, 14, 0, 0)`. O `Kind` será `Unspecified`.

Um serviço rodando em um servidor na Europa (UTC+1) lê essa data. Ao tentar converter para a hora local, o .NET pode assumir que `14:00` era a hora local do servidor, e não do usuário. A tarefa que deveria rodar às `14:00` no Brasil acaba rodando em um horário completamente diferente.

```
// Kind is DateTimeKind.Unspecified
var unspecifiedTime = new DateTime(2025, 1, 1, 14, 0, 0); 

// This conversion is unreliable because the source Kind is Unspecified.
// The .NET runtime will assume it's a Local time according to the server's timezone.
var convertedTime = unspecifiedTime.ToUniversalTime();

Console.WriteLine($"Original: {unspecifiedTime} (Kind: {unspecifiedTime.Kind})");
Console.WriteLine($"Converted to UTC: {convertedTime}"); // The result depends on the server's timezone!
```

## 

A Solução Profissional: `DateTimeOffset`

Para evitar a ambiguidade do `DateTime.Kind`, use `DateTimeOffset`. Ele armazena a mesma informação que o `DateTime`, mas também inclui o offset, que é a diferença de tempo em relação ao UTC. Isso torna o momento no tempo absoluto e inequívoco.

Um offset de `-03:00` significa "três horas a menos que o UTC".

```
// This object represents an absolute moment in time.
// The offset (-03:00) makes it unambiguous.
var specificMoment = new DateTimeOffset(2025, 8, 16, 15, 0, 0, TimeSpan.FromHours(-3));
Console.WriteLine(specificMoment);

// You can easily convert it to another timezone's offset, for example, India (UTC+5:30)
var indiaTime = specificMoment.ToOffset(TimeSpan.FromMinutes(330));
Console.WriteLine($"Same moment in India: {indiaTime}");

// And you can always get the pure UTC value
Console.WriteLine($"UTC value: {specificMoment.ToUniversalTime()}");
```

Com `DateTimeOffset`, o momento `16/08/2025 15:00:00 -03:00` é sempre o mesmo, não importa se o servidor que processa essa informação está no Brasil, no Japão ou na Lua.

## 

Os Especialistas: `DateOnly` e `TimeOnly`

Introduzidos no .NET 6, esses tipos resolvem um problema antigo: a necessidade de carregar uma data e hora completas quando você só precisa de uma parte. Eles são mais eficientes (usam menos memória) e deixam a intenção do seu código mais clara.

### 

`DateOnly`

Use para representar uma data de calendário. Mapeia perfeitamente para o tipo `date` em SQL.

```
// Represents a birth date, time is irrelevant.
var birthDate = new DateOnly(1990, 10, 20);
Console.WriteLine($"Birth date: {birthDate.ToLongDateString()}");
```

### 

`TimeOnly`

Use para representar uma hora do dia. Mapeia para o tipo `time` em SQL.

```
// Represents the opening time of a store
var openingTime = new TimeOnly(9, 0, 0);
Console.WriteLine($"Store opens at: {openingTime.ToLongTimeString()}");
```

## 

Convertendo Texto em Datas (`Parse`)

Receber datas como strings é muito comum. Para convertê-las em objetos, use os métodos `Parse` ou `TryParse`. A melhor prática é ser o mais explícito possível sobre o formato esperado.

### 

A Forma Mais Segura: `TryParseExact`

Para evitar exceções (`try-catch`), que podem impactar a performance, e garantir que apenas um formato específico seja aceito, use `TryParseExact`. Ele retorna `true` se a conversão for bem-sucedida e `false` caso contrário.

```
using System.Globalization;

var dateString = "2025-08-16";
var format = "yyyy-MM-dd";

// We use CultureInfo.InvariantCulture for machine-to-machine communication
// to ensure the format is consistent regardless of system culture.
// DateTimeStyles.None ensures no extra assumptions are made.
if (DateTime.TryParseExact(dateString, format, CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime parsedDate))
{
    Console.WriteLine($"Successfully parsed: {parsedDate:D}");
}
else
{
    Console.WriteLine("Could not parse the date string.");
}
```

## Boas Práticas para Manipulação de Datas

1. Prefira `DateTimeOffset` a `DateTime`. Use-o como padrão para APIs, bancos de dados e logs. Ele elimina a ambiguidade de fuso horário e torna seu sistema mais robusto.

2. Use `DateTime.UtcNow` para Timestamps. Ao registrar quando um evento ocorreu (ex: data de criação de um registro), use sempre `DateTime.UtcNow` (ou `DateTimeOffset.UtcNow`). O tempo do servidor local é irrelevante e pode mudar com o horário de verão ou com a localização do servidor.

3. Use `DateOnly` e `TimeOnly` quando a informação de hora ou data for irrelevante. Isso torna seu modelo de dados mais claro, eficiente e evita bugs relacionados a partes da data que deveriam ser ignoradas.

4. Seja Explícito ao Fazer `Parse` de Strings. Sempre use `TryParseExact`. Para datas de máquina para máquina (ex: JSON, XML), use `CultureInfo.InvariantCulture` e um formato bem definido (como o padrão ISO 8601: `yyyy-MM-ddTHH:mm:ssZ`). Para datas inseridas por usuários, use a cultura específica deles (`new CultureInfo("pt-BR")`).

5. Armazene Datas em UTC e Converta na Apresentação. A regra de ouro: seu back-end e seu banco de dados devem viver em UTC. A conversão para o fuso horário do usuário deve ser a última etapa, realizada pela interface do usuário (UI).

```MERMAID
graph TD
    subgraph Servidor/Banco de Dados (Sempre em UTC)
        A[DateTimeOffset.UtcNow] --> B{Armazenar em UTC};
    end

    subgraph Cliente/UI (Fuso do Usuário)
        C[Ler data do BD] --> D{Converter para Fuso Local};
        D --> E[Exibir para o Usuário];
    end

    B --> C;
```

## Veja Também (Referências Oficiais)

* [Estrutura DateTime](https://learn.microsoft.com/dotnet/api/system.datetime)

* [Estrutura DateTimeOffset](https://learn.microsoft.com/dotnet/api/system.datetimeoffset)

* [Estruturas DateOnly e TimeOnly](https://learn.microsoft.com/dotnet/standard/datetime/dateonly-timeonly)

* [Escolhendo entre DateTime e DateTimeOffset](https://learn.microsoft.com/dotnet/standard/datetime/choosing-between-datetime-datetimeoffset-and-timezoneinfo)

* [Strings de Formato de Data e Hora Padrão](https://learn.microsoft.com/dotnet/standard/base-types/standard-date-and-time-format-strings)

* [Analisando Strings de Data e Hora em .NET](https://learn.microsoft.com/dotnet/standard/base-types/parsing-datetime)



# Valores Monetários

Imagine que você está construindo uma casa de blocos de montar. Para que a casa fique firme, cada bloco precisa se encaixar perfeitamente no outro, sem sobras ou vãos. Se os blocos não tiverem o tamanho exato, a estrutura toda fica bamba e pode desabar.

Na programação, trabalhar com dinheiro é muito parecido. Precisamos de uma representação numérica que seja perfeitamente exata, como os blocos de montar. Usar um tipo de dado impreciso para dinheiro é como usar blocos de tamanhos errados: no final, a conta não fecha.

## 

O Desafio dos Tipos de Ponto Flutuante (`float` e `double`)

Muitos tipos numéricos, como `float` e `double`, são baseados em representações binárias de "ponto flutuante". Eles são ótimos para cálculos científicos e gráficos, onde uma aproximação minúscula é aceitável.

O problema é que, em binário, é impossível representar com exatidão algumas frações decimais simples, como `0.1` ou `0.2`. Isso leva a pequenos erros de arredondamento que, em cálculos financeiros, se acumulam e causam grandes problemas.

Pense nisso como tentar pagar `R$ 0,30` com moedas que só existem em frações de `1/2`, `1/4`, `1/8`. Você nunca conseguirá o valor exato.

## 

A Solução: O Tipo `decimal`

Para resolver isso, o C# nos oferece o tipo `decimal`. Ele foi projetado especificamente para cálculos financeiros e monetários.

Diferente do `float` e `double`, o `decimal` armazena os números como uma grande quantidade de dígitos (até 29) e a posição da vírgula decimal. Isso garante que valores como `10.99` ou `0.25` sejam armazenados com exatidão total, sem erros de arredondamento.

```MERMAID
graph TD
    A{Preciso de um número com fração} --> B{É para finanças, dinheiro ou contabilidade?};
    B -->|Sim| C[Use `decimal`];
    B -->|Não| D{É para ciência, gráficos 3D ou física?};
    D -->|Sim| E[Use `double` ou `float`];
    D -->|Não| F[Reavalie o requisito. `decimal` ainda é a aposta mais segura.];

    style C fill:#d4edda,stroke:#c3e6cb
    style E fill:#f8d7da,stroke:#f5c6cb
```

Termo Técnico:

* Ponto Flutuante Binário (`float`, `double`): Uma forma de representar números com frações usando potências de 2. É rápido, mas pode ser impreciso para valores decimais.

* Ponto Flutuante Decimal (`decimal`): Uma forma de representar números com frações usando potências de 10. É ideal para finanças, pois representa valores decimais com exatidão.

Sempre que for trabalhar com dinheiro, use `decimal`.

## Realizando Cálculos e Conversões

Trabalhar com `decimal` é direto. Você pode realizar todas as operações aritméticas padrão.

### Operações Aritméticas

```CSHARP
// The 'm' suffix indicates a decimal literal
decimal productPrice = 19.95m;
decimal shippingCost = 5.50m;
decimal discount = 0.10m; // 10% discount

// Addition
decimal subTotal = productPrice + shippingCost;

// Multiplication and Subtraction
decimal discountValue = subTotal * discount;
decimal finalTotal = subTotal - discountValue;

Console.WriteLine($"Subtotal: {subTotal:C}");
Console.WriteLine($"Discount: {discountValue:C}");
Console.WriteLine($"Final Total: {finalTotal:C}");
```

### 

Convertendo Texto em `decimal`

Frequentemente, você receberá valores monetários como texto (por exemplo, de um campo de formulário). É crucial converter esse texto de forma segura, para evitar erros caso o usuário digite um valor inválido. Use `decimal.TryParse()` para isso.

```CSHARP
using System.Globalization;

string userInput = "25,50"; // Input might use a comma
decimal parsedValue;

// TryParse will attempt to convert the string to a decimal.
// It returns true if successful and false if it fails.
// We provide a culture to correctly handle the comma as a decimal separator.
bool isSuccess = decimal.TryParse(userInput, NumberStyles.Currency, new CultureInfo("pt-BR"), out parsedValue);

if (isSuccess)
{
    Console.WriteLine($"Successfully parsed. The value is {parsedValue * 2}");
}
else
{
    Console.WriteLine("Invalid input. Please enter a valid number.");
}
```

## Formatando Moeda para Exibição

Depois que os cálculos estiverem corretos, você precisará mostrar o valor para o usuário de uma forma legível. Para isso, usamos o método `ToString("C")` e a classe `CultureInfo`.

Termo Técnico:

* `CultureInfo`: Um objeto que contém informações sobre uma cultura específica, como o idioma, o formato de data e hora, e o símbolo da moeda.

```CSHARP
using System.Globalization;

decimal value = 1234.56m;

// Format for Brazil (Real)
var cultureBrazil = new CultureInfo("pt-BR");
Console.WriteLine(value.ToString("C", cultureBrazil)); // Outputs: R$ 1.234,56

// Format for United States (Dollar)
var cultureUSA = new CultureInfo("en-US");
Console.WriteLine(value.ToString("C", cultureUSA)); // Outputs: $1,234.56

// Format for Portugal (Euro)
var culturePortugal = new CultureInfo("pt-PT");
Console.WriteLine(value.ToString("C", culturePortugal)); // Outputs: 1 234,56 €
```

## Recomendações e Boas Práticas

1. Sempre use `decimal`: Para qualquer variável que armazene ou calcule valores monetários.

2. Armazene Corretamente no Banco de Dados: Use tipos de dados equivalentes no seu banco de dados, como `DECIMAL` ou `NUMERIC`. Nunca use `FLOAT` ou `REAL`.

3. Evite Conversões Desnecessárias: Mantenha os valores como `decimal` durante todo o ciclo de vida do cálculo.

4. Internacionalização: Se sua aplicação lida com múltiplas moedas, armazene o código da moeda (ex: "BRL", "USD") junto com o valor.

5. Cuidado com o Arredondamento: Este é um tópico crucial.

### 

Detalhando o Arredondamento com `Math.Round()`

Cálculos podem gerar mais casas decimais do que o necessário. Use `Math.Round()` para arredondar os valores para o número correto de casas decimais (geralmente 2).

O .NET usa por padrão uma estratégia chamada "Arredondar para o par mais próximo" (`MidpointRounding.ToEven`). Isso significa que, se um número está exatamente no meio (como 2.5), ele será arredondado para o número par mais próximo (2). Isso é estatisticamente mais justo em grandes conjuntos de dados, mas pode não ser o que você espera em um extrato bancário.

Para o arredondamento "comercial" comum, onde `2.5` vira `3`, use `MidpointRounding.AwayFromZero`.

```CSHARP
decimal value1 = 4.255m;
decimal value2 = 4.265m;

// Default rounding (ToEven)
// 4.255 is halfway, rounds to the nearest even number (4.26)
decimal rounded1_even = Math.Round(value1, 2); 
// 4.265 is halfway, rounds to the nearest even number (4.26)
decimal rounded2_even = Math.Round(value2, 2);

Console.WriteLine($"Default Rounding: {value1} -> {rounded1_even}");
Console.WriteLine($"Default Rounding: {value2} -> {rounded2_even}");


// Commercial rounding (AwayFromZero)
// 4.255 rounds away from zero to 4.26
decimal rounded1_away = Math.Round(value1, 2, MidpointRounding.AwayFromZero);
// 4.265 rounds away from zero to 4.27
decimal rounded2_away = Math.Round(value2, 2, MidpointRounding.AwayFromZero);

Console.WriteLine($"AwayFromZero Rounding: {value1} -> {rounded1_away}");
Console.WriteLine($"AwayFromZero Rounding: {value2} -> {rounded2_away}");
```

## Referências

Para aprofundar seus conhecimentos, consulte a documentação oficial da Microsoft:

* [Tipo decimal](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types): Documentação oficial sobre os tipos de ponto flutuante, incluindo `decimal`.

* [Classe Math.Round()](https://learn.microsoft.com/pt-br/dotnet/api/system.math.round): Detalhes sobre os métodos de arredondamento e suas sobrecargas.

* [Enum MidpointRounding](https://learn.microsoft.com/pt-br/dotnet/api/system.midpointrounding): Explicação sobre as diferentes estratégias de arredondamento.

* [Cadeias de caracteres de formato numérico padrão](https://learn.microsoft.com/pt-br/dotnet/standard/base-types/standard-numeric-format-strings): Guia completo sobre as opções de formatação, incluindo a formatação de moeda ("C").

* [Classe CultureInfo](https://learn.microsoft.com/pt-br/dotnet/api/system.globalization.cultureinfo): Informações sobre como usar culturas para formatar dados de maneira localizada.



# Arrays

Imagine uma fila de sete anões mineradores, prontos para o trabalho. Essa fila organizada é a nossa analogia para um Array.

Um array é uma estrutura de dados fundamental que armazena uma coleção de elementos. Para entender completamente, vamos observar as três regras de ouro da fila dos anões:

1. Todos são do Mesmo Tipo: Na fila, só há anões. Você não pode colocar um elfo ou um dragão no meio. Em C#, isso significa que um array declarado para `int` só pode conter números inteiros. Um array de `string` só pode conter textos. Essa homogeneidade é uma regra estrita.

2. A Fila Tem Tamanho Fixo: Se a fila foi formada com 7 anões, ela tem 7 posições. Você não pode simplesmente adicionar um oitavo anão ou remover um do meio e esperar que a fila encolha. O tamanho de um array é definido em sua criação e não pode ser alterado. Para isso, usamos outras estruturas como `List<T>`.

3. Posições Começam do Zero (Índice Baseado em Zero): Esta é a regra mais importante! Para chamar um anão, você usa sua posição na fila, que sempre começa em 0. O primeiro anão está na posição `0`, o segundo na posição `1`, e o último anão (o sétimo) está na posição `6`. O endereço do último elemento é sempre `tamanho - 1`.

## Por Dentro da Memória: Por que Arrays são Rápidos?

Quando você cria um array, o computador aloca um bloco contínuo de memória para ele. Pense nisso como reservar um trecho de uma prateleira, onde cada espaço tem exatamente o mesmo tamanho e todos estão um ao lado do outro.

Como todos os elementos são do mesmo tipo (e, portanto, têm o mesmo tamanho em bytes) e estão em sequência, o computador pode calcular a localização exata de qualquer elemento instantaneamente. Ele pega o endereço de memória do início do array e soma `(índice * tamanho_do_elemento)`. É por isso que acessar `meuArray[500]` é tão rápido quanto acessar `meuArray[0]`.

## Declarando e Inicializando Arrays

Existem algumas maneiras de formar a "fila de anões".

### 1. Declarar e Definir o Tamanho (Valores Padrão)

Você pode primeiro declarar que terá uma fila de anões e definir seu tamanho. Cada anão na fila começará com um valor padrão, pois o espaço na memória é alocado e "zerado".

```
// Declare an array of integers that will have 5 positions.
// Each position is initialized with the default value for its type.
int[] numbers = new int[5]; // Creates [0, 0, 0, 0, 0]
```

Valores Padrão Comuns:

* Tipos numéricos (`int`, `double`, `decimal`): `0`

* `bool`: `false`

* `char`: `'\0'` (caractere nulo)

* Tipos de referência (`string`, objetos): `null`

### 2. Declarar e Inicializar com Valores

Você pode formar a fila e já definir quem estará em cada posição, tudo de uma vez.

```
// Declare an array and provide the initial values immediately.
// The size of the array is automatically determined by the number of elements.
string[] dwarves = new string[] { "Dopey", "Grumpy", "Doc", "Happy" };

// A syntax shorter is also common
int[] scores = { 95, 80, 100, 75 };
```

## Acessando e Modificando Elementos

Para falar com um anão ou trocar sua ferramenta, usamos sua posição (índice) entre colchetes `[]`.

```
string[] dwarves = { "Dopey", "Grumpy", "Doc", "Happy" };

// Accessing the dwarf at index 0 (the first one)
string firstDwarf = dwarves[0]; // firstDwarf will be "Dopey"

// Modifying the dwarf at index 1 (the second one)
dwarves[1] = "Sneezy"; // The array is now { "Dopey", "Sneezy", "Doc", "Happy" }
```

Tip:

Alerta de Perigo: `IndexOutOfRangeException`
Se você tentar chamar um anão em uma posição que não existe (por exemplo, `dwarves[4]` em nossa fila de 4 anões), o programa irá parar e gritar um erro em tempo de execução: `IndexOutOfRangeException`. É o erro mais comum ao trabalhar com arrays.

## Percorrendo um Array (Iteração)

Para dar uma ordem a todos os anões na fila, usamos laços de repetição.

### 

O Laço `for` (Controle Total)

O laço `for` é o capataz que anda pela fila, sabendo a posição de cada anão. Ele lhe dá acesso ao índice, o que é útil se você precisar saber a posição do elemento.

```
// We use the Length property to know the size of the line.
for (int i = 0; i < dwarves.Length; i++)
{
    // We use the index 'i' to access each dwarf.
    Console.WriteLine($"The dwarf at position {i} is {dwarves[i]}");
}
```

### 

O Laço `foreach` (Simples e Seguro)

O `foreach` é mais como um anúncio geral. Ele passa por cada anão da fila, um de cada vez, sem que você precise se preocupar com a posição. É mais simples e evita o risco de um `IndexOutOfRangeException`.

```
// The loop iterates through each element in the array automatically.
foreach (string dwarf in dwarves)
{
    Console.WriteLine($"{dwarf} is going to the mine!");
}
```

## Indo Além: Arrays Multidimensionais

E se os anões se organizassem não em uma fila, mas em um pátio, formando um retângulo? Para isso, temos os arrays multidimensionais. O mais comum é o 2D, que se parece com um tabuleiro de xadrez ou uma planilha.

```
// A 2D array, like a 2x3 grid.
int[,] gameBoard = new int[2, 3]; // 2 rows, 3 columns

// You can initialize it directly too
int[,] matrix = 
{
    { 1, 2, 3 },
    { 4, 5, 6 }
};

// To access an element, you need two indices: [row, column]
int element = matrix[1, 2]; // Accesses the element at row 1, column 2, which is 6.
```

## Referências

Para se aprofundar, a documentação oficial da Microsoft é o melhor recurso:

* [Guia de Programação de Arrays (C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/arrays/): O ponto de partida para tudo sobre arrays.

* [Arrays Multidimensionais](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/arrays/multidimensional-arrays): Guia específico para arrays com mais de uma dimensão.

* [Classe System.Array](https://learn.microsoft.com/pt-br/dotnet/api/system.array): Documentação da classe base para todos os arrays, mostrando métodos úteis que você pode usar (como `Sort`, `Reverse`, etc.).



# Propriedades e Métodos Essenciais de Arrays

Imagine que um array é como um trem de carga. Cada vagão do trem pode carregar um contêiner (um elemento do array), e todos os vagões são numerados, começando do zero. As operações que podemos fazer nesse trem nos ajudam a gerenciá-lo de forma eficiente.

Vamos explorar algumas das propriedades e métodos mais comuns que você usará ao trabalhar com arrays, usando nossa analogia do trem.

## 

`Length` (Propriedade)

O `Length` não é um método, mas sim uma propriedade. Pense nele como o relatório do chefe da estação que diz exatamente quantos vagões o seu trem possui. Ele não faz nada, apenas informa um fato sobre o array: seu tamanho total.

```
// Our array is a "train" with 5 "wagons"
int[] numbers = new int[5];

// The Length property tells us the total capacity of our train.
Console.WriteLine($"The train has {numbers.Length} wagons."); // Outputs: The train has 5 wagons.
```

## 

`Clone()` (Método)

O método `Clone()` constrói um trem novo, idêntico ao original. Ele cria um novo array com exatamente o mesmo tamanho e com os mesmos elementos do array original.

No entanto, há um detalhe extremamente importante: `Clone()` cria uma cópia superficial (shallow copy). Para uma explicação detalhada, veja o exemplo no final da seção.

```
// An array of value types (integers)
int[] originalTrain = { 10, 20, 30 };

// Clone the train
int[] clonedTrain = (int[])originalTrain.Clone();

// Change a wagon in the cloned train
clonedTrain[0] = 100;

// The original train remains unchanged because int is a value type
Console.WriteLine($"Original train first wagon: {originalTrain[0]}"); // Outputs: 10
```

## 

`CopyTo()` (Método)

O método `CopyTo()` é como mover a carga de alguns vagões do seu trem para outro trem que já está na estação. Ele não cria um novo array, mas copia elementos do array de origem para um array de destino que já existe.

```
// The source train with 3 wagons
int[] sourceTrain = { 1, 2, 3 };

// The destination train, bigger and initially empty
int[] destinationTrain = new int[5]; // { 0, 0, 0, 0, 0 }

// Copy all wagons from the source train to the destination train,
// starting at the second position (index 1) of the destination.
sourceTrain.CopyTo(destinationTrain, 1);

// Final state of destinationTrain: { 0, 1, 2, 3, 0 }
Console.WriteLine(string.Join(", ", destinationTrain));
```

## 

`IndexOf()` (Método Estático)

Precisa saber em qual vagão está uma carga específica? `Array.IndexOf()` faz isso. Ele percorre o trem e te diz o número do primeiro vagão (o índice) onde a carga foi encontrada. Se a carga não existir no trem, ele retorna `-1`.

```
string[] cargoTrain = { "Apples", "Oranges", "Bananas", "Oranges" };

// Find the wagon number for "Bananas"
int bananaWagon = Array.IndexOf(cargoTrain, "Bananas"); // Returns 2

// "Oranges" appears twice, but IndexOf returns the first one it finds.
int orangeWagon = Array.IndexOf(cargoTrain, "Oranges"); // Returns 1

// "Grapes" are not in the train
int grapeWagon = Array.IndexOf(cargoTrain, "Grapes"); // Returns -1

Console.WriteLine($"Bananas are in wagon: {bananaWagon}");
```

## 

`Sort()` (Método Estático)

Este método organiza os vagões do seu trem. Se a carga for numérica, ele os ordena do menor para o maior. Se for texto, em ordem alfabética. É importante saber que `Array.Sort()` modifica o array original.

```
int[] messyTrain = { 5, 1, 4, 2, 3 };

// Sort the train
Array.Sort(messyTrain);

// The messyTrain is now ordered: { 1, 2, 3, 4, 5 }
Console.WriteLine(string.Join(", ", messyTrain));
```

## 

`Reverse()` (Método Estático)

`Array.Reverse()` inverte a ordem de todos os vagões do trem. O último vira o primeiro, o penúltimo vira o segundo, e assim por diante. Assim como o `Sort`, ele modifica o array original.

```
string[] train = { "First", "Middle", "Last" };

// Reverse the train
Array.Reverse(train);

// The train is now in reversed order: { "Last", "Middle", "First" }
Console.WriteLine(string.Join(", ", train));
```

## 

`Clear()` (Método Estático)

Este método não remove os vagões, mas esvazia seu conteúdo, restaurando-os para o valor padrão (`0` para números, `null` para objetos, `false` para booleanos). Você especifica em qual vagão começar a limpeza e quantos vagões limpar.

```
int[] trainToClean = { 1, 2, 3, 4, 5 };

// Clean 2 wagons, starting from the second wagon (index 1)
Array.Clear(trainToClean, 1, 2);

// The train's cargo is now: { 1, 0, 0, 4, 5 }
Console.WriteLine(string.Join(", ", trainToClean));
```

## 

`Resize()` (Método Estático)

E se você precisar de um trem mais longo ou mais curto? Arrays em C# têm um tamanho fixo, mas `Array.Resize()` nos ajuda a contornar isso.

Atenção: ele não "estica" o array original. Ele cria um novo array com o tamanho desejado, copia os elementos do array antigo para o novo e, em seguida, faz sua variável de array apontar para este novo array.

```
int[] trainToResize = { 1, 2, 3 };

// Resize the train to have 5 wagons
// The 'ref' keyword is necessary here
Array.Resize(ref trainToResize, 5);

// The train now has 5 wagons. The new ones have the default value (0).
// Content: { 1, 2, 3, 0, 0 }
Console.WriteLine($"New train length: {trainToResize.Length}");
Console.WriteLine(string.Join(", ", trainToResize));
```

## Referências

Para aprofundar seus conhecimentos, consulte a documentação oficial da Microsoft, que é a fonte mais confiável de informação.

* [Classe System.Array](https://learn.microsoft.com/pt-br/dotnet/api/system.array): A página principal da classe Array, com uma lista de todas as suas propriedades e métodos.

* [Guia de Programação de Arrays (C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/arrays/): Um guia completo sobre como declarar, inicializar e usar arrays em C#.



# Manipulando Valores em Arrays

Nossa fila de anões (nosso array) não é estática. Uma vez formada, muitas vezes precisamos alterar seus elementos. Podemos precisar trocar a ferramenta de um anão, atualizar o status de todos ou mudar o nome de um deles. Esse processo de alterar os dados dentro de um array é uma das operações mais fundamentais na programação.

Vamos ver as principais maneiras de manipular os valores em um array.

## 1. Alteração Direta por Índice

A forma mais simples e rápida de alterar um valor é quando você sabe exatamente a posição (o índice) do elemento que deseja modificar. É como chamar o anão pelo número de sua posição na fila e lhe dar uma nova ferramenta diretamente.

```
// Our line of dwarves
string[] dwarves = { "Dopey", "Grumpy", "Doc", "Happy" };

// We know that Grumpy is at index 1. Let's change his name.
Console.WriteLine($"Before change: {dwarves[1]}");

dwarves[1] = "Cheerful"; // Direct assignment to the element at index 1

Console.WriteLine($"After change: {dwarves[1]}");

// The array is now: { "Dopey", "Cheerful", "Doc", "Happy" }
```

## 2. Encontrar e Alterar um Valor

Mais comumente, você não saberá a posição exata do elemento, mas saberá seu valor atual. O padrão, nesse caso, é:

1. Percorrer o array para encontrar o elemento.

2. Verificar se o elemento atual é o que você procura.

3. Se for, usar seu índice para alterá-lo.

Para isso, o laço `for` é a ferramenta ideal, pois ele nos dá o índice (`i`) de que precisamos para a modificação.

```
int[] scores = { 50, 88, 42, 95, 70 };

// Task: Find the score 42 and replace it with 60.
for (int i = 0; i < scores.Length; i++)
{
    // Check if the current element is the one we're looking for
    if (scores[i] == 42)
    {
        // Use the index 'i' to modify the value
        scores[i] = 60;
        Console.WriteLine("Found and updated the score.");
        break; // Exit the loop since we found what we were looking for
    }
}

// The array is now: { 50, 88, 60, 95, 70 }
```

## 3. Alterando Múltiplos Valores com um Laço

E se precisarmos aplicar uma mesma mudança a todos os elementos? Por exemplo, dar um bônus de 5 pontos para todos os anões ou converter todos os nomes para letras maiúsculas. Novamente, um laço `for` é a escolha perfeita.

```
int[] scores = { 50, 88, 42, 95, 70 };

// Task: Give a 5-point bonus to every score.
for (int i = 0; i < scores.Length; i++)
{
    scores[i] = scores[i] + 5; // Or using the shorthand: scores[i] += 5;
}

// The array is now: { 55, 93, 47, 100, 75 }
Console.WriteLine(string.Join(", ", scores));
```

## Cuidado: Tipos de Valor vs. Tipos de Referência

Como vimos nos outros tópicos, é crucial lembrar dessa diferença ao manipular dados.

* Tipos de Valor (`int`, `bool`): A alteração com `for` funciona perfeitamente, pois estamos acessando a posição de memória do array diretamente e colocando um novo valor lá.

* Tipos de Referência (Objetos): Ao acessar um elemento de um array de objetos, estamos obtendo uma referência para o objeto. Podemos usar essa referência para alterar as propriedades do objeto.

```
public class Dwarf { public string Name { get; set; } public bool IsHappy { get; set; } }

Dwarf[] dwarves = { 
    new Dwarf { Name = "Grumpy", IsHappy = false },
    new Dwarf { Name = "Doc", IsHappy = false }
};

// Task: Make all dwarves happy.
for (int i = 0; i < dwarves.Length; i++)
{
    // dwarves[i] gives us the reference to the Dwarf object.
    // We use that reference to change a property of that object.
    dwarves[i].IsHappy = true;
}

// Now, if we check the first dwarf...
Console.WriteLine($"Is Grumpy happy? {dwarves[0].IsHappy}"); // Outputs: True
```

## Conclusão

Manipular valores em arrays se resume a duas técnicas principais:

1. Acesso Direto: Use `array[indice] = novoValor;` quando souber a posição.

2. Iteração com `for`: Use um laço `for` para encontrar elementos ou aplicar uma modificação em massa, pois ele fornece o índice necessário para a alteração.

Dominar essas técnicas é essencial para fazer seus programas realizarem tarefas úteis e dinâmicas.

## Referências

Os conceitos neste tópico são uma aplicação prática do que foi visto nos documentos anteriores. É recomendado revisá-los:

* [Introdução Detalhada aos Arrays](arrays.html)

* [Percorrendo Arrays (Iteração)](iteration.html)



# Percorrendo Arrays (Iteração)

## O que é Iteração?

Antes de vermos as ferramentas, vamos entender o conceito. Iteração (do latim iterare, que significa "repetir, fazer de novo") é simplesmente o ato de repetir um processo para cada item de uma coleção, um de cada vez e em sequência.

Usando nossa analogia, a iteração é o próprio ato de o capataz andar pela fila, do primeiro ao último anão, para inspecionar a picareta de cada um. O processo de ir de anão em anão é a iteração. As diferentes maneiras como ele pode fazer isso (usando uma prancheta, um alto-falante, etc.) são os diferentes laços de iteração (`for`, `foreach`, etc.) que usamos no código.

Agora, vamos ver as ferramentas que o C# nos dá para realizar a iteração em arrays.

## 

O Laço `for`: O Capataz com a Prancheta

O laço `for` é como um capataz que anda pela fila dos anões com uma prancheta. Ele é metódico e tem controle total sobre o processo.

Ele controla três coisas:

1. Inicialização (`int i = 0`): Ele começa na posição 0, o primeiro anão.

2. Condição (`i < anoes.Length`): Ele continua enquanto sua posição atual for menor que o tamanho total da fila.

3. Incremento (`i++`): Após falar com um anão, ele passa para o próximo.

O capataz sempre sabe a posição exata (`i`) do anão com quem está falando. Isso é extremamente útil.

Vantagens:

* Você tem acesso ao índice do elemento.

* Você pode modificar o array diretamente.

* Você pode controlar a iteração: pular elementos, ir de trás para frente, etc.

```
string[] dwarves = { "Dopey", "Grumpy", "Doc", "Happy", "Sneezy" };

// The 'for' loop gives us access to the index 'i'
for (int i = 0; i < dwarves.Length; i++)
{
    // We can use the index to get the element and do something with it
    Console.WriteLine($"The dwarf at position {i} is {dwarves[i]}. Give him a pickaxe!");
    
    // We can also modify the array
    if (dwarves[i] == "Grumpy")
    {
        dwarves[i] = "Cheerful"; // Grumpy is now Cheerful
    }
}
```

## 

O Laço `foreach`: O Anúncio Geral

O laço `foreach` é como fazer um anúncio geral pelo alto-falante para todos os anões. Cada anão, um por um, escuta a mensagem e faz o que foi pedido. É mais simples e direto, mas menos pessoal.

Você não sabe a posição exata de cada anão, apenas que todos eles receberão a instrução.

Vantagens:

* Mais simples e legível: Menos código para escrever.

* Mais seguro: É impossível causar um erro de `IndexOutOfRangeException` com um `foreach`.

Limitações:

* Você não tem acesso ao índice do elemento.

* Você não pode modificar o array diretamente (para tipos de valor como `int`, a variável de iteração é uma cópia).

```
int[] numbers = { 10, 20, 30, 40, 50 };

// The 'foreach' loop handles getting each element automatically
foreach (int number in numbers)
{
    // 'number' holds the value of the current element
    Console.WriteLine($"The current number is {number}");
    
    // Trying to change the value like this will NOT change the array itself,
    // because 'number' is a copy of the element, not a reference to it.
    // number = 100; // This line would not affect the 'numbers' array.
}
```

## 

O Laço `while`: O Guarda Manual

O laço `while` é como um guarda que controla a fila manualmente. Ele verifica uma condição e, se for verdadeira, deixa um anão passar e depois decide o que fazer a seguir. Ele é o mais flexível, mas também exige mais cuidado.

Você precisa controlar manualmente o avanço na fila. Se esquecer de incrementar o contador, o guarda ficará preso no mesmo anão para sempre (um laço infinito).

É menos comum para percorrer um array inteiro, mas útil se você precisar parar a iteração com base em uma condição que não seja apenas o tamanho do array.

```
string[] dwarves = { "Dopey", "Grumpy", "Doc", "Happy", "Sneezy" };
int i = 0; // Manual counter

// The loop will continue as long as we haven't reached the end
// AND we haven't found the dwarf named "Doc".
while (i < dwarves.Length && dwarves[i] != "Doc")
{
    Console.WriteLine($"{dwarves[i]} is not Doc. Next!");
    i++; // Manually move to the next position. CRITICAL!
}

if (i < dwarves.Length)
{
    Console.WriteLine($"Found Doc at position {i}!");
}
```

## Qual Laço Usar? A Regra de Bolso

* Precisa do índice? Precisa modificar o array? Precisa de controle total (ir para trás, pular)? * Use o laço `for`.

* Só precisa ler os valores de cada elemento, de forma simples e segura? * Use o laço `foreach`. (Esta é a escolha mais comum para leitura).

* A condição para parar é complexa e não depende apenas de percorrer o array inteiro? * Use o laço `while`.

## Referências

* [O laço for (Guia de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/statements/for)

* [O laço foreach (Guia de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement)

* [O laço while (Guia de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/statements/iteration-statements#the-while-statement)



# O Laço foreach: A Forma Simples de Iterar

Dentro do nosso universo de arrays, que imaginamos como uma fila de anões, o laço `foreach` é a ferramenta mais amigável e direta para se comunicar com eles. Pense nele como um anúncio geral feito por um alto-falante.

O anúncio diz: "Atenção, cada anão, um de cada vez, por favor, pegue uma tocha". Cada anão, em ordem, ouve a instrução e a executa. É simples, eficiente e não há como errar a ordem ou pular um anão.

O `foreach` foi projetado para uma única tarefa: percorrer uma coleção do início ao fim, elemento por elemento, de forma legível e segura.

## Sintaxe e Funcionamento

A estrutura de um `foreach` é quase como uma frase em inglês:

`foreach (Tipo variavel in colecao)`

Vamos quebrar isso:

* `foreach`: A palavra-chave que inicia o laço.

* `Tipo variavel`: Você declara uma variável temporária que, a cada repetição (iteração), irá armazenar o valor do elemento atual. O `Tipo` deve ser compatível com os elementos da coleção.

* `in`: A palavra-chave que conecta a variável à coleção.

* `colecao`: O array (ou outra coleção) que você deseja percorrer.

```
string[] dwarves = { "Dopey", "Grumpy", "Doc", "Happy" };

// For each string, which we will call 'dwarf', in the 'dwarves' array...
foreach (string dwarf in dwarves)
{
    // The 'dwarf' variable holds the current element for this iteration
    Console.WriteLine($"{dwarf} is ready for work!");
}

// Output:
// Dopey is ready for work!
// Grumpy is ready for work!
// Doc is ready for work!
// Happy is ready for work!
```

## Vantagens

1. Legibilidade: A sintaxe é muito clara sobre sua intenção. É mais fácil de ler e entender do que um laço `for` para a simples tarefa de percorrer uma coleção.

2. Segurança: É impossível causar um erro de `IndexOutOfRangeException` com `foreach`, pois você não gerencia o índice manualmente. O laço cuida de começar no primeiro elemento e parar no último, sem erros.

3. Simplicidade: Menos "peças móveis". Você não precisa inicializar um contador, verificar uma condição de parada ou incrementar o contador. Menos código significa menos chance de bugs.

## Limitações e Cuidados Essenciais

A simplicidade do `foreach` vem com algumas regras estritas. Ignorá-las é uma fonte comum de erros.

### 1. Você Não Tem Acesso ao Índice

O `foreach` não sabe (e não te informa) a posição do elemento atual. Se você precisa fazer algo como "Na posição 3, faça isso", o `foreach` não é a ferramenta certa. Você precisará de um laço `for`.

### 2. A Coleção Não Pode Ser Modificada

Você não pode adicionar ou remover elementos de uma coleção enquanto um `foreach` está percorrendo-a. Isso é como tentar adicionar um anão no meio da fila enquanto o capataz está fazendo a contagem. Isso quebraria a lógica da iteração e, por isso, o C# lança uma exceção (`InvalidOperationException`).

```
// This code will COMPILE, but it will CRASH at runtime.
var names = new List<string> { "Ana", "Beto" }; // Using a List to show modification

foreach (string name in names)
{
    if (name == "Ana")
    {
        // DON'T DO THIS! This will throw an InvalidOperationException.
        // names.Remove(name); 
    }
}
```

### 3. A Variável de Iteração é (Praticamente) Somente Leitura

Este é o ponto mais sutil e importante. Você não pode usar o `foreach` para alterar os valores dentro do seu array.

* Para Tipos de Valor (`int`, `bool`, `struct`): A variável de iteração (`dwarf`, no nosso exemplo) é uma cópia do elemento no array. Mudar a cópia não afeta o original. ``` int[] scores = { 10, 20, 30 }; foreach (int score in scores) { // 'score' is a COPY of the element in the array. // This line does NOT change the original array. It only changes the copy. // In fact, this line would cause a compile error because 'score' is read-only. // score = 100; // COMPILE ERROR! } ```

* Para Tipos de Referência (objetos): A situação é um pouco diferente. A variável de iteração ainda é uma cópia, mas é uma cópia da referência (do endereço de memória). Isso significa que: * Você não pode fazer a variável apontar para um objeto totalmente novo. * Você pode usar a referência para acessar o objeto original e modificar suas propriedades. ``` public class Dwarf { public string Name { get; set; } public bool HasPickaxe { get; set; } } Dwarf[] dwarves = { new Dwarf { Name = "Grumpy", HasPickaxe = false } }; foreach (Dwarf dwarf in dwarves) { // We CAN use the reference to modify a property of the object. dwarf.HasPickaxe = true; // This WORKS. The original object in the array is changed. // We CANNOT assign a completely new object to the iteration variable. // dwarf = new Dwarf { Name = "Happy", HasPickaxe = true }; // COMPILE ERROR! } ```

## 

Conclusão: Quando Usar `foreach`?

Use o `foreach` sempre que sua intenção for percorrer todos os elementos de uma coleção para leitura ou para modificar propriedades de objetos de referência. É a sua escolha padrão para iteração simples pela sua legibilidade e segurança.

Se você precisar do índice, ou se precisar alterar os elementos de um array de tipos de valor (`int`, `bool`, etc.), use o laço `for`.

## Referências

* [A declaração foreach (Guia de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement): Documentação oficial da Microsoft com todos os detalhes técnicos.



# Exceções em C#

Imagine que você está cozinhando e seguindo uma receita. A receita é o seu programa, uma sequência de passos bem definida. Um dos passos diz: "adicione uma xícara de leite". Você vai até a geladeira, mas descobre que o leite acabou. O que acontece?

* Sem tratamento de exceções: Você para tudo. A receita não pode continuar. O jantar está arruinado. No mundo do software, isso é um "crash". O programa para de funcionar abruptamente.

* Com tratamento de exceções: A receita, prevendo essa possibilidade, tem uma nota de rodapé: "Se não tiver leite, use creme de leite ou água". Você tem uma alternativa! A receita continua, talvez com um resultado um pouco diferente, mas não falha completamente.

Isso é uma exceção: um problema inesperado que ocorre durante a execução de um programa. O tratamento de exceções é o plano que criamos para lidar com esses imprevistos de forma elegante, sem deixar o programa "quebrar".

Tip:

Uma exceção é um evento imprevisto (mas que pode ser previsto pelo desenvolvedor) que interrompe o fluxo normal de um programa.

## 

O Bloco `try-catch`

A principal ferramenta para tratar exceções em C# é o bloco `try-catch`.

* `try`: Colocamos dentro deste bloco o código que pode lançar uma exceção. É a nossa "tentativa".

* `catch`: Este bloco contém o código que será executado se uma exceção ocorrer dentro do bloco `try`. É o nosso plano B.

```CSHARP
public void ConvertStringToNumber()
{
    var myString = "abc";
    try
    {
        // We try to convert a string that is not a number.
        // This will throw a FormatException.
        int myInt = int.Parse(myString); 
        Console.WriteLine($"Successfully converted: {myInt}");
    }
    catch (FormatException e)
    {
        // The exception occurred! The program jumps here.
        Console.WriteLine("Error: The input string is not a valid number.");
        Console.WriteLine($"Technical details: {e.Message}");
    }
}
```

No exemplo acima, `int.Parse("abc")` não pode ser executado, então o .NET lança uma `FormatException`. Como o código está dentro de um bloco `try`, a execução normal para e o controle é passado para o bloco `catch` correspondente, que imprime uma mensagem de erro amigável.

## 

O Bloco `finally`

E se precisarmos executar um código de "limpeza" independentemente de uma exceção ter ocorrido ou não? Por exemplo, fechar um arquivo ou uma conexão com o banco de dados. Para isso, usamos o bloco `finally`.

O código dentro do `finally` é sempre executado:

* Se o bloco `try` for concluído com sucesso.

* Se uma exceção for lançada e capturada por um `catch`.

```CSHARP
public void ProcessFile(string filePath)
{
    FileStream file = null;
    try
    {
        file = new FileStream(filePath, FileMode.Open);
        // ... process the file ...
    }
    catch (IOException e)
    {
        Console.WriteLine($"An error occurred while processing the file: {e.Message}");
    }
    finally
    {
        // This block is always executed.
        // We ensure the file is closed to release resources.
        if (file != null)
        {
            file.Close();
            Console.WriteLine("File stream closed.");
        }
    }
}
```

### 

Diagrama de Fluxo `try-catch-finally`

```MERMAID
graph TD
    A[Início] --> B{Bloco try};
    B -- Código executa sem erros --> D[Bloco finally];
    B -- Ocorre uma exceção --> C{Bloco catch};
    C -- Exceção é tratada --> D;
    D --> E[Fim];
```

## Tratando Múltiplas Exceções

Um único bloco `try` pode gerar diferentes tipos de exceções. Podemos ter vários blocos `catch` para tratar cada tipo de erro de uma maneira específica.

```CSHARP
public void ConvertStringToNumber(string input)
{
    try
    {
        int result = int.Parse(input);
        Console.WriteLine($"Success! Result: {result}");
    }
    catch (FormatException)
    {
        // Occurs if the string is not a number (e.g., "abc")
        Console.WriteLine("Error: Input is not a valid number format.");
    }
    catch (OverflowException)
    {
        // Occurs if the number is too large or too small for an int
        Console.WriteLine("Error: The number is too large or too small.");
    }
    catch (Exception ex)
    {
        // A generic catch for any other exception.
        // It's good practice to leave it last.
        Console.WriteLine($"An unexpected error occurred: {ex.Message}");
    }
}
```

## 

Lançando Exceções com `throw`

Às vezes, nós mesmos precisamos criar e lançar exceções. Isso é útil quando detectamos uma condição de erro que impede nosso método de funcionar corretamente. Usamos a palavra-chave `throw` para isso.

```CSHARP
public void RegisterUser(string username)
{
    if (string.IsNullOrEmpty(username))
    {
        // The username is invalid, so we cannot continue.
        // We throw an exception to signal the error.
        throw new ArgumentNullException(nameof(username), "Username cannot be null or empty.");
    }

    // ... proceed with user registration ...
    Console.WriteLine($"User '{username}' registered.");
}

// Como usar:
try
{
    RegisterUser(null);
}
catch (ArgumentNullException ex)
{
    Console.WriteLine($"Failed to register user. Reason: {ex.Message}");
}
```

## Boas Práticas

1. Seja Específico: Capture os tipos de exceção mais específicos primeiro (`FormatException`, `IOException`) e os mais genéricos (`Exception`) por último.

2. Não Capture o que Você Não Pode Resolver: Se você não sabe o que fazer com uma exceção, é melhor não capturá-la. Deixe que um nível mais acima na "pilha de chamadas" (call stack) a trate.

3. Não Use Exceções para Controle de Fluxo: Exceções são para erros excepcionais, não para situações normais. Usá-las para controle de fluxo (como um `if/else`) é muito ineficiente.

4. Use `finally` ou `using` para Liberar Recursos: Sempre garanta que recursos como arquivos, conexões de rede ou de banco de dados sejam liberados. O bloco `using` em C# é uma forma mais concisa e segura de fazer isso para objetos que implementam `IDisposable`.



# Tratamento de Exceções

Em programação, mesmo o código mais cuidadosamente escrito pode encontrar problemas inesperados durante a execução. Uma conexão de rede pode cair, um arquivo pode não ser encontrado ou um usuário pode inserir dados em um formato inválido. Esses eventos são chamados de exceções. O C# fornece um mecanismo robusto e estruturado para lidar com esses erros: o tratamento de exceções.

## Analogia: O Chef de Cozinha Cauteloso

Imagine um chef de cozinha preparando um prato sofisticado. A execução da receita é o bloco `try`.

* `try`: O chef tenta executar os passos da receita. Ele sabe que certas coisas podem dar errado: o molho pode queimar, ou ele pode deixar um prato cair.

* `catch`: O chef tem planos de contingência. Se o molho queimar (`catch (SauceBurnedException)`), ele sabe exatamente como começar um novo rapidamente. Se um prato quebrar (`catch (PlateDroppedException)`), ele pega outro. Para qualquer outro desastre inesperado (`catch (Exception)`), seu plano geral é chamar o subchefe para avaliar a situação.

* `finally`: Independentemente de a receita ser um sucesso ou um desastre, a cozinha precisa ser limpa no final do expediente. Esta limpeza é o bloco `finally`, que sempre acontece.

Essa abordagem estruturada garante que um pequeno acidente não arruíne todo o serviço do jantar. Da mesma forma, o tratamento de exceções impede que um erro de execução encerre abruptamente sua aplicação.

## 

A Estrutura `try-catch-finally`

A sintaxe para o tratamento de exceções em C# envolve as palavras-chave `try`, `catch` e `finally`.

```CSHARP
try
{
    // Code that may throw an exception
}
catch (SpecificExceptionType ex)
{
    // Code to handle the specific exception
}
catch (AnotherExceptionType ex)
{
    // Code to handle another type of exception
}
finally
{
    // Code that will always execute, regardless of whether an exception was thrown
}
```

### 

O Bloco `try`

Você deve colocar qualquer código que tenha o potencial de lançar uma exceção dentro de um bloco `try`. Se uma exceção ocorrer em qualquer ponto dentro deste bloco, a execução normal é interrompida e o Common Language Runtime (CLR) procura por um bloco `catch` compatível.

### 

O Bloco `catch`

Um bloco `catch` é onde você lida com o erro. Você pode ter múltiplos blocos `catch` para um único bloco `try`, cada um projetado para lidar com um tipo específico de exceção.

É uma prática recomendada ordenar os blocos `catch` do mais específico para o mais genérico. Por exemplo, capturar `FileNotFoundException` antes de `IOException`, e `IOException` antes de `Exception`. Se o CLR não encontrar um `catch` específico para a exceção lançada, ele procurará por um `catch` que trate uma classe base da exceção.

```CSHARP
public void ReadFile(string filePath)
{
    try
    {
        string content = File.ReadAllText(filePath);
        Console.WriteLine("File content loaded successfully.");
    }
    catch (FileNotFoundException ex)
    {
        // Handle the case where the file does not exist
        Console.WriteLine($"Error: The file was not found at '{filePath}'.");
        Console.WriteLine($"Details: {ex.Message}");
    }
    catch (IOException ex)
    {
        // Handle other I/O errors (e.g., permission issues)
        Console.WriteLine($"An I/O error occurred: {ex.Message}");
    }
    catch (Exception ex)
    {
        // Catch any other unexpected exceptions
        Console.WriteLine($"An unexpected error occurred: {ex.Message}");
        // It's often useful to re-throw if you can't handle it,
        // but only after logging the issue.
        // throw; 
    }
}
```

### 

O Bloco `finally`

O bloco `finally` é opcional, mas extremamente útil. O código dentro dele é sempre executado, não importa o que aconteça no bloco `try` ou `catch`. Ele executará se:

1. Nenhuma exceção ocorrer.

2. Uma exceção ocorrer e for capturada por um `catch`.

3. Uma exceção ocorrer e não for capturada.

Isso o torna o local ideal para liberar recursos não gerenciados, como fechar conexões de banco de dados, fechar streams de arquivos ou liberar handles de sistema.

```CSHARP
public void ProcessData()
{
    DatabaseConnection conn = new DatabaseConnection();
    try
    {
        conn.Open();
        // Perform database operations...
    }
    catch (DatabaseException ex)
    {
        Console.WriteLine($"A database error occurred: {ex.Message}");
    }
    finally
    {
        // Ensure the connection is always closed
        if (conn.IsOpen)
        {
            conn.Close();
        }
    }
}
```

Tip:

A instrução `using` em C# fornece uma sintaxe mais conveniente para o mesmo padrão de `try-finally` para objetos que implementam a interface `IDisposable`.

## 

Lançando Exceções (`throw`)

Você também pode lançar exceções manualmente usando a palavra-chave `throw`. Isso é útil quando você detecta uma condição de erro em sua própria lógica de negócios ou quando deseja relançar uma exceção que capturou.

```CSHARP
public void CreateUser(string username)
{
    if (string.IsNullOrWhiteSpace(username))
    {
        // Throw a new exception because the input is invalid
        throw new ArgumentNullException(nameof(username), "Username cannot be null or empty.");
    }

    // ... logic to create user
}
```

Ao relançar uma exceção dentro de um bloco `catch`, use `throw;` em vez de `throw ex;`. Usar `throw;` preserva o stack trace original da exceção, o que é vital para a depuração, pois mantém o histórico de onde o erro se originou.

```CSHARP
catch (SomeException ex)
{
    // Log the exception
    _logger.LogError(ex, "An error occurred during some operation.");
    
    // Re-throw the original exception, preserving the stack trace
    throw;
}
```

## Referências Oficiais

Para um estudo mais aprofundado e detalhado, consulte a documentação oficial da Microsoft, que é a fonte definitiva sobre o assunto.

* Visão Geral de Exceções e Tratamento de Exceções: [https://learn.microsoft.com/pt-br/dotnet/csharp/fundamentals/exceptions/](https://learn.microsoft.com/pt-br/dotnet/csharp/fundamentals/exceptions/)

* Instruções de Tratamento de Exceções (`try-catch`, `try-finally`, `try-catch-finally`, `throw`): [https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/statements/exception-handling-statements](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/statements/exception-handling-statements)

* Melhores Práticas para Exceções: [https://learn.microsoft.com/pt-br/dotnet/standard/exceptions/best-practices-for-exceptions](https://learn.microsoft.com/pt-br/dotnet/standard/exceptions/best-practices-for-exceptions)



# A Estrutura try-catch

O bloco `try-catch` é o pilar do tratamento de exceções em C#. Ele nos permite isolar um código que pode falhar e definir um plano de ação para quando a falha de fato ocorrer.

O funcionamento é direto:

* `try`: O código que pode potencialmente lançar uma exceção é colocado aqui. O programa tenta executá-lo normalmente.

* `catch`: Se, e somente se, uma exceção ocorrer no bloco `try`, a execução normal é interrompida e o controle pula imediatamente para o bloco `catch`. É o nosso "plano de contingência".

```CSHARP
try 
{
    // Code that might cause an exception is placed here.
    // For example, attempting to divide by zero.
    int numerator = 10;
    int denominator = 0;
    int result = numerator / denominator; // This line will throw a DivideByZeroException.

    // This line will never be reached because the exception occurs before it.
    Console.WriteLine("Calculation successful!");
} 
catch 
{
    // If the code in the try block fails, this code is executed.
    Console.WriteLine("An error occurred during the calculation.");
}
```

## Capturando Detalhes da Exceção

Na maioria das vezes, apenas saber que um erro ocorreu não é suficiente. Precisamos de detalhes: o que deu errado? Onde?

Para isso, podemos capturar a exceção em um objeto dentro do bloco `catch`. Esse objeto, geralmente chamado de `ex` por convenção, contém informações valiosas para depuração.

As propriedades mais usadas são:

* `ex.Message`: Uma string que descreve o erro.

* `ex.StackTrace`: Um "rastro" de texto que mostra exatamente em qual método o erro ocorreu e a sequência de chamadas que levou até ele.

```CSHARP
try 
{
    int numerator = 10;
    int denominator = 0;
    int result = numerator / denominator;
} 
catch (Exception ex)  
{
    // We catch the Exception object to get more details.
    Console.WriteLine("An exception was caught!");
    Console.WriteLine($"Error Message: {ex.Message}");

    // The StackTrace is very useful for debugging but can be long.
    // Console.WriteLine($"Stack Trace: {ex.StackTrace}");
}
```

Tip:

Ao executar o código acima, a propriedade `ex.Message` conteria um texto como "Attempted to divide by zero.".

## Nota Importante sobre o Escopo

Warning:

Use blocos `try-catch` de forma cirúrgica, apenas ao redor do código que você suspeita que pode gerar uma exceção e que você sabe como tratar. Evite envolver métodos inteiros ou grandes partes do seu programa em um único `try-catch`. Fazer isso pode esconder bugs e tornar o código mais difícil de depurar e manter.



# Lançando Exceções (Throwing Exceptions)

Lançar uma exceção é o ato de sinalizar, de forma programática, que uma condição de erro ou um estado inesperado ocorreu e que o método ou bloco de código atual não tem a capacidade de resolvê-lo. Ao lançar uma exceção, o fluxo normal de execução do programa é interrompido, e o runtime do .NET começa a procurar por um tratador de exceções compatível (um bloco `catch`) na pilha de chamadas.

## Analogia: A Linha de Montagem

Pense em uma linha de montagem em uma fábrica. Cada operário (método) tem uma tarefa específica. Se um operário encontra um defeito que ele não pode consertar (por exemplo, uma peça faltando que deveria ter vindo da estação anterior), ele não ignora o problema nem tenta continuar. Ele imediatamente puxa uma alavanca de emergência (`throw`).

Essa ação para a linha de montagem e aciona um alarme. Um supervisor (o bloco `catch`) é então notificado. A notificação pode incluir detalhes sobre qual foi o problema e onde ele ocorreu. O supervisor pode então decidir o que fazer: descartar o produto, registrar o incidente ou tentar consertar o problema. Se o supervisor local não souber o que fazer, ele pode escalar o problema para um gerente de nível superior (relançar a exceção).

## 

A Instrução `throw`

A sintaxe para lançar uma exceção é direta. Você usa a palavra-chave `throw` seguida por uma nova instância de um objeto de exceção.

```CSHARP
// The expression after 'throw' must be an object derived from System.Exception
throw new ArgumentNullException(nameof(userName));
```

Quando esta linha é executada, o programa para o que está fazendo e começa a "desenrolar" a pilha de chamadas, procurando por um `catch` que possa lidar com uma `ArgumentNullException`.

### Quando Lançar uma Exceção?

Você deve lançar uma exceção quando um método não pode cumprir seu contrato ou propósito declarado.

* Argumentos inválidos: Um método recebe um argumento que o impede de funcionar. Use `ArgumentException` ou seus derivados (`ArgumentNullException`, `ArgumentOutOfRangeException`). ```CSHARP public void SetAge(int age) { if (age < 0) { throw new ArgumentOutOfRangeException(nameof(age), "Age cannot be negative."); } this.Age = age; } ```

* Estado de objeto inválido: Uma operação é chamada em um objeto, mas o estado atual do objeto não permite essa operação. Use `InvalidOperationException`. ```CSHARP public void SendEmail() { if (!this.IsConnected) { throw new InvalidOperationException("Cannot send email. No SMTP connection established."); } // ... sending logic } ```

## 

Relançando Exceções: `throw` vs. `throw ex`

Esta é uma das distinções mais importantes e que frequentemente causa bugs difíceis de rastrear. Às vezes, dentro de um bloco `catch`, você pode querer executar alguma ação (como registrar o erro) e depois deixar que a exceção continue sua jornada pela pilha de chamadas. Isso é chamado de relançar a exceção.

* `throw;`: A forma correta. Esta sintaxe relança a exceção original, preservando o stack trace original. O stack trace é o "mapa" que mostra a sequência exata de chamadas de método que levaram ao erro. Preservá-lo é vital para a depuração.

* `throw ex;`: A forma incorreta. Esta sintaxe lança a exceção como se ela estivesse se originando na linha atual. Isso destrói o stack trace original, fazendo parecer que o erro começou no bloco `catch`, escondendo a verdadeira causa raiz do problema.

### Exemplo Prático

```CSHARP
public void ProcessData()
{
    try
    {
        // Call a method that might fail
        ConnectToDatabase("invalid_connection_string");
    }
    catch (SqlException ex)
    {
        // We log the error for later analysis
        Console.WriteLine("LOG: Failed to connect to the database.");

        // CORRECT way: The exception continues with its origin intact.
        // The next 'catch' will know the error came from 'ConnectToDatabase'.
        throw;

        // INCORRECT way: If we used 'throw ex;', the stack trace would be reset.
        // The next 'catch' would think the error originated here, in 'ProcessData'.
        // throw ex; // NEVER DO THIS!
    }
}
```

## Práticas Recomendadas

1. Não use exceções para controle de fluxo normal: Exceções são para condições excepcionais. Para cenários esperados, como um usuário digitando um texto em vez de um número, use métodos como `int.TryParse`.

2. Lance a exceção mais específica possível: Em vez de `throw new Exception("O argumento é nulo")`, prefira `throw new ArgumentNullException("nomeDoArgumento")`. Isso permite que os blocos `catch` sejam mais seletivos.

3. Documente as exceções que seu método lança: Use a tag `<exception>` nos comentários XML para informar aos outros desenvolvedores quais exceções eles devem esperar.

```CSHARP
/// <summary>
/// Calculates the factorial of a number.
/// </summary>
/// <param name="number">The number to calculate the factorial of.</param>
/// <returns>The factorial value.</returns>
/// <exception cref="ArgumentOutOfRangeException">Thrown if the number is negative.</exception>
public static long Factorial(int number)
{
    if (number < 0)
    {
        throw new ArgumentOutOfRangeException(nameof(number), "Factorial is not defined for negative numbers.");
    }
    // ... logic
}
```

## Referências Oficiais da Microsoft

* [Instrução throw (Referência de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/throw)

* [Práticas recomendadas para exceções](https://learn.microsoft.com/pt-br/dotnet/standard/exceptions/best-practices-for-exceptions)



# Exceções Personalizadas (Custom Exceptions)

No desenvolvimento de software, prever e gerenciar erros é tão crucial quanto escrever o código para o "caminho feliz". O .NET oferece uma vasta hierarquia de classes de exceção para erros comuns, como `FileNotFoundException` ou `ArgumentNullException`. No entanto, há momentos em que essas exceções genéricas não são suficientes para descrever um problema específico do domínio da sua aplicação. É aqui que entram as exceções personalizadas.

## Analogia: O Painel do Carro

Pense nas exceções do sistema como as luzes de advertência genéricas em um carro. Uma luz de "Verificar Motor" (`System.Exception`) informa que algo está errado, mas não diz o quê. Pode ser um problema no motor, na transmissão ou no sistema de emissões. É um sinal útil, mas vago.

Uma exceção personalizada, por outro lado, é como uma luz de advertência específica: "Pressão Baixa no Pneu" ou "Nível de Óleo Baixo". Ela não apenas informa que há um problema, mas também qual é o problema, permitindo que o motorista (ou o desenvolvedor) tome a ação correta e imediata. Melhor ainda, uma exceção personalizada pode carregar dados extras, como qual pneu está com a pressão baixa ou qual era o nível do óleo.

## Por Que Criar Exceções Personalizadas?

1. Clareza e Semântica: Capturar uma `InsufficientBalanceException` é muito mais legível e explícito do que capturar uma `InvalidOperationException` e ter que inspecionar a mensagem de texto para entender o contexto. Isso torna o código de tratamento de erros mais limpo e auto-documentado.

2. Adicionar Contexto ao Erro: Exceções personalizadas podem ter propriedades e métodos próprios. Isso permite anexar informações valiosas sobre o estado do sistema no momento em que o erro ocorreu. Por exemplo, em uma `InsufficientBalanceException`, você pode incluir o saldo atual e o valor da tentativa de saque.

3. Controle Granular do Fluxo: Com exceções específicas, você pode criar blocos `catch` distintos para lidar com diferentes cenários de erro de maneiras diferentes. Um erro de "Usuário Não Encontrado" pode ser tratado de uma forma, enquanto um erro de "Conexão com o Banco de Dados Falhou" pode exigir uma lógica de nova tentativa.

## Como Implementar uma Exceção Personalizada

A criação de uma exceção personalizada segue um padrão bem definido. A regra fundamental é herdar da classe `System.Exception` (ou de outra exceção mais específica, se fizer sentido).

### Melhores Práticas de Implementação

* Nome: O nome da classe deve terminar com o sufixo `Exception`.

* Herança: Herde diretamente de `System.Exception`.

* Construtores: Forneça os três construtores mais comuns para garantir que sua exceção se comporte como as exceções padrão do .NET.

* Serialização: Marque a exceção com o atributo `[Serializable]` para permitir que ela seja transportada através de limites de domínio de aplicação (embora menos crítico em muitas arquiteturas modernas, ainda é uma boa prática).

### 

Exemplo Detalhado: `InsufficientBalanceException`

Vamos criar uma exceção para um sistema bancário.

```CSHARP
using System;
using System.Runtime.Serialization;

[Serializable]
public class InsufficientBalanceException : Exception
{
    public decimal CurrentBalance { get; }
    public decimal WithdrawalAmount { get; }

    // 1. Default constructor
    public InsufficientBalanceException()
        : base("Insufficient balance to perform the operation.") { }

    // 2. Constructor that accepts a custom message
    public InsufficientBalanceException(string message)
        : base(message) { }

    // 3. Constructor that wraps an inner exception
    public InsufficientBalanceException(string message, Exception innerException)
        : base(message, innerException) { }

    // 4. Rich constructor with specific error data
    public InsufficientBalanceException(decimal currentBalance, decimal withdrawalAmount)
        : base($"Attempted to withdraw {withdrawalAmount:C} when the balance was only {currentBalance:C}.")
    {
        CurrentBalance = currentBalance;
        WithdrawalAmount = withdrawalAmount;
    }

    // Constructor for deserialization
    protected InsufficientBalanceException(SerializationInfo info, StreamingContext context)
        : base(info, context)
    {
    }
}
```

## Lançando e Capturando a Exceção

Uma vez definida, você pode lançá-la (`throw`) em seu código quando a condição de erro específica for atendida e capturá-la (`catch`) em um bloco de tratamento de erros.

```CSHARP
public class BankAccount
{
    public decimal Balance { get; private set; }

    public BankAccount(decimal initialBalance)
    {
        Balance = initialBalance;
    }

    public void Withdraw(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(amount), "The withdrawal amount must be positive.");
        }

        if (amount > Balance)
        {
            // Throwing our custom exception with context!
            throw new InsufficientBalanceException(Balance, amount);
        }

        Balance -= amount;
        Console.WriteLine($"Withdrawal of {amount:C} successful. New balance: {Balance:C}");
    }
}

public class ATM
{
    public static void Main()
    {
        var account = new BankAccount(100.00m);

        try
        {
            Console.WriteLine("Attempting to withdraw 50.00...");
            account.Withdraw(50.00m); // Success

            Console.WriteLine("\nAttempting to withdraw 80.00...");
            account.Withdraw(80.00m); // Failure
        }
        catch (InsufficientBalanceException ex)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine("\n--- Operation Failed ---");
            Console.WriteLine($"Error Detail: {ex.Message}");
            Console.WriteLine($"Recommended Action: Try a smaller amount, up to {ex.CurrentBalance:C}.");
            Console.ResetColor();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An unexpected error occurred: {ex.GetType().Name} - {ex.Message}");
        }
    }
}
```

### Saída do Console:

```
Attempting to withdraw 50.00...
Withdrawal of $50.00 successful. New balance: $50.00

Attempting to withdraw 80.00...

--- Operation Failed ---
Error Detail: Attempted to withdraw $80.00 when the balance was only $50.00.
Recommended Action: Try a smaller amount, up to $50.00.
```

## Referências Oficiais da Microsoft

Para um aprofundamento no tópico e para seguir as diretrizes oficiais, consulte a documentação da Microsoft:

* [Criando e lançando exceções](https://learn.microsoft.com/pt-br/dotnet/standard/exceptions/creating-and-throwing-exceptions)

* [Práticas recomendadas para exceções](https://learn.microsoft.com/pt-br/dotnet/standard/exceptions/best-practices-for-exceptions)



# Katas

Start typing here...



# Kata - Editor de Texto Simples de Console

Neste kata, construiremos uma aplicação de console fundamental: um editor de texto simples. Este projeto nos permitirá explorar a manipulação de arquivos em C#, uma habilidade essencial para qualquer desenvolvedor. A aplicação será capaz de criar, salvar e abrir arquivos de texto diretamente do terminal.

Vamos focar em conceitos como entrada e saída do console, leitura e escrita de arquivos com `StreamReader` and `StreamWriter`, e a importância do bloco `using` para gerenciar recursos de forma segura.

## O Código Completo

Este é o código do nosso `Program.cs`. Ele estrutura o editor de texto em um menu interativo.

```
using System;
using System.IO;

namespace TextEditor
{
  public class Program
  {
    public static void Main(string[] args)
    {
      Menu();
    }

    static void Menu()
    {
      Console.Clear();
      Console.WriteLine("O que voce deseja fazer?");
      Console.WriteLine("1 - Abrir arquivo");
      Console.WriteLine("2 - Criar novo arquivo");
      Console.WriteLine("0 - Sair");
      short option = short.Parse(Console.ReadLine());

      switch (option)
      {
        case 0:
          System.Environment.Exit(0);
          break;
        case 1:
          Open();
          break;
        case 2:
          Edit();
          break;
        default:
          Menu();
          break;
      }
    }

    private static void Open()
    {
      Console.Clear();
      Console.WriteLine("Qual caminho do arquivo?");
      string path = Console.ReadLine();

      using (var file = new StreamReader(path))
      {
        string text = file.ReadToEnd();
        Console.WriteLine(text);
      }
      
      Console.WriteLine("");
      Console.ReadLine();
      Menu();
    }

    private static void Edit()
    {
      Console.Clear();
      Console.WriteLine("Digite seu texto abaixo (ESC para sair)");
      Console.WriteLine("--------------------------------");

      string text = "";

      do
      {
        text += Console.ReadLine();
        text += Environment.NewLine;
      } while (Console.ReadKey().Key != ConsoleKey.Escape);
      
      Save(text);
    }
    
    static void Save(string text) 
    {
      Console.Clear();
      Console.WriteLine("Qual caminho para salvar o arquivo? \n");
      var path = Console.ReadLine();
      
      
      // CRIA E JÁ FECHA O OBJETO - É BOM PARA HANDLER COM ARQUIVOS
      using (var file = new StreamWriter(path ?? string.Empty))
      {
        file.Write(text);
      }

      Console.WriteLine($"Arquivo salvo em {path} com sucesso!");
      Console.ReadLine(); 
      Menu();
    }
  }
}
```

## Análise do Código

### 

`Main` e `Menu`: Navegação Central

O ponto de entrada `Main` simplesmente chama o método `Menu`, que atua como o coração da nossa aplicação.

* `Console.Clear()`: Limpa a tela do console para uma apresentação mais limpa.

* Loop de Menu: O `Menu` exibe as opções, lê a entrada do usuário com `Console.ReadLine()` e usa uma instrução `switch` para direcionar o fluxo do programa. Note que, após cada ação (`Open`, `Edit`), o `Menu` é chamado novamente, criando um loop que mantém a aplicação em execução até que o usuário escolha sair.

* Saída Segura: `System.Environment.Exit(0)` é usado para encerrar a aplicação de forma limpa quando o usuário digita '0'.

### 

`Open`: Lendo Arquivos

```
private static void Open()
{
    // ...
    string path = Console.ReadLine();

    using (var file = new StreamReader(path))
    {
        string text = file.ReadToEnd();
        Console.WriteLine(text);
    }
    // ...
}
```

Esta função é responsável por abrir e exibir o conteúdo de um arquivo de texto.

* `StreamReader`: Esta classe do `System.IO` é projetada para ler caracteres de um fluxo (neste caso, um arquivo).

* Bloco `using`: Este é um dos conceitos mais importantes aqui. O `using` garante que o objeto `file` (que representa o arquivo no sistema operacional) seja "descartado" (`Dispose`) corretamente, mesmo que ocorram erros. Isso significa que o arquivo será fechado, liberando o recurso para outros programas. É a maneira padrão e segura de trabalhar com recursos como arquivos e conexões de rede.

* `ReadToEnd()`: Lê todo o conteúdo do arquivo, do início ao fim, e o retorna como uma única `string`.

### 

`Edit` e `Save`: Criando e Escrevendo em Arquivos

O processo de criação é dividido em duas partes: `Edit` para capturar a entrada e `Save` para escrevê-la no disco.

```
private static void Edit()
{
    // ...
    string text = "";
    do
    {
        text += Console.ReadLine();
        text += Environment.NewLine;
    } while (Console.ReadKey().Key != ConsoleKey.Escape);
    
    Save(text);
}
```

* Captura de Múltiplas Linhas: O loop `do-while` é uma forma inteligente de capturar texto. Ele continua adicionando linhas à variável `text` até que a tecla `ESC` seja pressionada. `Console.ReadKey()` intercepta a próxima tecla pressionada sem exigir que o usuário pressione Enter.

* `Environment.NewLine`: Garante que as quebras de linha sejam corretas para o sistema operacional em que o programa está sendo executado (seja `\n` no Linux/macOS ou `\r\n` no Windows).

```
static void Save(string text) 
{
    // ...
    var path = Console.ReadLine();
    
    using (var file = new StreamWriter(path ?? string.Empty))
    {
        file.Write(text);
    }
    // ...
}
```

* `StreamWriter`: O oposto do `StreamReader`, esta classe é usada para escrever strings em um fluxo/arquivo. Se o arquivo não existir no `path` especificado, ele será criado. Se já existir, seu conteúdo será sobrescrito.

* Segurança com `using`: Assim como no `Open`, o `using` garante que o arquivo seja fechado e salvo corretamente após a escrita.

## Conceitos-Chave Aplicados

* Entrada e Saída do Console: Uso intensivo de `Console.WriteLine`, `Console.ReadLine` e `Console.ReadKey` para criar uma interface de usuário interativa.

* Manipulação de Arquivos (`System.IO`): Utilização das classes `StreamReader` e `StreamWriter` para operações de leitura e escrita em arquivos.

* Gerenciamento de Recursos com `using`: Aplicação da instrução `using` para garantir que os recursos do sistema (arquivos) sejam liberados de forma segura e automática.

* Estruturas de Controle: Uso de `switch` para navegação no menu e `do-while` para captura de entrada de texto.

* Tratamento de Strings: Concatenação de strings para construir o conteúdo do arquivo e uso de `Environment.NewLine` para compatibilidade entre sistemas operacionais.

## Como Executar

Para testar este programa, você precisa navegar até a pasta do projeto no seu terminal e usar o comando `dotnet run`:

```BASH
# Navegue até o diretório do projeto
cd projects/TextEditor/TextEditor

# Execute a aplicação
dotnet run
```

A partir daí, o menu interativo irá guiá-lo para criar, abrir ou salvar seus arquivos de texto.



# Kata - Conversor de Tipos via Linha de Comando

Neste kata, vamos explorar um caso de uso um pouco mais avançado: a criação de uma ferramenta de linha de comando (CLI) em C#. Esta aplicação irá converter um valor de um tipo de dado para outro, com base nos argumentos fornecidos pelo usuário ao executar o programa.

Vamos abordar conceitos como manipulação de argumentos de linha de comando, dicionários para armazenar parâmetros, tratamento de erros robusto com `try-catch` e a diferença crucial entre `Parse` e `Convert`.

## O Código Completo

Este é o código do nosso `Program.cs`. Ele é projetado para ser executado via `dotnet run` com parâmetros específicos.

```
using System;
using System.Collections.Generic;

namespace AtividadeSemana1
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                ShowHelp();
                return;
            }

            var parameters = ParseArguments(args);

            if (!ValidateParameters(parameters))
            {
                Console.WriteLine("Erro: Parametros 'valor', 'tipoEntrada' e 'tipoSaida' sao obrigatorios.");
                Console.WriteLine("Uso: dotnet run valor=<valor> tipoEntrada=<tipo> tipoSaida=<tipo>");
                return;
            }

            string valorStr = parameters["valor"];
            string tipoEntrada = parameters["tipoentrada"].ToLower();
            string tipoSaida = parameters["tiposaida"].ToLower();

            try
            {
                object valorEntrada = ParseInputValue(valorStr, tipoEntrada);
                object valorSaida = ConvertValue(valorEntrada, tipoSaida, valorStr);
                PrintResult(valorStr, tipoEntrada, valorSaida, tipoSaida);
            }
            catch (ArgumentException ex)
            {
                Console.WriteLine($"Erro: {ex.Message}");
            }
            catch (InvalidCastException ex)
            {
                Console.WriteLine($"Erro de conversao: {ex.Message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ocorreu um erro inesperado: {ex.Message}");
            }
        }

        static void ShowHelp()
        {
            Console.WriteLine("=== Conversor de Tipos ===");
            Console.WriteLine("Por favor, forneca os parametros no formato chave=valor.");
            Console.WriteLine("Uso: dotnet run valor=<valor> tipoEntrada=<tipo> tipoSaida=<tipo>");
            Console.WriteLine("Exemplo: dotnet run valor=123.45 tipoEntrada=double tipoSaida=int");
            Console.WriteLine("Tipos suportados: int, double, float, bool, string, short");
        }

        static Dictionary<string, string> ParseArguments(string[] args)
        {
            var parameters = new Dictionary<string, string>();
            foreach (var arg in args)
            {
                var parts = arg.Split('=', 2);
                if (parts.Length == 2)
                {
                    parameters[parts[0].ToLower()] = parts[1];
                }
            }
            return parameters;
        }

        static bool ValidateParameters(Dictionary<string, string> parameters)
        {
            return parameters.ContainsKey("valor") &&
                   parameters.ContainsKey("tipoentrada") &&
                   parameters.ContainsKey("tiposaida");
        }

        
        static object ParseInputValue(string valorStr, string tipoEntrada)
        {
            try
            {
                return tipoEntrada switch
                {
                    "int" => int.Parse(valorStr),
                    "double" => double.Parse(valorStr),
                    "float" => float.Parse(valorStr),
                    "bool" => bool.Parse(valorStr),
                    "string" => valorStr,
                    "short" => short.Parse(valorStr),
                    _ => throw new ArgumentException($"Tipo de entrada desconhecido: {tipoEntrada}")
                };
            }
            catch (Exception ex)
            {
                throw new ArgumentException($"Ao processar o valor de entrada '{valorStr}': {ex.Message}", ex);
            }
        }

        static object ConvertValue(object valorEntrada, string tipoSaida, string valorStr)
        {
            try
            {
                return tipoSaida switch
                {
                    "int" => Convert.ToInt32(valorEntrada),
                    "double" => Convert.ToDouble(valorEntrada),
                    "float" => Convert.ToSingle(valorEntrada),
                    "bool" => Convert.ToBoolean(valorEntrada),
                    "string" => Convert.ToString(valorEntrada),
                    "short" => Convert.ToInt16(valorEntrada),
                    _ => throw new ArgumentException($"Tipo de saida desconhecido: {tipoSaida}")
                };
            }
            catch (Exception ex)
            {
                throw new InvalidCastException($"Nao foi possivel converter '{valorStr}' ({valorEntrada.GetType().Name}) para {tipoSaida}: {ex.Message}", ex);
            }
        }

        static void PrintResult(string valorStr, string tipoEntrada, object valorSaida, string tipoSaida)
        {
            Console.WriteLine("=== Resultado da Conversao ===" elytra.platform.documentation.core.content.format.MarkdownFile@527144b2);
            Console.WriteLine($"Entrada: [{valorStr}] ({tipoEntrada})");
            Console.WriteLine($"Saida:   [{valorSaida}] ({tipoSaida})");
        }
    }
}
```

## Análise do Código

### 

`Main`: O Ponto de Entrada e Orquestrador

O método `Main` agora tem mais responsabilidades:

1. Verificar Argumentos: `if (args.Length == 0)` checa se o programa foi executado sem nenhum argumento. Se for o caso, exibe uma mensagem de ajuda (`ShowHelp()`) e encerra.

2. Analisar Argumentos: `ParseArguments(args)` é chamado para processar os argumentos da linha de comando.

3. Validar Parâmetros: `ValidateParameters(parameters)` garante que todos os parâmetros necessários (`valor`, `tipoEntrada`, `tipoSaida`) foram fornecidos.

4. Executar a Conversão: O bloco `try-catch` é o núcleo da lógica. Ele tenta analisar o valor de entrada, convertê-lo para o tipo de saída e imprimir o resultado. Se qualquer etapa falhar, uma exceção é capturada e uma mensagem de erro é exibida.

### 

`ParseArguments`: Processando a Entrada do Usuário

```
static Dictionary<string, string> ParseArguments(string[] args)
{
    var parameters = new Dictionary<string, string>();
    foreach (var arg in args)
    {
        var parts = arg.Split('=', 2);
        if (parts.Length == 2)
        {
            parameters[parts[0].ToLower()] = parts[1];
        }
    }
    return parameters;
}
```

Esta função transforma um array de strings como `["valor=123", "tipoEntrada=int"]` em um `Dictionary<string, string>`. Um dicionário é uma coleção de pares chave-valor.

* `arg.Split('=', 2)`: Divide cada argumento no caractere `=`, no máximo em 2 partes. Isso garante que, se o valor contiver um `=`, ele não será dividido novamente (ex: `valor=chave=valor`).

* `parameters[parts[0].ToLower()] = parts[1]`: Adiciona a chave (em minúsculas) e o valor ao dicionário.

### 

`ParseInputValue` vs. `ConvertValue`

O programa usa duas funções distintas para a conversão, e a diferença é fundamental:

1. `ParseInputValue`: Usa métodos como `int.Parse(string)`. O objetivo do `Parse` é converter uma representação em string de um valor para o seu tipo de dado correspondente. Ele só funciona de `string` para outro tipo.

2. `ConvertValue`: Usa a classe `Convert`, com métodos como `Convert.ToInt32(object)`. A classe `Convert` é mais flexível. Ela pode converter um valor de qualquer tipo base para outro tipo, desde que uma conversão válida exista. Por exemplo, pode converter um `double` para um `int`, um `bool` para uma `string`, etc.

Em nosso fluxo, primeiro usamos `Parse` para tirar o valor da `string` inicial e, em seguida, usamos `Convert` para realizar a conversão entre os tipos de dados reais (ex: de `double` para `int`).

Ambas as funções usam uma expressão `switch` (uma forma mais concisa do `switch` tradicional) para selecionar a operação correta com base no tipo de entrada/saída.

### 

Tratamento de Erros (`try-catch`)

Este programa é muito mais robusto que a calculadora porque ele antecipa falhas.

* `try { ... }`: O código que pode gerar um erro é colocado dentro do bloco `try`.

* `catch (ArgumentException ex)`: Captura erros relacionados a argumentos inválidos, como um tipo de entrada/saída desconhecido.

* `catch (InvalidCastException ex)`: Captura erros que ocorrem quando a conversão entre dois tipos não é possível (por exemplo, converter a string `"abc"` para `int`).

* `catch (Exception ex)`: Uma cláusula genérica que captura qualquer outro erro inesperado, evitando que o programa "quebre" abruptamente.

## Conceitos-Chave Aplicados

* Argumentos de Linha de Comando: Leitura e processamento de `string[] args` no método `Main`.

* Dicionários (`Dictionary<TKey, TValue>`): Uma estrutura de dados poderosa para armazenar e acessar dados por meio de uma chave única.

* Tratamento de Exceções: Uso de `try-catch` para criar um programa resiliente que lida com entradas inválidas e erros de conversão.

* Expressões `switch`: Uma sintaxe moderna e concisa para controle de fluxo.

* Diferença entre `Parse` e `Convert`: Compreensão de duas maneiras fundamentais de realizar conversões de tipo em C#.

## Como Executar

Para testar este programa, você o executaria a partir do seu terminal, na pasta do projeto, da seguinte forma:

```BASH
# Exemplo 1: Convertendo um double para um int
dotnet run valor=123.45 tipoEntrada=double tipoSaida=int

# Exemplo 2: Convertendo uma string para um booleano
dotnet run valor=true tipoEntrada=string tipoSaida=bool

# Exemplo de erro
dotnet run valor=texto tipoEntrada=string tipoSaida=int
```

Este kata demonstra como construir aplicações de console interativas e robustas, um pilar fundamental da programação em muitas linguagens, incluindo C#.



# Kata - Calculadora em C#

Bem-vindo ao nosso primeiro kata prático! Neste exercício, vamos construir uma calculadora simples usando C#. O objetivo é aplicar os conceitos fundamentais que aprendemos, como variáveis, tipos de dados, operadores, condicionais e funções, em um projeto real e funcional.

Este tutorial é voltado para iniciantes e explicará cada parte do código detalhadamente.

## O Código Completo

Aqui está o código completo do nosso arquivo `Program.cs`. Vamos analisá-lo passo a passo.

```
using System;

namespace Calculator
{
  class Program
  {
    static void Main(string[] args)
    {
      Menu();
    }

    static void Menu()
    {
      Console.Clear();
      
      Console.WriteLine("O QUE DESEJA FAZER?");
      Console.WriteLine("---------------------");
      Console.WriteLine("1 - Soma");
      Console.WriteLine("2 - Subtração");
      Console.WriteLine("3 - Divisão");
      Console.WriteLine("4 - Multiplicação");
      Console.WriteLine("5 - Sair");

      Console.WriteLine("---------=-=-=-=-=--");
      Console.WriteLine("SELECIONE UMA OPÇÃO > ");
      short res = short.Parse(Console.ReadLine());
      
      switch(res)
      {
        case 1:
          Sum(); break;
        case 2:
          Subtraction(); break;
        case 3:
          Division(); break;
        case 4:
          Multiplication(); break;
        case 5:
          System.Environment.Exit(0);
          break;
        default:
          Menu();
          break;
      }
    }

    static void Sum()
    {
      Console.Clear();

      Console.WriteLine("First value: ");
      double v1 = double.Parse(Console.ReadLine());

      Console.WriteLine("Second value: ");
      double v2 = double.Parse(Console.ReadLine());

      double result = v1 + v2;

      Console.Clear();

      Console.WriteLine(" ========= Result ========");
      Console.WriteLine($" {v1} + {v2}  =  {result}");
      Console.ReadKey();
      Menu();
    }

    static void Subtraction()
    {
      Console.Clear();

      Console.WriteLine("First value: ");
      double v1 = double.Parse(Console.ReadLine());

      Console.WriteLine("Second value: ");
      double v2 = double.Parse(Console.ReadLine());

      double result = v1 - v2;

      Console.Clear();
      Console.WriteLine(" ========= Result ========");
      Console.WriteLine($" {v1} - {v2}  =  {result}");
      Console.ReadKey();
      Menu();
    }

    static void Division()
    {
      Console.Clear();

      Console.WriteLine("First value: ");
      double v1 = double.Parse(Console.ReadLine());

      Console.WriteLine("Second value: ");
      double v2 = double.Parse(Console.ReadLine());

      double result = v1 / v2;

      Console.Clear();
      Console.WriteLine(" ========= Result ========");
      Console.WriteLine($" {v1} / {v2}  =  {result}");
      Console.ReadKey();
      Menu();
    }

    static void Multiplication()
    {
      Console.Clear();
      Console.WriteLine("First value: ");
      double v1 = double.Parse(Console.ReadLine());

      Console.WriteLine("Second value: ");
      double v2 = double.Parse(Console.ReadLine());

      double result = v1 * v2;

      Console.Clear();
      Console.WriteLine(" ========= Result ========");
      Console.WriteLine($" {v1} x {v2}  =  {result}");
      Console.ReadKey();
      Menu();
    }
  }
}
```

## Análise do Código

### Estrutura Básica

* `using System;`: Esta linha importa o namespace `System`, que contém classes fundamentais e tipos de dados que usamos em quase todos os programas C#, como `Console`, `String`, `Double`, etc.

* `namespace Calculator`: Um `namespace` é usado para organizar o código e evitar conflitos de nomes. Aqui, estamos criando um namespace chamado `Calculator` para o nosso projeto.

* `class Program`: Em C#, todo o código executável deve estar dentro de uma classe. A classe `Program` é o contêiner principal para o nosso código.

* `static void Main(string[] args)`: Este é o ponto de entrada do nosso programa. Quando o aplicativo é executado, o método `Main` é o primeiro a ser chamado. * `static`: Significa que o método pertence à classe `Program` e não a uma instância específica dela. * `void`: Indica que o método não retorna nenhum valor. * `string[] args`: É um array de strings que pode ser usado para passar argumentos de linha de comando para o programa (não estamos usando neste kata).

### 

O Menu Principal (`Menu` function)

O coração da nossa aplicação é a função `Menu`. Ela é responsável por interagir com o usuário.

```
static void Menu()
{
  Console.Clear();
  
  Console.WriteLine("O QUE DESEJA FAZER?");
  // ... (outras opções)

  Console.WriteLine("SELECIONE UMA OPÇÃO > ");
  short res = short.Parse(Console.ReadLine());
  
  switch(res)
  {
    // ...
  }
}
```

1. `Console.Clear()`: Limpa a tela do console, proporcionando uma interface mais limpa a cada vez que o menu é exibido.

2. `Console.WriteLine(...)`: Exibe as opções disponíveis para o usuário.

3. `Console.ReadLine()`: Lê a entrada do usuário a partir do console. O valor lido é sempre uma `string`.

4. `short.Parse(...)`: Como `ReadLine` retorna uma `string`, precisamos convertê-la para um tipo numérico para podermos usá-la em nossa lógica. `short.Parse` converte a string de entrada em um `short` (um tipo de número inteiro).

5. `switch(res)`: A estrutura `switch` é uma forma de controle de fluxo que permite executar diferentes blocos de código com base no valor de uma variável. É uma alternativa mais limpa a múltiplos `if-else if`.

* `case X:`: Cada `case` corresponde a um valor possível da variável `res`. Se `res` for `1`, o código dentro de `case 1:` será executado.

* `break;`: A palavra-chave `break` é usada para sair do `switch` após a execução de um `case`.

* `default:`: Se o valor de `res` não corresponder a nenhum dos `case`, o bloco `default` será executado. Em nosso caso, ele simplesmente chama o `Menu()` novamente.

* `System.Environment.Exit(0);`: No `case 5`, usamos este comando para encerrar a aplicação. O `0` indica que o programa terminou com sucesso.

### Funções de Operação (Sum, Subtraction, etc.)

Todas as funções de operação seguem um padrão semelhante. Vamos analisar a função `Sum()`:

```
static void Sum()
{
  Console.Clear();

  Console.WriteLine("First value: ");
  double v1 = double.Parse(Console.ReadLine());

  Console.WriteLine("Second value: ");
  double v2 = double.Parse(Console.ReadLine());

  double result = v1 + v2;

  Console.Clear();

  Console.WriteLine(" ========= Result ========");
  Console.WriteLine($" {v1} + {v2}  =  {result}");
  Console.ReadKey();
  Menu();
}
```

1. `Console.Clear()`: Limpa a tela para a nova "página" da operação.

2. `double.Parse(Console.ReadLine())`: Novamente, lemos a entrada do usuário e a convertemos. Desta vez, usamos `double.Parse` porque queremos trabalhar com números que podem ter casas decimais.

3. `double result = v1 + v2;`: Aqui está a lógica principal da função. Realizamos a soma dos dois números e armazenamos o resultado na variável `result`.

4. `Console.WriteLine($" {v1} + {v2}  =  {result}");`: Esta é uma string interpolada. O `$` no início da string nos permite incorporar variáveis diretamente no texto usando chaves `{}`. É uma forma moderna e legível de formatar strings.

5. `Console.ReadKey()`: Pausa a execução do programa e espera que o usuário pressione qualquer tecla. Isso é útil para que o usuário possa ver o resultado antes que o programa limpe a tela e volte ao menu.

6. `Menu()`: Após a operação ser concluída e o usuário pressionar uma tecla, chamamos a função `Menu()` novamente, criando um loop que permite ao usuário realizar outra operação ou sair.

## Conceitos-Chave Aplicados

* Funções: Organizamos nosso código em funções reutilizáveis (`Menu`, `Sum`, `Subtraction`, etc.), tornando o código mais limpo e fácil de manter.

* Tipos de Dados: Usamos `short` para a opção do menu e `double` para os valores dos cálculos, escolhendo os tipos apropriados para cada tarefa.

* Conversão de Tipos (Parsing): Convertemos a entrada do usuário de `string` para tipos numéricos usando `short.Parse` and `double.Parse`.

* Controle de Fluxo: Usamos a estrutura `switch` para tomar decisões com base na entrada do usuário.

* Entrada e Saída: Utilizamos a classe `Console` para interagir com o usuário, exibindo informações (`WriteLine`) e lendo dados (`ReadLine`).

* Recursão (Leve): A função `Menu` chama a si mesma no `default` do `switch`, e as funções de operação chamam `Menu` no final. Isso cria um ciclo de vida para a aplicação.

## Desafios para Expansão

Agora que você entende o código, aqui estão alguns desafios para você tentar:

1. Adicionar Potenciação: Crie uma nova opção no menu e uma função `Power()` que calcula `v1` elevado a `v2`. (Dica: você pode usar `Math.Pow(v1, v2)`).

2. Tratamento de Erros: O que acontece se o usuário digitar "abc" em vez de um número? O programa irá quebrar. Pesquise sobre `try-catch` em C# para lidar com essas exceções e exibir uma mensagem de erro amigável.

3. Raiz Quadrada: Adicione uma opção para calcular a raiz quadrada de um número. (Dica: `Math.Sqrt(v1)`).

4. Histórico de Operações: Como você poderia armazenar e exibir as últimas 5 operações que o usuário realizou?

Parabéns por concluir este kata! Você deu um passo importante na sua jornada de aprendizado de C#.



# O Paradigma da Programação Orientada a Objetos (POO)

A Programação Orientada a Objetos (POO, ou OOP do inglês Object-Oriented Programming) não é apenas um conjunto de técnicas ou um estilo de escrita de código; é um paradigma de programação fundamental. Um paradigma é uma maneira de pensar, uma filosofia sobre como estruturar e construir software. A POO revolucionou a engenharia de software ao propor uma abordagem que ajuda a gerenciar a crescente complexidade dos sistemas modernos.

Para entender o que a POO é, é útil contrastá-la com sua predecessora, a Programação Procedural.

* Programação Procedural: Foca nos verbos, ou seja, em procedimentos, rotinas e funções. Os dados e as operações sobre esses dados são mantidos separados. Você tem um conjunto de dados e passa esses dados para uma série de funções que os manipulam. Ex: `calcularFolhaDePagamento(dadosDoFuncionario)`. Conforme os sistemas crescem, manter o controle sobre quais funções modificam quais dados se torna exponencialmente difícil, levando a um código frágil e de difícil manutenção.

* Programação Orientada a Objetos: Foca nos substantivos, ou seja, nos objetos. A ideia central é unir os dados e as operações que os manipulam em uma única entidade coesa. Em vez de passar os dados para uma função, você invoca uma operação no próprio objeto que contém os dados. Ex: `funcionario.calcularFolhaDePagamento()`. O objeto se torna responsável por seus próprios dados.

Tip:

Dissertação: Essa mudança de foco de "o que o programa faz" (procedimentos) para "quem são os atores e quais são suas responsabilidades" (objetos) é a chave para gerenciar a complexidade. A POO nos permite modelar o mundo real, ou um sistema complexo, como uma coleção de componentes independentes e colaborativos, tornando o software mais intuitivo, robusto e escalável.

## A Ideia Central: Modelando o Mundo com Objetos

O objetivo da POO é criar um modelo do domínio do problema diretamente no código. Em vez de pensar em termos de fluxo de dados e algoritmos, você pensa em termos dos componentes do sistema.

Imagine que estamos construindo um software para uma biblioteca.

* Na abordagem procedural, pensaríamos em funções: `emprestarLivro()`, `verificarAtraso()`, `cadastrarMembro()`.

* Na abordagem orientada a objetos, nós primeiro identificamos os substantivos, os componentes do domínio: `Livro`, `Membro`, `Emprestimo`.

Cada um desses componentes se torna uma classe (um molde) em nosso código. A partir dessas classes, criamos objetos (as instâncias reais).

* Um objeto `Livro` saberia seu próprio título e autor (seu estado) e poderia ter comportamentos como `serEmprestado()` ou `serDevolvido()`.

* Um objeto `Membro` saberia seu próprio nome e histórico (seu estado) e poderia ter comportamentos como `pegarEmprestado(livro)` ou `devolver(livro)`.

O programa funciona através da interação desses objetos. Um objeto `Membro` pede a um objeto `Livro` para ser emprestado. Essa abordagem é imensamente mais natural e fácil de gerenciar do que um emaranhado de funções e variáveis globais.

## Os Quatro Pilares da POO: Uma Visão Geral

O paradigma da POO é sustentado por quatro conceitos fundamentais, frequentemente chamados de "Os Quatro Pilares". Eles trabalham em conjunto para permitir a criação de software robusto, flexível e reutilizável.

```PLANTUML
@startuml
' Settings to improve diagram appearance
skinparam rectangle {
    roundCorner 20
}
skinparam note {
    backgroundColor #LightYellow
    borderColor #Black
}
skinparam defaultFontName "Segoe UI, Arial"
skinparam defaultFontSize 12

' The central concept of an Object
rectangle "Object" as Object {
  - State (Internal Data)
  --
  + Behavior (Public Methods)
}

' The four pillars
rectangle "Encapsulation" as Encapsulation #ADD1B2
rectangle "Abstraction" as Abstraction #C1E1C1
rectangle "Inheritance" as Inheritance #FDFD96
rectangle "Polymorphism" as Polymorphism #FFB3BA

' Explanatory note
note right of Object
  An **instance** of a Class,
  combining data and behavior.
end note

' Relationships
Object -[#blue,bold]-> Encapsulation : << protects >>
Object -[#green,bold]-> Abstraction : << simplifies >>
Object -[#orange,bold]-> Inheritance : << reuses from >>
Object -[#red,bold]-> Polymorphism : << manifests as >>

@enduml
```

Vamos explorar cada pilar conceitualmente.

1. Encapsulamento (Encapsulation)

* Definição: É o ato de agrupar dados e os métodos que os manipulam em uma única unidade (a classe), e ao mesmo tempo ocultar o estado interno do objeto. O acesso aos dados é feito através de uma interface pública, protegendo-os de manipulação indevida.

* Analogia: Uma cápsula de remédio. O invólucro (a cápsula) protege os ingredientes ativos (os dados) do ambiente externo. Você não interage com os ingredientes diretamente; você ingere a cápsula inteira (interage com o objeto através de sua interface pública).

* Objetivo Principal: Proteção e Integridade. Garantir que um objeto nunca esteja em um estado inválido.

2. Abstração (Abstraction)

* Definição: É o processo de ocultar os detalhes complexos de implementação e expor apenas a funcionalidade essencial de um objeto. É o resultado do encapsulamento bem feito.

* Analogia: O painel de um carro. Ele te mostra a velocidade, o nível de combustível e a temperatura (a interface essencial), mas esconde os milhares de detalhes complexos do motor, sensores e fios que fazem tudo funcionar.

* Objetivo Principal: Gerenciamento da Complexidade. Simplificar o uso de objetos complexos.

3. Herança (Inheritance)

* Definição: É um mecanismo que permite a uma classe (filha) herdar os atributos e métodos de outra classe (mãe), estabelecendo uma relação de "é um(a)".

* Analogia: Uma árvore genealógica. Você herda traços genéticos de seus pais (cor dos olhos, tipo sanguíneo), mas também possui suas próprias características únicas.

* Objetivo Principal: Reutilização de Código e Organização. Evitar duplicação e criar hierarquias lógicas.

4. Polimorfismo (Polymorphism)

* Definição: Do grego, "muitas formas". É a capacidade de uma interface ser implementada por múltiplas classes, ou de objetos de diferentes classes responderem à mesma mensagem (chamada de método) de maneiras específicas.

* Analogia: A entrada USB do seu computador. A porta (a interface) é a mesma, mas você pode conectar nela um mouse, um teclado, um pen drive ou um celular. Cada dispositivo (objeto) responde ao "ser conectado" de uma maneira diferente, mas todos usam a mesma interface.

* Objetivo Principal: Flexibilidade e Extensibilidade. Permitir que o sistema seja estendido com novos tipos de objetos sem alterar o código existente que os utiliza.

## Por que Adotar a POO? Os Benefícios no Mundo Real

Dominar estes pilares e adotar o paradigma da POO traz benefícios concretos para o desenvolvimento de software:

* Modularidade: O software é composto por objetos independentes, o que torna mais fácil desenvolver, testar e depurar partes do sistema isoladamente.

* Manutenibilidade: Graças ao encapsulamento, uma mudança na implementação interna de um objeto tem menos probabilidade de "quebrar" outras partes do sistema.

* Escalabilidade: A POO gerencia bem a complexidade, permitindo que os sistemas cresçam de forma mais organizada e sustentável ao longo do tempo.

* Flexibilidade: Através da herança e do polimorfismo, é possível adicionar novas funcionalidades e estender o sistema com o mínimo de impacto no código já existente.

Tip:

Nota Adicional: A POO não é o único paradigma de programação. A Programação Funcional, por exemplo, é outro paradigma poderoso que foca em funções puras e imutabilidade. Linguagens modernas como o C# são multi-paradigma, permitindo que os desenvolvedores mesclem conceitos de POO e Programação Funcional para obter o melhor dos dois mundos.

## Referências Oficiais da Microsoft

* [Programação Orientada a Objetos (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/fundamentals/object-oriented/)

* [Tutorial: Introdução à POO com C#](https://dotnet.microsoft.com/pt-br/learn/csharp/hello-world-tutorial/intro-to-csharp)



# O que é um Objeto?

Em Programação Orientada a Objetos, se a Classe é o conceito abstrato, o molde, a planta baixa, então o Objeto é a entidade fundamental, concreta e viva. É a materialização de uma classe, uma instância real com a qual podemos interagir. Enquanto a classe é a ideia de um "Cliente", um objeto é um cliente específico: a "Alice Silva", com seu ID, email e data de cadastro únicos.

Um programa orientado a objetos é, em sua essência, uma coleção de objetos que interagem entre si. A execução do software é a história desses objetos sendo criados, tendo seus estados modificados e invocando os comportamentos uns dos outros para atingir um objetivo maior. Sem objetos, uma classe é apenas um plano sem utilidade; sem classes, não há plano para criar objetos.

## Diagramando a Relação: Classe vs. Objetos

Um diagrama pode solidificar essa distinção. A classe é o molde único, e os objetos são as múltiplas instâncias distintas criadas a partir dele, cada uma com seus próprios dados.

```PLANTUML
@startuml
' Settings to improve diagram appearance
skinparam classAttributeIconSize 0
skinparam monochrome true
skinparam classBackgroundColor White
skinparam classArrowColor Black
skinparam classBorderColor Black

' The Class is the blueprint, defining the structure.
class Customer {
  + Id : Guid
  + Name : string
  + Email : string
  + RegistrationDate : DateTime
  + UpdateEmail(newEmail) : void
}

' Objects are concrete, living instances of the class.
object "customerA: Customer" as customerA {
  Id = "guid-1111-..."
  Name = "Alice Silva"
  Email = "alice@email.com"
}

object "customerB: Customer" as customerB {
  Id = "guid-2222-..."
  Name = "Beto Costa"
  Email = "beto@email.com"
}

' The dashed arrow with an open head means "instantiation".
' It shows that the objects are instances of the class.
Customer <.. customerA : "instance of"
Customer <.. customerB : "instance of"
@enduml
```

Este diagrama ilustra perfeitamente que existe uma definição (`Customer`) e múltiplas instâncias (`customerA`, `customerB`), cada uma com seu próprio estado.

## As Duas Características Essenciais de um Objeto

Todo e qualquer objeto em POO é definido por duas características inseparáveis:

1. Estado (State)
O estado de um objeto é o conjunto de todos os seus dados (armazenados em campos e propriedades) em um determinado momento. É a "memória" do objeto, sua "fotografia" atual. É o que o torna único em relação a outros objetos da mesma classe.

Tip:

Dissertação: O estado é a essência da individualidade de um objeto. Dois objetos da classe `Customer` podem existir, mas é o estado — a combinação específica de `Id`, `Name` e `Email` — que os diferencia. `customerA` é a "Alice" e `customerB` é o "Beto". Sem um estado, todos os objetos seriam idênticos e, portanto, inúteis.

2. Comportamento (Behavior)
O comportamento de um objeto é o conjunto de ações que ele pode executar. Essas ações são definidas pelos métodos da sua classe. O mais importante é que o comportamento de um objeto quase sempre existe para visualizar ou, mais comumente, modificar seu próprio estado.

Tip:

Dissertação: A forte ligação entre estado e comportamento é o coração do encapsulamento. O método `UpdateEmail()` não é uma função solta no programa; ele é um comportamento do objeto `Customer` que existe especificamente para alterar o estado `Email` daquele objeto. O comportamento valida e protege o estado, garantindo que o objeto esteja sempre em uma condição consistente.

## Objetos em Código C#: Da Planta à Casa Real

Vamos ver como a teoria se traduz em código C# prático.

### 

Instanciação: O Poder da Palavra-chave `new`

Para criar um objeto (uma instância) a partir de uma classe, usamos a palavra-chave `new`. Esta palavra-chave é uma instrução fundamental que diz ao runtime do .NET para executar três passos:

1. Alocar Memória: Encontrar um bloco de memória na área chamada Heap que seja grande o suficiente para armazenar todos os dados de um objeto `Customer`.

2. Executar o Construtor: Chamar o método construtor da classe. A função do construtor é inicializar o objeto, colocando-o em um estado inicial válido e consistente.

3. Retornar a Referência: Devolver o endereço de memória do objeto recém-criado. Esse endereço (e não o objeto em si) é o que será armazenado na sua variável.

### 

Exemplo Prático: A Classe `Customer`

```CSHARP
// using System; // Required for Guid, DateTime, etc.

public class Customer
{
    // STATE: These properties define the data of a Customer.
    public Guid Id { get; private set; }
    public string Name { get; set; }
    public string Email { get; private set; }
    public DateTime RegistrationDate { get; private set; }

    // CONSTRUCTOR: This method is called by the 'new' keyword to initialize the object.
    public Customer(string name, string email)
    {
        // 'this' refers to the current instance of the object being created.
        this.Id = Guid.NewGuid();
        this.Name = name;
        this.Email = email;
        this.RegistrationDate = DateTime.UtcNow;
    }

    // BEHAVIOR: This method defines an action the object can perform.
    // It modifies the object's own state.
    public void UpdateEmail(string newEmail)
    {
        // In a real system, you would add validation here.
        this.Email = newEmail;
        Console.WriteLine($"Email for customer '{this.Name}' has been updated to '{this.Email}'.");
    }
}

public class CustomerManagement
{
    public static void Main()
    {
        // INSTANTIATION: We use 'new' to create a living object from the Customer class.
        // 'customerA' now holds a reference (a memory address) to the new object.
        Customer customerA = new Customer("Alice Silva", "alice@email.com");

        // We create another, completely separate object.
        Customer customerB = new Customer("Beto Costa", "beto@email.com");

        // INTERACTION: We use the dot (.) operator to access the object's public members.
        Console.WriteLine($"New customer created: {customerA.Name}, ID: {customerA.Id}");
        customerA.UpdateEmail("alice.silva@newdomain.com");
    }
}
```

## Aprofundando: Objetos são Tipos de Referência

Este é um dos conceitos técnicos mais importantes em C#. Entendê-lo previne uma classe inteira de bugs.

Em C#, existem duas grandes categorias de tipos: Tipos de Valor (`int`, `bool`, `struct`) e Tipos de Referência (`class`, `string`, `array`). Objetos são sempre tipos de referência.

* Analogia: Pense na memória do seu computador como uma cidade. O Heap é a área residencial, onde as casas (objetos) são construídas. A Stack é um caderno de anotações rápido, onde você anota os endereços das casas. Uma variável de objeto (`Customer customerA`) é uma linha no seu caderno (na Stack) que contém apenas o endereço da casa (no Heap).

Quando você atribui uma variável de objeto a outra, você não está construindo uma casa nova. Você está apenas copiando o endereço de um lado para o outro do seu caderno.

```CSHARP
// customer1 is a note on the Stack, holding the address of a new Customer object on the Heap.
Customer customer1 = new Customer("Carlos Dias", "carlos@email.com");

// We are NOT creating a new object here.
// We are just copying the memory address from customer1 to customer2.
// Both variables now point to the exact same object on the Heap.
Customer customer2 = customer1; 

// If we modify the object using one reference...
Console.WriteLine($"Original name for customer1: {customer1.Name}"); // Carlos Dias
customer2.Name = "Carlão";

// ...the change is visible through the other reference, because it's the same object.
Console.WriteLine($"Name for customer1 after change: {customer1.Name}"); // Carlão
```

Tip:

Nota sobre Identidade vs. Igualdade: Por causa do comportamento de referência, temos dois tipos de "igualdade". Igualdade de Referência (`Object.ReferenceEquals(a, b)`) pergunta: "As duas variáveis apontam para o mesmíssimo objeto na memória?". Igualdade de Valor (`a.Equals(b)`) pergunta: "Os dois objetos, mesmo que sejam instâncias diferentes, contêm os mesmos valores e são considerados equivalentes?". São conceitos distintos e importantes em cenários mais avançados.

Tip:

Nota sobre `System.Object`: Em C#, toda e qualquer classe, implícita ou explicitamente, herda de uma classe base universal chamada `System.Object`. Isso significa que todo objeto em C# tem, no mínimo, os comportamentos definidos por `System.Object`, como `Equals()`, `GetHashCode()` e `ToString()`.

## Referências Oficiais da Microsoft

* [Objetos (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/fundamentals/object-oriented/objects)

* [Classes (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/fundamentals/object-oriented/classes)

* [Tipos de Referência (Referência de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/reference-types)



# O que é uma Classe?

No universo da Programação Orientada a Objetos (OOP), a classe é, sem dúvida, o conceito mais fundamental. Pense nela como uma planta baixa ou um molde. Uma planta baixa de uma casa define todas as suas características: quantos quartos terá, a localização da cozinha, o número de banheiros, e assim por diante. No entanto, a planta baixa em si não é a casa; ela é apenas o projeto para construir casas. Cada casa construída a partir daquela planta é um objeto.

Em C#, uma `class` é exatamente isso: um modelo para criar objetos. Ela é uma estrutura que agrupa dados (informações sobre o estado) e comportamentos (ações que podem ser executadas) em uma única unidade lógica e coesa.

Ao definir uma classe, estamos criando um novo tipo de dado em nosso programa. Assim como temos tipos primitivos como `int` para números inteiros e `string` para textos, podemos criar um tipo `Customer`, `Product` ou `Invoice` que representa uma entidade do mundo real ou um conceito do nosso sistema.

## Estrutura Fundamental de uma Classe

Uma classe encapsula seus membros, que podem ser campos, propriedades, métodos e eventos. Vamos visualizar a estrutura de uma classe `Customer` (Cliente) de um sistema de e-commerce usando um diagrama PlantUML.

```PLANTUML
@startuml
title Diagrama de Classe: Customer

class Customer {
  -- Campos (Estado Interno) --
  - Guid _id
  - string _firstName
  - string _lastName
  - string _email
  - DateTime _creationDate

  -- Propriedades (Interface Pública) --
  + Id : Guid <<get>>
  + FirstName : string <<get/set>>
  + LastName : string <<get/set>>
  + Email : string <<get/set>>
  + CreationDate : DateTime <<get>>

  -- Construtor --
  + Customer(firstName, lastName, email)

  -- Métodos (Comportamentos) --
  + GetFullName() : string
  + UpdateEmail(newEmail) : void
  - IsValidEmail(email) : bool
}
@enduml
```

Este diagrama nos mostra de forma clara:

* O nome da classe: `Customer`.

* Seus campos (representados com `-`, indicando que são `private`), que guardam o estado interno do objeto.

* Suas propriediedades (representadas com `+`, indicando que são `public`), que expõem os dados de forma controlada.

* Seu construtor, um método especial para criar o objeto.

* Seus métodos (também com `+` para `public` e `-` para `private`), que definem o que o objeto pode fazer.

## Anatomia de uma Classe em C#

Vamos traduzir o diagrama acima em código C# e dissecar cada parte.

```
// A 'public' keyword is an access modifier. It means this class can be accessed
// from anywhere in the project.
public class Customer
{
    // Fields: These are private variables that hold the internal state of the object.
    // The underscore prefix (_) is a common convention for private fields.
    private readonly Guid _id;
    private string _firstName;
    private string _lastName;
    private string _email;
    private readonly DateTime _creationDate;

    // Properties: These are the public "gates" to the private fields.
    // They control how the data is accessed and modified. This is a core
    // principle of Encapsulation.
    public Guid Id => _id; // Expression-bodied property for read-only access
    public string FirstName
    {
        get { return _firstName; }
        set { _firstName = value; }
    }
    public string LastName
    {
        get { return _lastName; }
        set { _lastName = value; }
    }
    public string Email
    {
        get { return _email; }
        set { _email = value; }
    }
    public DateTime CreationDate => _creationDate;

    // Constructor: A special method called when a new object is created.
    // It's used to initialize the object's state.
    public Customer(string firstName, string lastName, string email)
    {
        _id = Guid.NewGuid();
        _creationDate = DateTime.UtcNow;
        _firstName = firstName;
        _lastName = lastName;
        _email = email;
    }

    // Methods: These define the actions the object can perform.
    public string GetFullName()
    {
        return $"{_firstName} {_lastName}";
    }

    public void UpdateEmail(string newEmail)
    {
        if (IsValidEmail(newEmail))
        {
            _email = newEmail;
        }
        else
        {
            // In a real application, we would throw an exception here.
            Console.WriteLine("Invalid email format.");
        }
    }

    // This is a private method. It can only be called by other members
    // of this same class. It's a helper method.
    private bool IsValidEmail(string email)
    {
        // A simple (but not perfect) email validation.
        return email.Contains("@") && email.Contains(".");
    }
}
```

### Dissecando o Código

1. Modificadores de Acesso (`public`): A palavra-chave `public` determina a "visibilidade" da classe. `public` significa que qualquer outra parte do seu código pode criar e usar objetos `Customer`. Outros modificadores incluem `internal` (visível apenas dentro do mesmo projeto/assembly) e `private` (visível apenas dentro de outra classe, no caso de classes aninhadas).

2. Campos (`Fields`): São as variáveis internas da classe. A boa prática, ligada ao pilar do Encapsulamento, dita que os campos devem ser `private`. Isso protege o estado interno do objeto de ser modificado de forma inesperada e inconsistente. A convenção de usar um underscore (`_`) no início do nome (`_firstName`) ajuda a diferenciar visualmente os campos privados das variáveis locais.

Tip:

Nota: A palavra-chave `readonly` significa que o valor do campo só pode ser atribuído durante a sua declaração ou dentro do construtor da classe. Uma vez definido, ele não pode mais ser alterado, garantindo a imutabilidade daquele dado específico (como o `Id` e a `CreationDate` do cliente).

3. Propriedades (`Properties`): Se os campos são o cofre, as propriedades são a porta do cofre. Elas expõem publicamente os dados dos campos de uma maneira controlada. Uma propriedade tem dois blocos:

* `get`: É executado quando o valor da propriedade é lido. Ele retorna o valor do campo correspondente.

* `set`: É executado quando um valor é atribuído à propriedade. A palavra-chave `value` representa o valor que está sendo atribuído.

No exemplo `public Guid Id => _id;`, usamos uma sintaxe mais curta, chamada expression-bodied property, que é útil para propriedades que são somente leitura (`read-only`) e apenas retornam o valor de um campo.

4. Construtor (`Constructor`): É um método especial que não tem tipo de retorno e possui o mesmo nome da classe. Sua função é inicializar um objeto, garantindo que ele nasça em um estado válido e consistente. No nosso exemplo, o construtor exige que um novo `Customer` seja criado já com nome, sobrenome e email, além de gerar automaticamente um `Id` e a data de criação.

5. Métodos (`Methods`): Representam os comportamentos e ações. `GetFullName()` é um método que calcula e retorna uma informação derivada do estado do objeto. `UpdateEmail(string newEmail)` é um método que modifica o estado do objeto, mas de forma controlada, validando a informação antes de aplicá-la.

## Instanciando e Usando um Objeto

Definir a classe é como desenhar a planta. Para ter a casa, precisamos construí-la. Em C#, "construir" um objeto a partir de uma classe é chamado de instanciação. Usamos a palavra-chave `new` para isso.

```
public class Program
{
    public static void Main()
    {
        // Instantiating a new object from the Customer class.
        // We are "calling" the constructor here and passing the required arguments.
        var customer1 = new Customer("John", "Doe", "john.doe@example.com");

        // Now, 'customer1' is an object, an instance of the Customer class.
        // We can access its public properties and methods using the dot (.) operator.

        // Reading properties
        Console.WriteLine($"Customer ID: {customer1.Id}");
        Console.WriteLine($"Customer Name: {customer1.GetFullName()}"); // Using a method
        Console.WriteLine($"Original Email: {customer1.Email}");

        // Modifying state through a property
        customer1.LastName = "Smith";
        Console.WriteLine($"Updated Name: {customer1.GetFullName()}");

        // Modifying state through a method
        customer1.UpdateEmail("john.smith@newdomain.com");
        Console.WriteLine($"Updated Email: {customer1.Email}");

        // Trying to do something invalid
        customer1.UpdateEmail("invalid-email"); // The internal logic will prevent this
        Console.WriteLine($"Email after invalid update: {customer1.Email}");
    }
}
```

Neste exemplo, `customer1` é a nossa "casa". É uma entidade na memória que foi construída a partir do molde `Customer`. Ela tem sua própria cópia dos dados (`_firstName`, `_lastName`, etc.) e pode executar os comportamentos definidos na classe.

## Conclusão

A classe é o pilar central da Programação Orientada a Objetos em C#. Ela nos permite modelar conceitos do mundo real ou abstratos de forma organizada, segura e reutilizável. Ao agrupar estado (dados) e comportamento (métodos) em uma única unidade, as classes nos ajudam a construir sistemas complexos de maneira mais gerenciável e lógica. Dominar o conceito de classes, incluindo encapsulamento, propriedades, construtores e métodos, é o passo mais crucial para se tornar um desenvolvedor C# proficiente.

Tip:

### Referências Oficiais

Para um estudo mais aprofundado, consulte sempre a documentação oficial da Microsoft, que é a fonte primária de conhecimento:

* [Documentação sobre Classes em C#](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/classes)



# Propriedades

Em C#, uma Propriedade é um membro de uma classe que fornece um mecanismo flexível e poderoso para ler, escrever ou calcular o valor de um campo privado. Elas são a face pública do estado de um objeto e a principal ferramenta para implementar o pilar do Encapsulamento.

À primeira vista, uma propriedade pode parecer simplesmente uma forma mais verbosa de se declarar uma variável pública, mas essa impressão é enganosa. Na verdade, elas são os guardiões dos dados de um objeto, permitindo controle total sobre como o estado é acessado e modificado.

Tip:

Dissertação: Pense em um campo público (`public string Nome;`) como uma porta sem tranca para um cômodo da sua casa. Qualquer um pode entrar a qualquer momento e fazer o que quiser. Uma propriedade (`public string Nome { get; set; }`), por outro lado, é uma porta com um porteiro. Mesmo que, inicialmente, o porteiro deixe todo mundo entrar e sair sem questionar, ele está lá. Se, no futuro, você decidir que apenas pessoas autorizadas podem entrar, ou que ninguém pode sair com os móveis, você só precisa dar novas instruções ao porteiro. Você não precisa reconstruir todas as entradas da sua casa. Essa é a essência e o poder das propriedades.

## O Problema: Por que Não Usar Campos Públicos?

Uma pergunta comum para quem está começando é: "Se `public string Name { get; set; }` funciona de forma parecida com `public string Name;`, por que toda essa cerimônia?". A resposta está na quebra do encapsulamento.

Um campo público é um convite ao caos. Ele expõe a representação interna do estado do seu objeto sem nenhuma proteção. Qualquer parte do seu sistema pode modificar esse campo para qualquer valor, a qualquer momento, incluindo valores inválidos.

```CSHARP
public class Product
{
    // BAD PRACTICE: Public field. No control, no validation.
    public decimal price;
}

// Some other part of the code...
var myProduct = new Product();
myProduct.price = -999.99m; // The object is now in an invalid state!
```

Se você usa um campo público e, meses depois, percebe que precisa adicionar uma validação (o preço não pode ser negativo), você terá um problema gigantesco. Você precisará encontrar todos os lugares no seu código que modificam `myProduct.price` e adicionar a lógica de validação ali. Isso é frágil, propenso a erros e insustentável. Com uma propriedade, a mudança é feita em um único lugar: dentro da classe `Product`.

## A Anatomia de uma Propriedade

Uma propriedade é, na verdade, "açúcar sintático" (uma forma mais bonita de escrever) para um par de métodos chamados acessadores (`accessors`).

* Campo de Apoio (Backing Field): Geralmente, uma propriedade envolve um campo `private` que armazena o dado real. A convenção é nomeá-lo com um underscore (`_`) no início (ex: `_name`).

* Acessador `get`: Este bloco de código é executado quando o valor da propriedade é lido. Ele deve retornar um valor do tipo da propriedade.

* Acessador `set`: Este bloco de código é executado quando um valor é atribuído à propriedade. Dentro do bloco `set`, você tem acesso a uma palavra-chave implícita chamada `value`, que contém o valor que está sendo atribuído. É aqui que a mágica da validação e do controle acontece.

### Diagrama Conceitual

Este diagrama ilustra como a propriedade atua como um intermediário ou guardião para o campo privado.

```PLANTUML
@startuml
skinparam classAttributeIconSize 0
skinparam monochrome true
skinparam shadowing false

class UserProfile {
    ' The private backing field holds the actual data.
    - _email : string

    ' The public property acts as a gateway.
    + Email : string
    .. Get/Set Accessors ..
    + {method} get()
    + {method} set(value)
}

rectangle "External Code" as Ext

note right of UserProfile::Email
  Provides controlled access
  to the internal _email field.
  Can contain validation logic.
end note

Ext .right.> UserProfile : "Accesses public property"
UserProfile::Email .down.> UserProfile::_email : "Manages private field"
@enduml
```

## Tipos de Propriedades em C#

C# oferece várias sintaxes para declarar propriedades, cada uma adequada a um cenário diferente.

### 1. Propriedades Automáticas (Auto-Implemented Properties)

Esta é a forma mais comum e concisa. Você a utiliza quando não precisa de nenhuma lógica customizada nos acessadores.

`public string Name { get; set; }`

Ao usar esta sintaxe, o compilador do C# cria um backing field anônimo e privado para você nos bastidores. Você obtém todos os benefícios de uma propriedade (flexibilidade futura) com a clareza de um campo.

### 2. Propriedades Completas (Fully-Implemented Properties)

Você usa esta forma quando precisa de um backing field explícito para implementar uma lógica customizada.

```CSHARP
private int _age;

public int Age
{
    get
    {
        return _age;
    }
    set
    {
        // Validation logic inside the setter.
        if (value < 0 || value > 120)
        {
            throw new ArgumentOutOfRangeException(nameof(value), "Age must be between 0 and 120.");
        }
        _age = value;
    }
}
```

### 3. Propriedades de Apenas Leitura (Read-Only Properties)

Frequentemente, você quer expor um dado que não pode ser modificado de fora da classe. Existem duas maneiras principais:

* Propriedade Computada: Não tem um backing field e seu valor é calculado no `get`. Ela não possui um acessador `set`. `public string Description => $"{Name} is {Age} years old.";`

* Propriedade com `private set`: O valor pode ser lido por todos, mas só pode ser modificado de dentro da própria classe (geralmente no construtor). Isso é perfeito para IDs ou datas de criação. `public Guid Id { get; private set; }`

### 

Exemplo Prático: `UserProfile`

Este exemplo combina os diferentes tipos de propriedades em uma classe do mundo real.

```CSHARP
public class UserProfile
{
    // 1. Read-only property with a private setter.
    // The ID is set once in the constructor and can never be changed from outside.
    public Guid Id { get; private set; }

    // 2. Auto-implemented property for simple data.
    public string Username { get; set; }

    // 3. Full property with validation logic.
    private string _email;
    public string Email
    {
        get { return _email; }
        set
        {
            // Simple validation to ensure the value looks like an email.
            if (string.IsNullOrWhiteSpace(value) || !value.Contains("@"))
            {
                throw new ArgumentException("A valid email is required.", nameof(value));
            }
            _email = value;
        }
    }

    // 4. Read-only computed property using expression-body syntax.
    public string DisplayName => $"@{Username}";

    public UserProfile(string username, string email)
    {
        Id = Guid.NewGuid();
        Username = username;
        Email = email; // The setter for Email is called here, so validation runs.
    }
}

public class Program
{
    public static void Main()
    {
        try
        {
            var user = new UserProfile("mrpunkdasilva", "mr.punk@example.com");
            Console.WriteLine($"User created: {user.DisplayName} (ID: {user.Id})");

            // This works, the setter logic is executed.
            user.Email = "dasilva.punk@newdomain.com";
            Console.WriteLine($"Email updated to: {user.Email}");

            // This will throw an exception due to the validation in the setter.
            user.Email = "invalid-email";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"\nAn error occurred: {ex.Message}");
        }
    }
}
```

Tip:

Nota sobre `init-only` setters (C# 9 e superior): Uma adição moderna são os `init` setters: `public string Name { get; init; }`. Eles agem como um `set`, mas só permitem que a propriedade seja atribuída durante a inicialização do objeto (no construtor ou em um inicializador de objeto: `new User { Name = "Test" }`). Após a criação, a propriedade se torna efetivamente de apenas leitura. Isso é extremamente útil para criar objetos imutáveis.

## Referências Oficiais da Microsoft

* [Propriedades (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/properties)

* [Usando Propriedades](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/using-properties)

```

```



# Métodos

Se as Propriedades representam o estado de um objeto (seus dados, suas características), os Métodos representam seu comportamento. Eles são os verbos da Programação Orientada a Objetos, os blocos de código que executam ações, manipulam o estado e, em última análise, fazem o trabalho do seu programa. Um método encapsula uma série de instruções sob um único nome, permitindo que essa lógica seja reutilizada e invocada de forma clara e organizada.

Tip:

Dissertação: Pense em um objeto `Email`. Seu estado (propriedades) seria o `Destinatario`, o `Assunto` e o `CorpoDoEmail`. Mas o email por si só é inerte. É o método `Enviar()` que contém a lógica complexa de se conectar a um servidor SMTP, autenticar, transmitir os dados e tratar possíveis erros. O método é onde a lógica de negócio reside. Ele age sobre o estado do objeto (`Destinatario`, `Assunto`) para realizar uma tarefa significativa. Dominar a criação de métodos claros, coesos e bem definidos é essencial para construir qualquer aplicação funcional.

## A Anatomia de um Método

Para usar métodos de forma eficaz, é crucial entender cada parte de sua declaração, conhecida como sua assinatura e corpo.

Vamos dissecar um exemplo do mundo real: um método para adicionar um item a um carrinho de compras.

`public bool AddItem(Product product, int quantity)`

1. Modificador de Acesso (`public`): Define a visibilidade do método. `public` significa que ele pode ser chamado de qualquer lugar do seu código. Outras opções comuns são `private` (só pode ser chamado de dentro da mesma classe) e `protected` (pode ser chamado pela classe e suas derivadas).

2. Tipo de Retorno (`bool`): Especifica o tipo de dado que o método irá retornar após sua execução ser concluída. Neste caso, um `bool` (booleano) poderia indicar se o item foi adicionado com sucesso (`true`) ou não (`false`). Se um método não retorna nenhum valor, usamos a palavra-chave `void`.

3. Nome do Método (`AddItem`): Um nome descritivo e, por convenção, baseado em um verbo, que indica a ação que o método realiza.

4. Lista de Parâmetros (`(Product product, int quantity)`): Define os dados de entrada que o método precisa para executar sua tarefa. Cada parâmetro tem um tipo (ex: `Product`) e um nome (ex: `product`). A combinação do nome do método e dessa lista de parâmetros forma a assinatura única do método.

5. Corpo do Método (`{...}`): O bloco de código entre chaves que contém as instruções a serem executadas quando o método é chamado.

### Diagrama de Métodos (PlantUML)

Este diagrama ilustra uma classe `ShoppingCart` e destaca a anatomia de seus métodos.

```PLANTUML
@startuml
skinparam classAttributeIconSize 0
skinparam monochrome true
skinparam shadowing false

class ShoppingCart {
    ' A private field to hold the state
    - _items : List<CartItem>

    ' Methods defining the object's behavior
    + AddItem(product: Product, quantity: int) : bool
    + RemoveItem(productId: Guid) : void
    + GetSubtotal() : decimal
    + ApplyDiscountCode(code: string) : bool
    + Clear() : void
}

class Product

note right of ShoppingCart::AddItem
  Signature: AddItem(Product, int)
  Returns: bool (e.g., success/failure)
end note

note right of ShoppingCart::GetSubtotal
  Signature: GetSubtotal()
  Returns: decimal (a calculated value)
end note

note right of ShoppingCart::Clear
  Signature: Clear()
  Returns: void (performs an action, no return value)
end note

ShoppingCart o-- Product : uses
@enduml
```

## Passando Dados para Métodos: Uma Análise Profunda

A maneira como os dados fluem para dentro de um método é um dos conceitos mais importantes para se dominar em C#. A escolha do modificador de parâmetro correto afeta não apenas o comportamento do método, mas também a performance e a clareza do código. Vamos dissecar cada tipo com exemplos práticos.

### O Comportamento Padrão: Passagem por Valor

Este é o comportamento padrão em C#. Quando você passa um argumento para um método, uma cópia do valor desse argumento é criada e passada para o parâmetro do método. O que isso significa na prática depende se o tipo é um Tipo de Valor (`struct`, `int`, `bool`, etc.) ou um Tipo de Referência (`class`, `string`, `array`, etc.).

#### 

Passando Tipos de Valor (ex: `int`, `struct`)

Uma cópia completa do valor é feita. Qualquer alteração no parâmetro dentro do método não afeta a variável original.

```CSHARP
public void Square(int number)
{
    // 'number' is a copy of the original 'myValue'.
    number = number * number;
    Console.WriteLine($"Inside method: {number}");
}

public void Test()
{
    int myValue = 5;
    Console.WriteLine($"Before method: {myValue}");
    Square(myValue);
    Console.WriteLine($"After method: {myValue}");
}

// Output:
// Before method: 5
// Inside method: 25
// After method: 5 
```

Tip:

Análise: Observe que `myValue` permaneceu `5` após a chamada do método. A variável `number` dentro de `Square` era uma cópia completamente independente.

#### 

Passando Tipos de Referência (ex: `class`)

Aqui a situação é mais sutil e uma fonte comum de confusão. O que é passado por valor (copiado) é a referência ao objeto, não o objeto em si. Ambas as variáveis (a original e o parâmetro) apontam para o mesmo objeto na memória.

Isso significa que:

1. Se você alterar uma propriedade do objeto dentro do método, a alteração será visível fora, pois o objeto é o mesmo.

2. Se você atribuir um novo objeto ao parâmetro (`param = new MyClass()`), isso não afetará a variável original. Você está apenas fazendo o parâmetro (a cópia da referência) apontar para um novo lugar.

```CSHARP
public class Score
{
    public int Value { get; set; }
}

public void ModifyScore(Score score)
{
    // 1. This change WILL be visible outside, because we are modifying
    // the object that the reference points to.
    score.Value = 100;

    // 2. This change WILL NOT be visible outside. We are changing the
    // parameter (the copied reference) to point to a new object.
    // The original variable still points to the old object.
    score = new Score { Value = 999 };
    Console.WriteLine($"Inside method, after new: {score.Value}");
}

public void Test()
{
    var myScore = new Score { Value = 10 };
    Console.WriteLine($"Before method: {myScore.Value}");
    ModifyScore(myScore);
    Console.WriteLine($"After method: {myScore.Value}");
}

// Output:
// Before method: 10
// Inside method, after new: 999
// After method: 100
```

Tip:

Análise: O valor final de `myScore.Value` é `100`, provando que a alteração na propriedade do objeto original foi bem-sucedida. A reatribuição para um `new Score` dentro do método foi irrelevante para a variável `myScore`.

### 

Modificador `ref`: Passando por Referência

Ao usar `ref`, você não passa mais uma cópia. Você passa a própria referência da variável original. É como dar ao método o endereço de memória da sua variável. Qualquer alteração feita no parâmetro, seja no valor/propriedade ou uma reatribuição, afetará diretamente a variável original.

* A variável deve ser inicializada antes de ser passada.

* Tanto na chamada quanto na declaração do método, a palavra-chave `ref` deve ser usada.

```CSHARP
public void DoubleValue(ref int number)
{
    // This now modifies the original variable.
    number = number * 2;
}

public void Test()
{
    int myValue = 5;
    Console.WriteLine($"Before: {myValue}");
    DoubleValue(ref myValue);
    Console.WriteLine($"After: {myValue}");
}

// Output:
// Before: 5
// After: 10
```

Tip:

Uso: Use `ref` com moderação. Geralmente é preferível que um método retorne um valor em vez de modificar seus parâmetros de entrada. É útil em cenários de alta performance ou ao trabalhar com APIs mais antigas.

### 

Modificador `out`: Parâmetros de Saída

O `out` é muito similar ao `ref`, mas com duas diferenças cruciais:

1. A variável passada para um parâmetro `out` não precisa ser inicializada antes da chamada.

2. O método que recebe um parâmetro `out` é obrigado a atribuir um valor a ele antes de retornar.

É o padrão da indústria para métodos que precisam retornar múltiplos valores. O exemplo clássico é o padrão `Try...`.

```CSHARP
public bool TryParseDate(string text, out DateTime result)
{
    // The method MUST assign a value to 'result' before it exits.
    try
    {
        result = DateTime.Parse(text);
        return true;
    }
    catch (FormatException)
    {
        result = default; // Assign a default value on failure.
        return false;
    }
}

public void Test()
{
    string dateString = "2025-08-27";
    // The 'parsedDate' variable doesn't need to be initialized.
    if (TryParseDate(dateString, out DateTime parsedDate))
    {
        Console.WriteLine($"Successfully parsed: {parsedDate.ToShortDateString()}");
    }
    else
    {
        Console.WriteLine("Failed to parse the date.");
    }
}

// Output:
// Successfully parsed: 27/08/2025
```

Tip:

Análise: O método `TryParseDate` consegue comunicar duas coisas: o sucesso da operação (através do `bool` de retorno) e o resultado da operação (através do parâmetro `out`).

### 

Modificador `in`: Parâmetros de Entrada Somente Leitura

Introduzido em versões mais recentes do C#, o `in` é o oposto do `out`. Ele também passa o argumento por referência (evitando cópias), mas garante que o método não pode modificar o valor.

Seu principal caso de uso é um ganho de performance ao passar `structs` grandes. Copiar um `struct` grande pode ser custoso; passá-lo com `in` envia apenas uma referência, de forma muito mais rápida, com a segurança de que ele não será alterado.

```CSHARP
// Imagine this is a very large struct.
public readonly struct Point3D
{
    public double X { get; }
    public double Y { get; }
    public double Z { get; }

    public Point3D(double x, double y, double z)
    {
        X = x; Y = y; Z = z;
    }
}

// By using 'in', we avoid copying the Point3D struct.
public void PrintPoint(in Point3D point)
{
    // The method can read the point's data.
    Console.WriteLine($"({point.X}, {point.Y}, {point.Z})");

    // But any attempt to modify it would cause a COMPILE ERROR.
    // point = new Point3D(0,0,0); // Error!
    // point.X = 10; // Error (also because property is readonly, but 'in' enforces it)
}
```

### 

Modificador `params`: Array de Parâmetros

A palavra-chave `params` permite que um método aceite um número variável de argumentos.

* Só pode haver um `params` por método.

* Ele deve ser o último parâmetro na assinatura do método.

* Os argumentos passados são agrupados em um array dentro do método.

```CSHARP
// This method can accept any number of integers.
public double CalculateAverage(params int[] numbers)
{
    if (numbers == null || numbers.Length == 0)
    {
        return 0;
    }
    
    double sum = 0;
    foreach (var number in numbers)
    {
        sum += number;
    }
    return sum / numbers.Length;
}

public void Test()
{
    // You can call it with multiple arguments...
    double avg1 = CalculateAverage(10, 20, 30);
    Console.WriteLine($"Average 1: {avg1}");

    // ...with a single argument...
    double avg2 = CalculateAverage(99);
    Console.WriteLine($"Average 2: {avg2}");

    // ...or with no arguments.
    double avg3 = CalculateAverage();
    Console.WriteLine($"Average 3: {avg3}");
}

// Output:
// Average 1: 20
// Average 2: 99
// Average 3: 0
```

### Parâmetros Opcionais e Nomeados

Parâmetros Opcionais permitem que você defina um valor padrão para um parâmetro na assinatura do método. Se o chamador não fornecer um argumento para ele, o valor padrão é usado. Eles devem vir depois de todos os parâmetros obrigatórios.

Parâmetros Nomeados permitem que você especifique o nome do parâmetro ao passar o argumento. Isso melhora a legibilidade e permite passar argumentos fora de ordem, o que é especialmente útil com parâmetros opcionais.

```CSHARP
public void CreateUser(string username, string role = "User", bool isActive = true)
{
    Console.WriteLine($"Creating user '{username}' with role '{role}' and status '{(isActive ? "Active" : "Inactive")}'.");
}

public void Test()
{
    // 1. Using all default parameters
    CreateUser("john.doe");

    // 2. Providing one optional parameter
    CreateUser("jane.doe", "Administrator");

    // 3. Using named parameters to skip one and improve readability
    CreateUser(username: "super.user", isActive: false);
    
    // 4. Using named parameters out of order
    CreateUser(isActive: true, role: "Guest", username: "guest.user");
}

// Output:
// Creating user 'john.doe' with role 'User' and status 'Active'.
// Creating user 'jane.doe' with role 'Administrator' and status 'Active'.
// Creating user 'super.user' with role 'User' and status 'Inactive'.
// Creating user 'guest.user' with role 'Guest' and status 'Active'.
```

## Sobrecarga de Métodos (Method Overloading)

A sobrecarga é a capacidade de definir, na mesma classe, múltiplos métodos com o mesmo nome, desde que suas assinaturas sejam diferentes (ou seja, a quantidade ou o tipo dos parâmetros sejam diferentes).

Isso é extremamente útil para fornecer maneiras mais convenientes de chamar uma mesma ação.

```CSHARP
public class ShoppingCart
{
    // Overload 1: The main method
    public void AddItem(Product product, int quantity)
    {
        Console.WriteLine($"Adding {quantity} of '{product.Name}'.");
        // ... logic ...
    }

    // Overload 2: A convenience method. If quantity is not provided, it defaults to 1.
    public void AddItem(Product product)
    {
        // It calls the other overload to avoid duplicating code.
        AddItem(product, 1);
    }

    // Overload 3: Another convenience method. Finds the product by its ID first.
    public void AddItem(Guid productId, int quantity)
    {
        // In a real system, we would fetch the product from a database.
        Product product = FindProductById(productId);
        if (product != null)
        {
            AddItem(product, quantity);
        }
    }

    private Product FindProductById(Guid id) { /* ... database logic ... */ return new Product(); }
    public class Product { public string Name { get; set; } }
}
```

## Exemplo Prático Completo

```CSHARP
public class Order
{
    public Guid Id { get; private set; }
    public List<string> Items { get; private set; }
    public decimal TotalAmount { get; private set; }
    public bool IsShipped { get; private set; }

    public Order()
    {
        Id = Guid.NewGuid();
        Items = new List<string>();
        TotalAmount = 0;
        IsShipped = false;
    }

    // A simple method to add an item and update the total.
    public void AddItem(string itemName, decimal price, int quantity = 1)
    {
        if (IsShipped)
        {
            Console.WriteLine("Error: Cannot modify a shipped order.");
            return;
        }
        Items.Add($"{itemName} (x{quantity})");
        TotalAmount += price * quantity;
        Console.WriteLine($"Added '{itemName}'. Subtotal is now {TotalAmount:C}.");
    }

    // A method that uses an 'out' parameter.
    public bool TryApplyDiscount(string discountCode, out decimal discountAmount)
    {
        discountAmount = 0;
        if (discountCode == "SAVE10")
        {
            discountAmount = TotalAmount * 0.10m;
            TotalAmount -= discountAmount;
            return true; // Success
        }
        return false; // Failure
    }

    // A method that changes the state of the object.
    public void ShipOrder()
    {
        if (Items.Count == 0)
        {
            Console.WriteLine("Error: Cannot ship an empty order.");
            return;
        }
        IsShipped = true;
        Console.WriteLine($"Order {Id} has been shipped.");
    }
}

public class OrderProcessing
{
    public static void Main()
    {
        var order = new Order();
        order.AddItem("Laptop", 1500.00m);
        order.AddItem("Mouse", 75.50m, 2); // Using the optional parameter

        // Using the method with an 'out' parameter
        if (order.TryApplyDiscount("SAVE10", out decimal appliedDiscount))
        {
            Console.WriteLine($"Applied a discount of {appliedDiscount:C}. New total: {order.TotalAmount:C}");
        }

        order.ShipOrder();
        order.AddItem("Keyboard", 120.00m); // This will fail because the order is shipped.
    }
}
```

Tip:

Nota sobre Métodos de Extensão: C# tem um recurso poderoso chamado métodos de extensão, que permite "adicionar" novos métodos a tipos existentes sem alterar seu código-fonte original. Por exemplo, você poderia criar um método `string.IsEmail()` que poderia ser chamado em qualquer string. Eles são amplamente utilizados no LINQ.

Tip:

Nota sobre Métodos Estáticos: Os métodos que vimos são métodos de instância, pois operam sobre o estado de um objeto específico (`order.ShipOrder()`). Existem também os métodos estáticos, que pertencem à classe em si e não a uma instância. Eles são chamados diretamente na classe (ex: `Math.Max(5, 10)`) e não podem acessar o estado de uma instância (como a propriedade `TotalAmount`).

## Referências Oficiais da Microsoft

* [Métodos (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/methods)

* [Passando Parâmetros (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters)

* [Sobrecarga de Método (Guia de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/proposals/csharp-7.2/method-overloading-improvements)



# Construtores

Em Programação Orientada a Objetos, um Construtor (do inglês, Constructor) é um método especial dentro de uma classe. Sua única e crítica responsabilidade é inicializar um novo objeto no momento em que ele é criado. Quando você usa a palavra-chave `new` para instanciar uma classe, é o construtor que é chamado para preparar o objeto para uso, definindo seu estado inicial e garantindo que ele "nasça" de forma válida e consistente.

Tip:

Dissertação: Pense no construtor como o controle de qualidade e a linha de montagem inicial de uma fábrica de objetos. Ele garante que nenhum objeto saia da linha de produção com peças faltando ou em um estado perigoso. Se uma classe `User` precisa de um `username` e `password` para ser válida, o construtor é o guardião que exige essas informações no momento da criação, impedindo a existência de um objeto `User` inválido no sistema. Um objeto nunca deve existir em um estado inconsistente, e o construtor é a principal ferramenta para garantir essa regra.

## A Anatomia de um Construtor

Construtores seguem regras de sintaxe bem específicas que os diferenciam de métodos comuns:

1. O nome do construtor deve ser exatamente o mesmo nome da classe.

2. Construtores não possuem um tipo de retorno, nem mesmo `void`.

```CSHARP
public class User
{
    // This is a constructor for the User class.
    public User(string username)
    {
        // Initialization logic goes here.
    }
}
```

### O Processo de Instanciação (Diagrama)

O que realmente acontece quando você escreve `new User("test")`? O diagrama de sequência abaixo ilustra o processo:

```PLANTUML
@startuml
' Settings to improve diagram appearance
skinparam sequenceArrowThickness 2
skinparam roundcorner 10
skinparam defaultFontName "Segoe UI, Arial"

actor "Client Code" as Client
participant "`new` Keyword" as New
participant "Constructor" as Ctor
participant "Memory (Heap)" as Heap

Client -> New : new User("test");
activate New #LightBlue

New -> Heap : 1. Allocate Memory
activate Heap #LightGreen
Heap --> New : Memory Address
deactivate Heap

New -> Ctor : 2. Invoke Constructor(args)
activate Ctor #LightYellow
Ctor -> Ctor : 3. Initialize object state
Ctor --> New : 
deactivate Ctor

New --> Client : 4. Return Reference (Address)
deactivate New

@enduml
```

## Padrões de Construtores em C#

Existem várias formas e padrões para se trabalhar com construtores, cada um com seu propósito.

### 1. Construtor Sem Parâmetros (Parameterless Constructor)

Este é o construtor mais básico. Ele pode existir de duas formas:

* Construtor Padrão (Implícito): Se você não declarar nenhum construtor em sua classe, o compilador do C# criará um para você. Este construtor é `public`, não tem parâmetros, e apenas inicializa os campos com seus valores padrão (`null`, `0`, `false`). ```CSHARP public class SimpleLogger { // No constructor is defined here, so the compiler adds one automatically: // public SimpleLogger() { } } // Usage: // This works because the compiler provided a default public constructor. var logger = new SimpleLogger(); ```

* Construtor Sem Parâmetros (Explícito): Você pode declarar seu próprio construtor sem parâmetros para executar uma lógica de inicialização específica. Tip: Nota Importante: No momento em que você declara qualquer outro construtor (com parâmetros), o compilador não gera mais o construtor padrão. Se você ainda quiser permitir a criação de um objeto sem passar parâmetros, deverá declarar o construtor sem parâmetros explicitamente. ```CSHARP public class CacheService { public int CacheDurationSeconds { get; set; } // An explicit parameterless constructor to set a default value. public CacheService() { // Set a default cache duration if none is provided. this.CacheDurationSeconds = 60; } // A parameterized constructor. public CacheService(int cacheDuration) { this.CacheDurationSeconds = cacheDuration; } } // Usage: // var defaultCache = new CacheService(); // CacheDurationSeconds will be 60 // var customCache = new CacheService(300); // CacheDurationSeconds will be 300 ```

### 2. Construtor com Parâmetros (Parameterized Constructor)

Esta é a forma mais comum e útil. Ao exigir parâmetros, o construtor força que o objeto seja criado com os dados essenciais para seu funcionamento, garantindo seu estado válido desde o início.

```CSHARP
public class Product
{
    public string Sku { get; private set; }

    // This constructor forces every product to be created with a SKU.
    // It's impossible to create a Product object without providing this information.
    public Product(string sku)
    {
        if (string.IsNullOrWhiteSpace(sku))
        {
            throw new ArgumentException("SKU cannot be empty.", nameof(sku));
        }
        this.Sku = sku;
    }
}
```

### 

3. Sobrecarga e Encadeamento de Construtores (`: this(...)`)

Para evitar a duplicação de código entre construtores sobrecarregados (múltiplos construtores na mesma classe), um construtor pode chamar outro usando a palavra-chave `: this(...)`. Isso centraliza a lógica de inicialização.

```CSHARP
public class DbConnection
{
    public string Server { get; private set; }
    public string Database { get; private set; }
    public int Timeout { get; private set; }

    // The "main" constructor with the most parameters, containing the core logic.
    public DbConnection(string server, string database, int timeout)
    {
        Console.WriteLine("Executing main constructor...");
        // Validation logic here...
        this.Server = server;
        this.Database = database;
        this.Timeout = timeout;
    }

    // Overload 1: This constructor calls the main one using ': this()' 
    // and provides a default value of 30 for the timeout.
    public DbConnection(string server, string database) : this(server, database, 30)
    {
        // This constructor's body can be empty because the work is delegated.
        Console.WriteLine("Executing overload with default timeout.");
    }
}
```

## Construtores em Cenários Avançados

### Construtores Privados e o Padrão Singleton

Se você declarar um construtor como `private`, você impede que a classe seja instanciada de fora. O uso mais clássico para isso é no Padrão de Projeto Singleton, que garante que exista apenas uma única instância de uma classe em toda a aplicação.

```CSHARP
public class ApplicationSettings
{
    // A single, static, private instance of the class itself.
    private static readonly ApplicationSettings _instance = new ApplicationSettings();

    public string ApiUrl { get; private set; }

    // The constructor is private, so no one outside this class can call 'new ApplicationSettings()'.
    private ApplicationSettings()
    {
        // In a real app, this would load settings from a file.
        Console.WriteLine("Private constructor called. Loading settings...");
        ApiUrl = "https://api.example.com";
    }

    // A public static method to get the single instance.
    public static ApplicationSettings GetInstance()
    {
        return _instance;
    }
}

// Usage:
// var settings1 = new ApplicationSettings(); // COMPILE ERROR!
// var settings1 = ApplicationSettings.GetInstance();
// var settings2 = ApplicationSettings.GetInstance(); // settings2 will be the exact same object as settings1.
```

### Construtores Estáticos

Uma classe pode ter um único construtor estático (`static MyClass()`). Ele não tem modificadores de acesso nem parâmetros. Ele é executado automaticamente pelo runtime apenas uma vez, antes da primeira instância da classe ser criada ou qualquer membro estático ser acessado. Sua função é inicializar os campos estáticos da classe.

```CSHARP
public class LogManager
{
    // A static field, shared across all parts of the application.
    private static readonly string _logFilePath;

    // The static constructor runs only once to initialize static fields.
    static LogManager()
    {
        Console.WriteLine("Static constructor called. Initializing log file path...");
        _logFilePath = $"logs/app_{DateTime.Now:yyyy-MM-dd}.log";
    }

    public static void Log(string message) { /* ... logic to write to _logFilePath ... */ }
}

// Usage:
// LogManager.Log("First message");  // Static constructor runs here.
// LogManager.Log("Second message"); // Static constructor does NOT run again.
```

### 

Construtores e Herança (`: base(...)`)

Em uma hierarquia de herança, o construtor de uma classe filha deve chamar um construtor da sua classe mãe. Isso garante que toda a cadeia de herança seja inicializada corretamente. A chamada é feita com a palavra-chave `: base(...)`.

```CSHARP
public abstract class BaseRepository
{
    protected readonly string _connectionString;

    // The base class requires a connection string to be created.
    protected BaseRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
}

public class UserRepository : BaseRepository
{
    // The derived class's constructor must call the base constructor
    // using ': base()' to pass the required connection string up the chain.
    public UserRepository(string connectionString) : base(connectionString)
    {
        // Now we can add initialization logic specific to UserRepository.
    }
}
```

## Referências Oficiais da Microsoft

* [Construtores (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/constructors)

* [Construtores Estáticos (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/static-constructors)



# Abstração: O Pilar da Simplicidade

A Abstração é um dos quatro pilares fundamentais da Programação Orientada a Objetos (OOP), ao lado do Encapsulamento, Herança e Polimorfismo. Em sua essência, o princípio da abstração consiste em ocultar os detalhes complexos e irrelevantes de implementação, expondo apenas as funcionalidades essenciais de um objeto ou sistema.

É um conceito que usamos o tempo todo em nosso dia a dia. Quando você dirige um carro, interage com uma interface simples: volante, pedais e câmbio. Você não precisa conhecer a mecânica da combustão interna, o funcionamento da transmissão ou a eletrônica embarcada para chegar ao seu destino. O carro, como sistema, abstrai toda essa complexidade para você.

Na programação, a abstração nos permite criar sistemas mais simples de usar e entender. Em vez de lidar com dezenas de operações de baixo nível, interagimos com objetos através de métodos e propriedades de alto nível, que nos fornecem o que precisamos sem nos sobrecarregar com o "como" aquilo é feito.

Em C#, a abstração é alcançada principalmente através de dois mecanismos: Classes Abstratas (`abstract class`) e Interfaces (`interface`).

## 

1. Classes Abstratas (`abstract class`)

Uma classe abstrata é uma classe especial que serve como um modelo base para outras classes. A principal característica de uma classe abstrata é que ela não pode ser instanciada diretamente. Ou seja, você não pode criar um objeto a partir dela usando `new`.

Ela funciona como um contrato parcial. Pode conter tanto métodos concretos (com implementação) quanto métodos abstratos (sem implementação). As classes que herdam de uma classe abstrata são obrigadas a fornecer a implementação para todos os métodos abstratos da base.

### Exemplo do Mundo Real: Sistema de Notificações

Imagine que estamos construindo um sistema que precisa enviar diferentes tipos de notificações: E-mail, SMS e Push. Todas essas notificações compartilham características e ações comuns, mas a forma de envio de cada uma é drasticamente diferente.

Este é um cenário perfeito para uma classe abstrata `Notification`.

```PLANTUML
@startuml
title Diagrama de Abstração: Notificações

skinparam classAttributeIconSize 0

abstract class Notification {
  + Recipient: string
  + SentDate: DateTime
  # Status: string

  + Notification(recipient: string)

  .. Métodos ..
  + {abstract} Send(message: string): bool
  + GetStatus(): string
}

note right of Notification::Send
  Este método é abstrato.
  Cada tipo de notificação
  deve implementar sua própria
  lógica de envio.
end note

class EmailNotification {
  + From: string
  + Send(message: string): bool
}

class SmsNotification {
  + PhoneNumber: string
  + Send(message: string): bool
}

Notification <|-- EmailNotification
Notification <|-- SmsNotification

@enduml
```

### Implementando em C#

Vamos traduzir o diagrama para código. Primeiro, a classe abstrata `Notification`.

```
// An abstract class cannot be instantiated directly.
// It serves as a base for other classes.
public abstract class Notification
{
    // It can have properties, both abstract and concrete.
    public string Recipient { get; private set; }
    public DateTime SentDate { get; protected set; }
    protected string Status { get; set; }

    // It can have a constructor, which is called by derived classes.
    public Notification(string recipient)
    {
        Recipient = recipient;
        Status = "Pending";
    }

    // An abstract method has no implementation (no body).
    // Derived classes MUST provide an implementation for this method.
    public abstract bool Send(string message);

    // An abstract class can also have concrete methods with implementation.
    // This logic is shared among all derived classes.
    public string GetStatus()
    {
        return $"Notification to {Recipient} is currently {Status}.";
    }
}
```

Agora, as classes concretas que herdam de `Notification` e implementam o método `Send`.

```
public class EmailNotification : Notification
{
    public string From { get; private set; }

    // The constructor of the derived class calls the base class constructor.
    public EmailNotification(string recipient, string from) : base(recipient)
    {
        From = from;
    }

    // We MUST override and implement the abstract method from the base class.
    public override bool Send(string message)
    {
        Console.WriteLine($"Sending EMAIL from {From} to {Recipient}: '{message}'");
        // In a real scenario, we would use an SMTP client here.
        SentDate = DateTime.UtcNow;
        Status = "Sent";
        return true;
    }
}

public class SmsNotification : Notification
{
    public string PhoneNumber { get; private set; }

    public SmsNotification(string recipientPhoneNumber) : base(recipientPhoneNumber)
    {
        PhoneNumber = recipientPhoneNumber;
    }

    public override bool Send(string message)
    {
        Console.WriteLine($"Sending SMS to {PhoneNumber}: '{message}'");
        // In a real scenario, we would use a service like Twilio here.
        SentDate = DateTime.UtcNow;
        Status = "Sent";
        return true;
    }
}
```

Com essa estrutura, a classe `Notification` define um contrato (`Send` deve existir) e fornece funcionalidade comum (`GetStatus`), enquanto as classes filhas se preocupam apenas com os detalhes específicos de sua implementação.

## 

2. Interfaces (`interface`)

Uma interface é a forma mais pura de abstração. Ela é um contrato completo, que define um conjunto de assinaturas de métodos, propriedades, eventos ou indexadores. Uma interface não contém nenhuma implementação.

Se uma classe ou struct implementa uma interface, ela garante que fornecerá uma implementação para todos os membros definidos naquela interface.

Tip:

Nota sobre C# 8.0+: A partir do C# 8.0, as interfaces podem ter implementações padrão para métodos. Isso é um recurso avançado, usado para adicionar novos membros a interfaces existentes sem quebrar as classes que já a implementam. No entanto, o propósito primário de uma interface continua sendo a definição de um contrato sem implementação.

### Exemplo do Mundo Real: Repositório de Dados

Vamos pensar em um sistema que precisa salvar e recuperar dados. Esses dados podem vir de um banco de dados SQL Server, de um arquivo de texto, de uma API externa ou simplesmente de uma lista em memória (para testes). A lógica de negócio do nosso sistema não deveria se importar com onde os dados estão, apenas com o contrato de como interagir com eles: `GetById`, `GetAll`, `Add`, `Delete`.

```PLANTUML
@startuml
title Diagrama de Abstração: Repositório

skinparam classAttributeIconSize 0

interface "IRepository<T>" as IRepository {
  + {abstract} GetById(id: object): T
  + {abstract} GetAll(): IEnumerable<T>
  + {abstract} Add(entity: T): void
  + {abstract} Update(entity: T): void
  + {abstract} Delete(entity: T): void
}

note left of IRepository
  Uma interface define um
  contrato de "capacidades".
  Qualquer classe que implementa
  IRepository<T> "pode" realizar
  operações de dados.
end note

class SqlProductRepository {
  + GetById(id: object): Product
  + GetAll(): IEnumerable<Product>
  + Add(entity: Product): void
  + ...
}

class InMemoryProductRepository {
  - _products: List<Product>
  + GetById(id: object): Product
  + GetAll(): IEnumerable<Product>
  + Add(entity: Product): void
  + ...
}

IRepository <|.. SqlProductRepository
IRepository <|.. InMemoryProductRepository

@enduml
```

### Implementando em C#

Primeiro, a interface `IRepository<T>`. A convenção em C# é prefixar nomes de interface com a letra `I`.

```
// An interface is a pure contract. It only defines "what" a class can do,
// not "how" it does it.
// Here, we use generics (<T>) to make the repository work with any data type.
public interface IRepository<T>
{
    T GetById(Guid id);
    IEnumerable<T> GetAll();
    void Add(T entity);
    void Update(T entity);
    void Delete(T entity);
}
```

Agora, duas implementações concretas para um `Product`.

```
// Dummy Product class for the example
public class Product { public Guid Id { get; set; } public string Name { get; set; } }

// Implementation using a SQL database (simulated)
public class SqlProductRepository : IRepository<Product>
{
    public void Add(Product entity)
    {
        Console.WriteLine($"SQL: Inserting product '{entity.Name}' into the database.");
    }

    // ... other methods (GetById, GetAll, etc.) would be implemented here
    // with actual database logic using Dapper, EF Core, etc.
}

// Implementation using an in-memory list (useful for tests)
public class InMemoryProductRepository : IRepository<Product>
{
    private readonly List<Product> _products = new List<Product>();

    public void Add(Product entity)
    {
        Console.WriteLine($"MEMORY: Adding product '{entity.Name}' to the in-memory list.");
        _products.Add(entity);
    }

    // ... other methods implemented here, manipulating the _products list.
}
```

O poder disso é que a nossa aplicação pode depender da interface `IRepository<T>`, e podemos "injetar" a implementação que quisermos (SQL em produção, memória em testes) sem mudar uma linha sequer da lógica de negócio. Isso é a base para injeção de dependência e código de baixo acoplamento.

## Classe Abstrata vs. Interface: Qual Usar?

Esta é uma dúvida clássica. A escolha depende do seu objetivo.

| Característica |Classe Abstrata |Interface |
----------------------------------------------
| Herança |Uma classe só pode herdar de uma classe abstrata. |Uma classe pode implementar múltiplas interfaces. |
| Conteúdo |Pode ter implementação de métodos, campos, construtores. |Geralmente, apenas assinaturas. Define um contrato puro. |
| Relação |Define uma relação "é um". Ex: `EmailNotification` é uma `Notification`. |Define uma relação "pode fazer". Ex: `SqlRepository` pode fazer as operações de `IRepository`. |
| Propósito |Compartilhar código e definir um modelo base comum para classes relacionadas. |Definir capacidades que podem ser implementadas por classes não relacionadas. |

* Use uma classe abstrata quando: Você tem um conjunto de classes intimamente relacionadas e quer compartilhar código (lógica comum) entre elas. A classe base estabelece um parentesco forte.

* Use uma interface quando: Você quer definir uma capacidade que pode ser implementada por classes completamente diferentes. Por exemplo, `Carro`, `Pessoa` e `Cachorro` podem implementar a interface `IMovivel`, mas não têm uma relação de parentesco entre si.

## Conclusão

A abstração é uma ferramenta poderosa para gerenciar a complexidade. Ao criar abstrações com classes abstratas e interfaces, nós separamos o "o quê" (a interface pública, o contrato) do "como" (os detalhes de implementação). Isso leva a um código mais limpo, flexível, testável e de fácil manutenção, permitindo que os sistemas evoluam de forma muito mais segura e desacoplada.

Tip:

### Referências Oficiais

* [Classes Abstratas e Seladas e Membros de Classe (Guia de C#)](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members)

* [Interfaces (Guia de C#)](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/interface)



# Encapsulamento: A Cápsula Protetora do Código

O Encapsulamento é o segundo grande pilar da Programação Orientada a Objetos (OOP). O nome é bastante descritivo: ele se refere à prática de agrupar dados (atributos) e os métodos (comportamentos) que operam nesses dados em uma única unidade, a `classe`.

Mas o encapsulamento vai além do simples agrupamento. Seu objetivo principal é proteger o estado interno de um objeto, restringindo o acesso direto aos seus dados. Pense nele como uma cápsula de remédio: o invólucro (a classe) protege o conteúdo (os dados) do ambiente externo. Você não interage com o pó diretamente; você consome a cápsula, que sabe como e quando liberar seu conteúdo de forma segura.

No mundo do software, isso significa que um objeto deve esconder sua complexidade interna e expor apenas as operações necessárias e seguras para o mundo exterior. Ele se torna uma "caixa-preta" responsável por gerenciar seu próprio estado.

## Por Que o Encapsulamento é Vital?

Sem encapsulamento, o estado de um objeto ficaria vulnerável. Qualquer parte do sistema poderia modificar seus dados internos, levando a inconsistências, bugs e comportamentos inesperados.

Imagine uma classe `BankAccount` (Conta Bancária) onde o saldo é um campo público:

```
// An example of what NOT to do.
public class UnsafeBankAccount
{
    // Public field - anyone can access and modify it directly.
    public decimal balance;
    public string accountHolder;
}

public class MainProgram
{
    public void Run()
    {
        var myAccount = new UnsafeBankAccount();
        myAccount.accountHolder = "John Doe";
        myAccount.balance = 100.00m;

        // Another part of the code, maybe written by another developer,
        // can do this, corrupting the object's state.
        myAccount.balance = -99999.99m; // The balance should never be negative!
    }
}
```

No exemplo acima, quebramos uma regra de negócio fundamental: o saldo de uma conta não pode ser negativo. Como o campo `balance` é público, a classe `UnsafeBankAccount` não tem nenhum controle sobre seu próprio estado. Ela é apenas um saco de dados passivo.

O encapsulamento resolve isso, trazendo três benefícios principais:

1. Integridade e Controle: A classe passa a controlar como seus dados são acessados e modificados, permitindo a aplicação de regras de validação e lógica de negócio.

2. Flexibilidade e Manutenção: A implementação interna da classe pode ser alterada sem quebrar o código que a utiliza. Desde que a "interface pública" (seus métodos e propriedades) permaneça a mesma, podemos refatorar o interior da classe com segurança.

3. Redução da Complexidade: Oculta os detalhes de implementação, tornando a classe mais fácil de usar. Quem usa a classe não precisa saber como ela funciona por dentro, apenas o que ela faz.

## Alcançando o Encapsulamento em C#

Em C#, o encapsulamento é implementado através da combinação de Modificadores de Acesso e Propriedades.

### 1. Modificadores de Acesso

Eles definem o nível de "visibilidade" dos membros de uma classe.

* `public`: O membro é acessível de qualquer lugar.

* `private`: O membro só pode ser acessado de dentro da própria classe. Esta é a chave para esconder os dados.

* `protected`: O membro pode ser acessado de dentro da própria classe e de classes que herdam dela.

* `internal`: O membro é acessível apenas dentro do mesmo projeto (assembly).

A regra de ouro do encapsulamento é: manter os dados (campos) `private` e expor as operações (métodos e propriedades) como `public`.

### 2. Propriedades (Properties)

As propriedades são a maneira idiomática do C# de expor os campos privados de forma controlada. Elas parecem campos para quem usa a classe, mas na verdade são métodos especiais (`get` e `set`).

Vamos refatorar nossa conta bancária usando os princípios do encapsulamento.

```PLANTUML
@startuml
title Diagrama de Encapsulamento: BankAccount

skinparam classAttributeIconSize 0

class BankAccount {
  .. Estado Interno (Protegido) ..
  - _balance: decimal
  - _accountHolder: string

  .. Interface Pública (Controlada) ..
  + AccountHolder: string <<get>>
  + Balance: decimal <<get>>

  + BankAccount(accountHolder: string, initialDeposit: decimal)

  + Deposit(amount: decimal): void
  + Withdraw(amount: decimal): bool
}

note right of BankAccount::_balance
  O campo _balance é **privado**.
  Só pode ser modificado pelos
  métodos da própria classe, como
  Deposit() e Withdraw(), que
  contêm as regras de negócio.
end note

@enduml
```

### 

Implementando a Classe `BankAccount` Corretamente

```
public class BankAccount
{
    // 1. Data (fields) are private. The state is protected.
    private decimal _balance;
    private readonly string _accountHolder;

    // 2. Public properties provide controlled access to the data.
    // The Balance property is "read-only" to the outside world.
    // It has a 'get' accessor, but no 'set' accessor.
    public decimal Balance => _balance;

    // This property can also be made read-only from the outside.
    public string AccountHolder => _accountHolder;

    // 3. The constructor ensures the object is created in a valid state.
    public BankAccount(string accountHolder, decimal initialDeposit)
    {
        if (string.IsNullOrWhiteSpace(accountHolder))
        {
            // We can throw an exception to prevent creating an invalid object.
            throw new ArgumentException("Account holder name cannot be empty.", nameof(accountHolder));
        }

        if (initialDeposit < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(initialDeposit), "Initial deposit cannot be negative.");
        }

        _accountHolder = accountHolder;
        _balance = initialDeposit;
    }

    // 4. Public methods define the valid operations that can change the object's state.
    public void Deposit(decimal amount)
    {
        if (amount <= 0)
        {
            // The class protects its own state by validating the input.
            throw new ArgumentOutOfRangeException(nameof(amount), "Deposit amount must be positive.");
        }
        _balance += amount;
    }

    public bool Withdraw(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(amount), "Withdrawal amount must be positive.");
        }

        // The class enforces its own business rules.
        if (_balance >= amount)
        {
            _balance -= amount;
            return true; // Withdrawal was successful
        }
        
        Console.WriteLine("Insufficient funds.");
        return false; // Withdrawal failed
    }
}
```

### Usando a Classe Encapsulada

Agora, o código que utiliza a classe `BankAccount` não pode mais corromper seu estado. Ele é forçado a usar a interface pública segura que a classe oferece.

```
public class MainProgram
{
    public void Run()
    {
        // The object is created in a valid state through the constructor.
        var myAccount = new BankAccount("Jane Doe", 100.00m);

        Console.WriteLine($"Holder: {myAccount.AccountHolder}, Initial Balance: {myAccount.Balance:C}");

        // We interact with the object through its public methods.
        myAccount.Deposit(50.00m);
        Console.WriteLine($"Balance after deposit: {myAccount.Balance:C}");

        myAccount.Withdraw(30.00m);
        Console.WriteLine($"Balance after withdrawal: {myAccount.Balance:C}");

        // Any attempt to directly modify the balance will result in a COMPILE ERROR.
        // myAccount.Balance = 5000.00m; // <-- This line won't compile!

        // The object protects itself from invalid operations.
        try
        {
            myAccount.Deposit(-20.00m); // This will throw an exception.
        }
        catch (ArgumentOutOfRangeException ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }

        Console.WriteLine($"Final Balance: {myAccount.Balance:C}");
    }
}
```

## Conclusão

O Encapsulamento é um princípio de design fundamental que torna nosso código mais robusto, seguro e fácil de manter. Ao tratar objetos como entidades autônomas que são responsáveis por seu próprio estado, nós criamos blocos de construção confiáveis.

Lembre-se da regra principal: esconda os dados, exponha os comportamentos. Mantenha seus campos `private` e forneça acesso controlado através de propriedades `public` e métodos `public`. Ao fazer isso, você estará no caminho certo para escrever software de alta qualidade em C#.

Tip:

### Referências Oficiais

* [Propriedades (Guia de C#)](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/properties)

* [Modificadores de Acesso (Guia de C#)](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)



# Herança: Reutilização e Estrutura

A Herança é um dos quatro pilares fundamentais e mais poderosos da Programação Orientada a Objetos (POO). Em sua essência, a herança é um mecanismo que permite a uma nova classe — que chamamos de classe filha ou derivada — ser baseada em uma classe já existente — a classe mãe ou base. Ao fazer isso, a classe derivada herda (adquire) todos os membros públicos e protegidos (atributos e métodos) da classe base, como se fossem seus.

O conceito central que a herança modela no mundo do software é o relacionamento "é um(a)". Esta não é apenas uma frase bonita, é a verificação lógica que você deve fazer ao decidir usar herança. Por exemplo:

* Um `Gerente` é um `Funcionario`.

* Um `Carro` é um `Veiculo`.

* Uma `EmailNotification` é uma `Notification`.

Essa estruturação não se trata apenas de copiar e colar código. Trata-se de estabelecer uma relação formal, lógica e forte entre os tipos do seu sistema. Isso permite criar hierarquias de classes que são intuitivas, fáceis de manter e, crucialmente, que abrem as portas para o polimorfismo.

## Os Pilares da Motivação para Herança

Por que nos damos ao trabalho de criar essas hierarquias? A herança não é apenas um recurso da linguagem; ela resolve problemas fundamentais da engenharia de software.

1. Reutilização de Código (Code Reusability)
Este é o benefício mais imediato e óbvio. Em vez de duplicar lógica em múltiplas classes, você a centraliza na classe base. Imagine que você tem as classes `Cliente`, `Funcionario` e `Fornecedor`. Todas elas precisam de `Id`, `Nome` e `DataDeCadastro`. Em vez de repetir esses três campos em cada classe, você pode criar uma classe base `Pessoa` que os contenha. `Cliente`, `Funcionario` e `Fornecedor` então herdam de `Pessoa` e reutilizam essa estrutura.

Tip:

Dissertação: A verdadeira vitória aqui não é apenas digitar menos. É criar uma única fonte de verdade (Single Source of Truth). Se, no futuro, você decidir que todo `Id` deve ser um `Guid` em vez de um `int`, ou que a lógica de validação do `Nome` precisa mudar, você altera isso em um único lugar: a classe `Pessoa`. Todas as classes filhas instantaneamente herdam a melhoria. Isso reduz drasticamente o custo de manutenção e a probabilidade de bugs.

2. Organização e Modelagem do Domínio (Domain Modeling)
A herança permite que a estrutura do seu código espelhe a estrutura do problema do mundo real que você está tentando resolver (o seu "domínio"). Se você está construindo um software para uma transportadora, seu código terá classes como `Veiculo`, `Caminhao`, `Van`, `Carro`, formando uma hierarquia que qualquer pessoa da empresa consegue entender. O código se torna um modelo do negócio, tornando-o mais fácil de raciocinar, discutir e evoluir.

3. Habilitação do Polimorfismo (Enabling Polymorphism)
A herança é a fundação sobre a qual o pilar do Polimorfismo é construído. Como uma `EmailNotification` é uma `Notification`, a herança permite que você trate um objeto da classe filha como se ele fosse um objeto da classe mãe. Isso significa que você pode, por exemplo, criar uma lista de `Notification` (`List<Notification>`) e adicionar nela objetos dos tipos `EmailNotification`, `SmsNotification` e `PushNotification`.

Tip:

Nota: O Polimorfismo é um tópico próprio e igualmente importante, mas é impossível justificar a herança sem mencionar que ela é o que torna o polimorfismo possível. A capacidade de escrever código genérico que opera sobre uma classe base, e confiar que o comportamento correto da classe derivada será executado, é uma das técnicas mais poderosas em POO.

## Diagramando a Herança com PlantUML

Visualizar a hierarquia de classes é uma forma excelente de entender a estrutura do código antes mesmo de escrevê-lo. Usaremos a ferramenta PlantUML para desenhar a hierarquia do nosso exemplo prático: um sistema de notificações.

```PLANTUML
@startuml
' Settings to improve diagram appearance
skinparam classAttributeIconSize 0
skinparam monochrome true
skinparam classBackgroundColor White
skinparam classArrowColor Black
skinparam classBorderColor Black

' The abstract base class
abstract class Notification {
  ' Public members (+)
  + Id : Guid
  ' Protected members (#)
  # SentAt : DateTime
  # WasSent : bool
  ' Protected constructor (#)
  # Notification()
  ' Abstract method (must be implemented by children)
  + <<abstract>> Send() : void
}

' First derived class
class EmailNotification {
  + RecipientEmail : string
  + Subject : string
  + EmailNotification(recipientEmail, subject)
  ' Overridden method (custom implementation)
  + <<override>> Send() : void
}

' Second derived class
class SmsNotification {
  + PhoneNumber : string
  + SmsNotification(phoneNumber)
  + <<override>> Send() : void
}

' The arrow indicates that the child class inherits from the parent class
Notification <|-- EmailNotification
Notification <|-- SmsNotification
@enduml
```

Interpretando o Diagrama:

* `abstract class Notification`: A palavra-chave `abstract` e o nome em itálico indicam que `Notification` é uma classe conceitual que não pode ser instanciada diretamente.

* `+`, `#`: Indicam os modificadores de acesso. `+` é `public` (totalmente visível) e `#` é `protected` (visível para a classe e suas filhas).

* `<<abstract>>` e `<<override>>`: São "estereótipos" que nos dão mais informações sobre os métodos. `<<abstract>>` indica um método que deve ser implementado, e `<<override>>` indica um método que está fornecendo essa implementação.

* `Notification <|-- EmailNotification`: Esta é a representação visual da herança. A seta de triângulo vazia aponta da classe filha para a classe mãe. Leia-se: "EmailNotification herda de Notification".

## Implementando Herança em C#: Uma Análise Técnica

Agora, vamos traduzir o diagrama e os conceitos para código C#, explicando cada palavra-chave envolvida.

### 

A Sintaxe de Herança: O Operador `:`

Para declarar que uma classe herda de outra, você usa o operador de dois pontos (`:`) após o nome da classe filha, seguido pelo nome da classe mãe.

`public class EmailNotification : Notification`

Esta simples linha estabelece formalmente que `EmailNotification` é uma `Notification` e herda seus membros.

### Palavras-chave Essenciais para Herança

| Palavra-chave |Propósito na Classe Mãe |Propósito na Classe Filha |
---------------------------------------------------------------------
| `abstract` |Declara que a classe é um conceito e não pode ser instanciada. Pode conter métodos `abstract` (sem corpo). |- |
| `virtual` |Declara um método com uma implementação padrão, mas que pode ser sobrescrito pelas classes filhas. |- |
| `override` |- |Fornece uma nova implementação para um método `abstract` ou `virtual` da classe mãe. |
| `protected` |Declara um membro que é `private` para o mundo exterior, mas `public` para qualquer classe filha. |Permite o acesso a membros `protected` da classe mãe. |
| `base` |- |Usado para acessar membros da classe mãe, seja seu construtor (`: base()`) ou seus métodos (`base.Metodo()`). |
| `sealed` |- |Declara que a classe não pode mais ser herdada por nenhuma outra classe. Ela encerra a cadeia de herança. |

### Exemplo Prático: O Código do Sistema de Notificações

Este código implementa exatamente o que foi projetado no diagrama PlantUML.

```CSHARP
// using System; // Required for Guid, DateTime, etc.
// using System.Collections.Generic; // Required for List<T>

// THE ABSTRACT BASE CLASS
// 'abstract' means this class is a concept and cannot be created directly.
// E.g., you cannot do 'new Notification()'.
public abstract class Notification
{
    // A Guid (Globally Unique Identifier) is a 128-bit almost-unique number,
    // ideal for use as a database ID.
    public Guid Id { get; private set; }

    // 'protected' means this member can only be accessed by this class
    // or by classes that inherit from it (EmailNotification, SmsNotification).
    protected DateTime SentAt { get; set; }
    protected bool WasSent { get; set; }

    // Protected constructor. Can only be called by this class or its derivatives.
    protected Notification()
    {
        Id = Guid.NewGuid();
        WasSent = false;
    }

    // An 'abstract' method is a contract. It has no implementation here.
    // Every derived class IS FORCED to implement its own version of this method.
    public abstract void Send();
}

// A DERIVED CLASS
public class EmailNotification : Notification // Inheritance happens here
{
    public string RecipientEmail { get; private set; }
    public string Subject { get; private set; }

    public EmailNotification(string recipientEmail, string subject)
    {
        // Note that the base class constructor (Notification) is called implicitly here.
        RecipientEmail = recipientEmail;
        Subject = subject;
    }

    // 'override' fulfills the contract defined by the 'abstract' method in the parent class.
    // This is the SPECIFIC implementation of Send() for an email.
    public override void Send()
    {
        Console.WriteLine($"Sending email to '{RecipientEmail}' with subject '{Subject}'.");
        // The derived class can access the 'protected' members of the base class.
        this.SentAt = DateTime.UtcNow;
        this.WasSent = true;
        Console.WriteLine("Email sent successfully.");
    }
}

// ANOTHER DERIVED CLASS
public class SmsNotification : Notification
{
    public string PhoneNumber { get; private set; }

    // Here we explicitly call the base class constructor with ': base()'
    // It's not strictly necessary in this case, but it's good practice to be clear.
    public SmsNotification(string phoneNumber) : base()
    {
        PhoneNumber = phoneNumber;
    }

    public override void Send()
    {
        Console.WriteLine($"Sending SMS to '{this.PhoneNumber}'.");
        this.SentAt = DateTime.UtcNow;
        this.WasSent = true;
        Console.WriteLine("SMS sent successfully.");
    }
}

public class NotificationService
{
    public static void Main()
    {
        var email = new EmailNotification("test@example.com", "Your order has shipped!");
        var sms = new SmsNotification("+1234567890");

        // Inheritance allows us to use Polymorphism.
        // We create a list of the BASE class, but we populate it with CHILD classes.
        var notificationsToSend = new List<Notification> { email, sms };

        Console.WriteLine("--- Processing notifications ---");
        foreach (var notification in notificationsToSend)
        {
            // The correct version of .Send() is called for each object!
            notification.Send();
            Console.WriteLine("--------------------------------");
        }
    }
}
```

Tip:

Nota sobre Herança Múltipla: Diferente de algumas outras linguagens (como C++), o C# não permite herança múltipla de classes. Uma classe só pode herdar diretamente de uma única classe base. Isso é uma decisão de design para evitar um problema complexo chamado "Problema do Diamante". A funcionalidade de herança múltipla em C# é alcançada através de Interfaces, que permitem que uma classe "assine múltiplos contratos".

## Referências Oficiais da Microsoft

Para um estudo ainda mais aprofundado, a documentação oficial é a melhor fonte de informação.

* [Herança (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/fundamentals/object-oriented/inheritance)

* [Palavra-chave abstract](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/abstract)

* [Palavras-chave virtual e override](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/virtual)



# Polimorfismo: As Muitas Formas do seu Código

Polimorfismo, do grego "muitas formas" (poly = muitas, morphos = formas), é o quarto e talvez o mais poderoso pilar da Programação Orientada a Objetos (OOP). Ele é o princípio que permite que objetos de diferentes classes, que compartilham uma mesma superclasse ou implementam uma mesma interface, respondam à mesma mensagem (chamada de método) de maneiras específicas e diferentes.

Em termos mais simples, o polimorfismo permite que você trate uma variedade de objetos diferentes de maneira uniforme. Você pode ter uma coleção de objetos distintos e chamar o mesmo método em cada um deles, e cada objeto executará a ação de uma forma que faz sentido para ele. É o conceito que dá vida à abstração e à herança.

Vamos usar uma analogia. Pense em um botão "Play" em um controle remoto universal. Este controle pode operar uma TV, um aparelho de Blu-ray e um sistema de som. O botão "Play" é a interface comum.

* Ao apontar para a TV e pressionar "Play", ele pode iniciar a reprodução de um arquivo de mídia via USB.

* Ao apontar para o Blu-ray e pressionar "Play", ele inicia a reprodução do disco.

* Ao apontar para o sistema de som e pressionar "Play", ele começa a tocar uma rádio online.

A ação é a mesma (`Play`), mas o resultado (o comportamento) é diferente dependendo do objeto que recebe o comando. Isso é polimorfismo.

## Como o Polimorfismo Funciona em C#

Em C#, o polimorfismo é tipicamente alcançado através da combinação de herança (ou implementação de interface) com métodos virtuais e sobrescritos.

Os ingredientes essenciais são:

1. Uma classe base (ou interface) que define um método como `virtual` ou `abstract`.

* `virtual`: O método na classe base tem uma implementação padrão, mas pode ser substituído por uma classe derivada.

* `abstract`: O método na classe base não tem implementação. Ele deve ser implementado por uma classe derivada.

2. Uma ou mais classes derivadas que sobrescrevem (`override`) esse método, fornecendo sua própria implementação específica.

3. Uma referência da classe base que aponta para um objeto da classe derivada. É aqui que a mágica acontece: você chama o método através da referência da base, e o .NET runtime determina em tempo de execução qual a implementação correta a ser executada (a da classe derivada).

### Exemplo do Mundo Real: Um Sistema de Renderização de Documentos

Imagine que estamos construindo um editor de texto. Este editor precisa renderizar diferentes elementos em uma página: parágrafos de texto, imagens, tabelas, etc. Cada elemento precisa ser "desenhado" na tela, mas a lógica para desenhar um texto é muito diferente da lógica para desenhar uma imagem.

```PLANTUML
@startuml
title Diagrama de Polimorfismo: Renderização de Documentos

skinparam classAttributeIconSize 0

abstract class DocumentElement {
  + PositionX: int
  + PositionY: int
  + {abstract} Draw(): void
}

note right of DocumentElement::Draw
  O método Draw() é abstrato.
  Ele define o **contrato**: todo
  elemento de documento "pode ser desenhado".
  Mas o **como** é responsabilidade das
  classes filhas.
end note

class Paragraph {
  + Text: string
  + Font: string
  + Draw(): void
}

class Image {
  + SourcePath: string
  + Width: int
  + Height: int
  + Draw(): void
}

class Table {
  + Rows: int
  + Columns: int
  + Draw(): void
}

DocumentElement <|-- Paragraph
DocumentElement <|-- Image
DocumentElement <|-- Table

class DocumentRenderer {
  + Render(elements: List<DocumentElement>): void
}

DocumentRenderer ..> DocumentElement : uses

@enduml
```

### Implementando em C#

Primeiro, nossa classe base abstrata `DocumentElement`.

```
// The abstract base class defines the common contract.
public abstract class DocumentElement
{
    public int PositionX { get; set; }
    public int PositionY { get; set; }

    // This is the polymorphic method. It's abstract, so derived classes MUST implement it.
    public abstract void Draw();
}
```

Agora, as classes concretas. Cada uma fornece sua própria implementação para o método `Draw`.

```
public class Paragraph : DocumentElement
{
    public string Text { get; set; }

    // We override the base class method to provide a specific implementation.
    public override void Draw()
    {
        Console.WriteLine($"Drawing a paragraph at ({PositionX},{PositionY}): '{Text}'");
    }
}

public class Image : DocumentElement
{
    public string SourcePath { get; set; }

    public override void Draw()
    {
        Console.WriteLine($"Drawing an image from '{SourcePath}' at ({PositionX},{PositionY}).");
    }
}

public class Table : DocumentElement
{
    public int Rows { get; set; }
    public int Columns { get; set; }

    public override void Draw()
    {
        Console.WriteLine($"Drawing a {Rows}x{Columns} table at ({PositionX},{PositionY}).");
    }
}
```

### A Mágica do Polimorfismo em Ação

O poder do polimorfismo se torna evidente quando temos uma classe que precisa operar sobre esses objetos, como um `DocumentRenderer`. Este renderizador não precisa conhecer os detalhes de `Paragraph`, `Image` ou `Table`. Ele só precisa saber que todos eles são `DocumentElement` e que, portanto, todos têm um método `Draw`.

```
public class DocumentRenderer
{
    // This method accepts a list of ANY object that IS A DocumentElement.
    public void Render(List<DocumentElement> elements)
    {
        Console.WriteLine("--- Starting Document Rendering ---");
        foreach (var element in elements)
        {
            // This is polymorphism!
            // We call the same method, Draw(), on every object.
            // The .NET runtime checks the actual type of 'element' at runtime
            // and calls the correct overridden version of Draw().
            element.Draw();
        }
        Console.WriteLine("--- Document Rendering Finished ---");
    }
}

public class Program
{
    public static void Main()
    {
        // Create a list of different document elements.
        // Note that the list type is of the base class.
        var documentParts = new List<DocumentElement>
        {
            new Paragraph { Text = "This is the first paragraph.", PositionX = 10, PositionY = 20 },
            new Image { SourcePath = "/images/logo.png", PositionX = 10, PositionY = 50 },
            new Table { Rows = 3, Columns = 4, PositionX = 10, PositionY = 150 },
            new Paragraph { Text = "This is a second paragraph, after the image and table.", PositionX = 10, PositionY = 250 }
        };

        var renderer = new DocumentRenderer();
        
        // Pass the list to the renderer.
        // The renderer doesn't know or care about the specific types in the list.
        renderer.Render(documentParts);
    }
}
```

O laço `foreach` dentro do método `Render` é o coração do polimorfismo. A variável `element` é do tipo `DocumentElement`, mas a cada iteração, ela aponta para um objeto de um tipo concreto diferente (`Paragraph`, `Image`, etc.). A chamada `element.Draw()` invoca a versão correta e sobrescrita do método, de acordo com o objeto real na memória naquele momento.

## Benefícios do Polimorfismo

1. Extensibilidade: Podemos adicionar novos tipos de `DocumentElement` (como `Video`, `Chart`, etc.) ao nosso sistema sem precisar mudar uma linha sequer da classe `DocumentRenderer`. Basta criar a nova classe, herdar de `DocumentElement` e implementar o método `Draw`. Isso está diretamente ligado ao Princípio do Aberto/Fechado (Open/Closed Principle).

2. Código Desacoplado: O `DocumentRenderer` não está acoplado às implementações concretas. Ele depende apenas da abstração (`DocumentElement`), tornando o sistema mais flexível e fácil de manter.

3. Simplicidade: O código cliente (como o `DocumentRenderer`) se torna muito mais simples. Em vez de ter um `if-else` ou `switch` gigante para tratar cada tipo de elemento, ele simplesmente trata todos da mesma forma.

## Conclusão

O Polimorfismo é o que permite que nossas abstrações ganhem vida. Ele nos capacita a escrever código que opera em termos de contratos (classes base ou interfaces) em vez de implementações concretas. Ao fazer isso, criamos sistemas que não são apenas mais fáceis de entender e manter, mas também incrivelmente flexíveis e extensíveis, prontos para se adaptar a novos requisitos com o mínimo de esforço.

Tip:

### Referências Oficiais

* [Polimorfismo (Guia de C#)](https://docs.microsoft.com/pt-br/dotnet/csharp/fundamentals/object-oriented/polymorphism)

* [Palavras-chave virtual e override](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/override)



# Sobrecarga de Métodos (Method Overloading)

A Sobrecarga de Métodos (em inglês, Method Overloading) é um recurso da Programação Orientada a Objetos que permite a uma classe ter dois ou mais métodos com o mesmo nome, desde que suas assinaturas de parâmetros sejam diferentes.

É uma forma de polimorfismo que acontece em tempo de compilação (polimorfismo estático). O compilador do C# é inteligente o suficiente para saber qual versão do método chamar com base nos argumentos que você fornece na chamada.

O principal objetivo da sobrecarga é fornecer maneiras mais flexíveis e intuitivas de se chamar uma mesma operação, sem a necessidade de se inventar nomes diferentes para ações que são conceitualmente idênticas. Ela aumenta a legibilidade e a usabilidade de uma classe.

## As Regras da Sobrecarga

Para que a sobrecarga seja válida, as assinaturas dos métodos devem ser únicas. A assinatura de um método é composta por:

1. O nome do método.

2. O número de parâmetros.

3. O tipo e a ordem dos parâmetros.

4. Os modificadores de parâmetro (`ref`, `out`, `in`).

Tip:

Ponto Crítico: O tipo de retorno de um método NÃO faz parte de sua assinatura. Você não pode sobrecarregar um método apenas mudando seu tipo de retorno. O compilador não saberia qual deles chamar.

```CSHARP
public class Calculator
{
    // Valid Overloads
    public int Add(int a, int b) { return a + b; }
    public double Add(double a, double b) { return a + b; } // Different parameter types
    public int Add(int a, int b, int c) { return a + b + c; } // Different number of parameters

    // Invalid Overload - COMPILE ERROR!
    // The signature 'Add(int, int)' is already defined.
    // The return type does not differentiate the signature.
    // public double Add(int a, int b) { return (double)(a + b); }
}
```

## Exemplo do Mundo Real: Uma Classe de Log

Um dos exemplos mais clássicos e úteis de sobrecarga é uma classe de logging. Um sistema pode precisar registrar diferentes tipos de informação: uma simples mensagem de texto, uma mensagem com um nível de severidade (Info, Warning, Error) ou um objeto de exceção completo.

```PLANTUML
@startuml
title Diagrama de Sobrecarga: Logger

skinparam classAttributeIconSize 0

enum LogLevel {
  Info
  Warning
  Error
}

class Logger {
  + Log(message: string): void
  + Log(message: string, level: LogLevel): void
  + Log(ex: Exception): void
}

Logger ..> LogLevel : uses
Logger ..> Exception : uses

note right of Logger::Log
  Três sobrecargas do método 'Log'.
  O compilador escolhe a versão correta
  com base nos argumentos fornecidos
  na chamada do método.
end note

@enduml
```

### 

Implementando a Classe `Logger`

```CSHARP
public enum LogLevel
{
    Info,
    Warning,
    Error
}

public class Logger
{
    // Overload 1: For simple string messages. Defaults to Info level.
    public void Log(string message)
    {
        // This overload calls another one to avoid code duplication.
        // This is a very common and recommended practice.
        Log(message, LogLevel.Info);
    }

    // Overload 2: The main overload with message and level.
    public void Log(string message, LogLevel level)
    {
        // In a real system, this would write to a file, database, or console.
        Console.WriteLine($"[{level.ToString().ToUpper()}] - {DateTime.UtcNow} - {message}");
    }

    // Overload 3: For logging exception objects.
    public void Log(Exception ex)
    {
        // This provides a structured way to log exceptions.
        string formattedMessage = $"An exception occurred.\nType: {ex.GetType().Name}\nMessage: {ex.Message}\nStackTrace:\n{ex.StackTrace}";
        Log(formattedMessage, LogLevel.Error);
    }
}

public class Program
{
    public static void Main()
    {
        var logger = new Logger();

        // Calling the first overload: Log(string)
        logger.Log("User logged in successfully.");

        // Calling the second overload: Log(string, LogLevel)
        logger.Log("Database connection is slow.", LogLevel.Warning);

        // Calling the third overload: Log(Exception)
        try
        {
            int x = 10;
            int y = 0;
            int z = x / y;
        }
        catch (Exception ex)
        {
            logger.Log(ex);
        }
    }
}
```

## Sobrecarga de Construtores

O mesmo princípio se aplica a construtores. É extremamente comum sobrecarregar construtores para fornecer diferentes maneiras de inicializar um objeto. Isso torna a classe muito mais flexível.

Uma prática recomendada é usar a palavra-chave `this(...)` para encadear construtores. Isso evita a duplicação da lógica de inicialização e centraliza o trabalho no construtor mais completo.

```CSHARP
public class Customer
{
    public Guid Id { get; private set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public DateTime MemberSince { get; private set; }

    // Overload 1: The most complete constructor. This is the one that does the actual work.
    public Customer(string name, string email)
    {
        Id = Guid.NewGuid();
        Name = name;
        Email = email;
        MemberSince = DateTime.UtcNow;
        Console.WriteLine("Main constructor executed.");
    }

    // Overload 2: A convenience constructor for creating a customer with just an email.
    // It calls the main constructor using 'this(...)', providing a default name.
    public Customer(string email) : this("New Customer", email)
    {
        // This body is executed AFTER the main constructor.
        Console.WriteLine("Email-only constructor finished.");
    }

    // Overload 3: A default constructor.
    // It calls the second constructor, which in turn calls the first one.
    public Customer() : this("default@example.com")
    {
        Console.WriteLine("Default constructor finished.");
    }
}

// Example Usage:
var customer1 = new Customer("John Doe", "john.doe@example.com"); // Calls the main constructor
var customer2 = new Customer("jane.doe@example.com"); // Calls the second, then the main
var customer3 = new Customer(); // Calls the third, then the second, then the main
```

## E as Propriedades? Sobrecarga Através de Indexadores

Como mencionado, propriedades com o mesmo nome não podem ser sobrecarregadas. No entanto, o C# oferece os Indexadores (Indexers), que permitem que um objeto seja acessado como se fosse um array (usando `[]`). E a grande vantagem é que indexadores podem ser sobrecarregados.

Um indexador é declarado de forma parecida com uma propriedade, mas usa a palavra-chave `this` como nome e inclui os parâmetros de índice entre colchetes.

### Exemplo: Uma Coleção de Configurações

Imagine uma classe que armazena as configurações de uma aplicação. Seria útil poder acessar uma configuração tanto pelo seu nome (`string`) quanto pela sua posição na lista (`int`).

```CSHARP
public class AppSettings
{
    private readonly Dictionary<string, string> _settings = new Dictionary<string, string>();
    private readonly List<string> _settingKeys = new List<string>();

    // Indexer Overload 1: Access by string key.
    public string this[string key]
    {
        get 
        {
            return _settings[key];
        }
        set 
        {
            if (!_settings.ContainsKey(key))
            {
                _settingKeys.Add(key);
            }
            _settings[key] = value;
        }
    }

    // Indexer Overload 2: Access by integer index.
    public string this[int index]
    {
        get
        {
            string key = _settingKeys[index];
            return _settings[key];
        }
        // A 'set' accessor could be added here as well.
    }
}

public class Program
{
    public static void Main()
    {
        var settings = new AppSettings();

        // Using the string indexer to set values
        settings["ConnectionString"] = "Server=myServer;Database=myDataBase;";
        settings["Theme"] = "Dark";

        // Using the string indexer to get a value
        Console.WriteLine($"Theme: {settings["Theme"]}");

        // Using the int indexer to get a value by position
        Console.WriteLine($"First setting: {settings[0]}");
    }
}

// Output:
// Theme: Dark
// First setting: Server=myServer;Database=myDataBase;
```

Dessa forma, embora não estejamos sobrecarregando uma propriedade chamada `Setting`, estamos oferecendo múltiplas formas de acessar os dados da classe, que é o espírito da sobrecarga, mas aplicado através do mecanismo de indexadores.

## Conclusão

A sobrecarga de métodos e construtores é uma ferramenta poderosa no arsenal do desenvolvedor C# para criar APIs de classes que são ao mesmo tempo robustas, flexíveis e fáceis de usar. Ao permitir que uma única "ação" (o nome do método) seja invocada de múltiplas maneiras, a sobrecarga reduz a complexidade para quem consome a classe, melhora a legibilidade do código e evita a proliferação de métodos com nomes ligeiramente diferentes para tarefas semelhantes. É um pilar do design de software limpo e expressivo.

Tip:

### Referências Oficiais

* [Sobrecarga de Métodos (Guia de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/methods#method-overloading)

* [Construtores (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/constructors)



# Sobrescrita de Método (override): Especializando o Comportamento Herdado

A Sobrescrita de Método, ou Method Overriding, é uma das manifestações mais poderosas da Programação Orientada a Objetos. É o mecanismo que permite a uma classe derivada (filha) fornecer uma implementação nova e especializada para um método que ela herdou de sua classe base (mãe). Em essência, a classe filha diz: "Eu reconheço e respeito o comportamento que herdei, mas para mim, essa ação específica funciona de uma maneira diferente e mais adequada".

Este mecanismo é a espinha dorsal do Polimorfismo de Tempo de Execução. É o que permite que você chame o mesmo método em diferentes objetos e obtenha comportamentos diferentes, específicos para o tipo real de cada objeto.

Tip:

Dissertação: A herança nos dá o benefício da reutilização de código, fornecendo um comportamento padrão. A sobrescrita nos dá o poder da especialização. Sem a sobrescrita, a herança seria muito limitada. Teríamos apenas uma forma de comportamento para toda uma hierarquia de classes. A sobrescrita quebra essa rigidez, permitindo que cada classe na hierarquia adapte o comportamento herdado à sua própria realidade, tornando o modelo de objetos imensamente mais flexível e expressivo.

## A Necessidade de Comportamento Especializado

Imagine que estamos modelando um sistema com animais. Podemos ter uma classe base `Animal`.

```CSHARP
public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("An animal makes a sound.");
    }
}
```

Esta implementação padrão é genérica. Agora, criamos uma classe `Dog` que herda de `Animal`. Um cachorro não faz um "som de animal"; ele late. A classe `Dog` precisa de um comportamento mais específico.

```CSHARP
public class Dog : Animal
{
    // The Dog class OVERRIDES the base behavior.
    public override void MakeSound()
    {
        Console.WriteLine("Woof! Woof!");
    }
}
```

Da mesma forma, uma classe `Cat` pode sobrescrever o método para miar. A mágica acontece quando usamos o polimorfismo: podemos ter uma lista de `Animal` e, ao chamar `MakeSound()` em cada um, o som correto é produzido em tempo de execução, com base no tipo real do objeto.

## 

O Contrato de Sobrescrita: `virtual`, `abstract` e `override`

A sobrescrita não é um processo anárquico. Ela é governada por um contrato claro entre a classe base e a classe derivada, definido pelas palavras-chave `virtual`, `abstract` e `override`.

1. `virtual` - O Convite para Sobrescrever

* Onde: Usado em um método na classe base.

* O que significa: "Eu, a classe base, estou fornecendo uma implementação padrão para este método, mas estou ciente de que minhas filhas podem ter uma ideia melhor. Eu as convido a fornecerem suas próprias implementações, se desejarem. Isso é opcional."

2. `abstract` - A Obrigação de Sobrescrever

* Onde: Usado em um método dentro de uma classe base `abstract`.

* O que significa: "Eu, a classe base, sou apenas um conceito e não sei como implementar este método. No entanto, eu declaro que este comportamento existe. Toda e qualquer classe concreta que herdar de mim é obrigada a fornecer sua própria implementação para este método. Isso é mandatório."

3. `override` - A Nova Implementação

* Onde: Usado em um método na classe derivada.

* O que significa: "Eu, a classe filha, estou ciente do convite (`virtual`) ou da obrigação (`abstract`) da minha mãe. Eu estou conscientemente fornecendo a minha própria implementação especializada para esse método."

Tip:

Nota Importante: Você não pode sobrescrever um método que não seja `virtual` ou `abstract`. O C# impõe esse contrato para evitar que você altere acidentalmente o comportamento de uma classe de uma forma que o autor original não previu, o que poderia levar a bugs sutis.

### Diagrama de Contrato (PlantUML)

Vamos visualizar um exemplo mais prático: um sistema que processa diferentes tipos de documentos.

```PLANTUML
@startuml
skinparam classAttributeIconSize 0
skinparam monochrome true
skinparam shadowing false

abstract class Document {
    + Title : string
    + Author : string
    + <<virtual>> Print() : void
    + <<abstract>> Save() : bool
}

class PdfDocument {
    + CompressionLevel : int
    + <<override>> Print() : void
    + <<override>> Save() : bool
}

class WordDocument {
    + IsCompatibilityMode : bool
    + <<override>> Save() : bool
}

Document <|-- PdfDocument
Document <|-- WordDocument

note right of Document::Print
  A **virtual** method.
  Provides a default printing behavior,
  but allows derived classes to change it.
end note

note right of Document::Save
  An **abstract** method.
  Forces all derived classes
  to implement their own save logic.
end note

note right of WordDocument
  This class inherits the default
  Print() behavior from Document
  but provides its own Save() logic.
end note
@enduml
```

## Exemplo Prático: Processador de Documentos

Este código implementa a hierarquia do diagrama acima.

```CSHARP
// The abstract base class defines the contract.
public abstract class Document
{
    public string Title { get; set; }

    // This is a VIRTUAL method. It has a default implementation.
    // Derived classes CAN override it, but they don't have to.
    public virtual void Print()
    {
        Console.WriteLine($"Printing document '{this.Title}' to the default printer.");
    }

    // This is an ABSTRACT method. It has no implementation.
    // Derived classes MUST provide their own implementation.
    public abstract bool Save();
}

// A derived class providing its own implementations.
public class PdfDocument : Document
{
    // This class OVERRIDES the Print method to add specific behavior.
    public override void Print()
    {
        Console.WriteLine($"Opening Adobe Reader to print PDF document '{this.Title}'.");
    }

    // This class MUST override the Save method to fulfill the abstract contract.
    public override bool Save()
    {
        Console.WriteLine($"Saving document '{this.Title}' as a PDF file.");
        return true;
    }
}

// Another derived class.
public class WordDocument : Document
{
    // This class does NOT override Print(), so it will use the default
    // implementation from the base Document class.

    // It MUST, however, override the abstract Save method.
    public override bool Save()
    {
        Console.WriteLine($"Saving document '{this.Title}' as a .docx file.");
        return true;
    }
}

public class DocumentProcessor
{
    public static void Main()
    {
        var documents = new List<Document>
        {
            new PdfDocument { Title = "My-Annual-Report" },
            new WordDocument { Title = "My-Secret-Novel" }
        };

        foreach (var doc in documents)
        {
            Console.WriteLine($"--- Processing {doc.GetType().Name}: {doc.Title} ---");
            doc.Print(); // The magic of polymorphism happens here!
            doc.Save();
            Console.WriteLine();
        }
    }
}
```

## Tópicos Adicionais e Avançados

Tip:

`override` vs. `new` (Ocultação de Método): Existe outra palavra-chave, `new`, que pode ser usada em um método de uma classe filha com a mesma assinatura de um método da classe mãe. No entanto, `new` NÃO sobrescreve o método; ela apenas o oculta. Isso quebra o polimorfismo. Se um objeto `PdfDocument` for armazenado em uma variável do tipo `Document`, e o método `Print` fosse definido com `new`, a versão da classe `Document` seria chamada, não a da `PdfDocument`. O uso de `new` é raro e deve ser feito com extremo cuidado, pois quase sempre indica um problema de design. Sempre prefira `override` para especializar comportamento.

Tip:

`sealed override`: Você pode "selar" um método sobrescrito para impedir que classes mais abaixo na hierarquia o sobrescrevam novamente. `public sealed override void MyMethod() { ... }`. Isso "trava" a implementação naquele ponto da cadeia de herança.

## Referências Oficiais da Microsoft

* [Polimorfismo (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/fundamentals/object-oriented/polymorphism)

* [Palavra-chave override (Referência de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/override)

* [Controle de Versão com as Palavras-chave override e new (Guia de Programação C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords)



# Modificators

Os modificadores mudam a forma como acessamos os metodos, atributos e classes

Tip:

O padrão é private em class

temos, public, private, internal, protected



# ComplexTypes

Tipos complexos seriam tudo com uso do `new`

Tip:

Tem que tomar cuidado com o Primitive Obsession porque é bom ter tipos primitivos mas é melhor quebrar os objetos e tornarem em classes menores



# References

This page contains a curated list of high-quality resources for learning and mastering C# and the .NET ecosystem.

## Official Documentation

* Microsoft C# Docs: The official and most comprehensive source for C# documentation. It includes tutorials, language references, and how-to guides. * [C# Documentation Home](https://docs.microsoft.com/en-us/dotnet/csharp/) * [C# Language Reference](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/) * [.NET Documentation](https://docs.microsoft.com/en-us/dotnet/)

## Books

* C# in Depth by Jon Skeet: An essential book for intermediate to advanced developers looking to understand the nuances of the C# language and its evolution.

## Online Courses & Tutorials

* Microsoft Learn: An interactive platform with free tutorials and learning paths for C#, .NET, and Azure. * [Take your first steps with C#](https://learn.microsoft.com/en-us/training/paths/csharp-first-steps/)

## Community & Code

* .NET Foundation: An independent organization to foster open development and collaboration around the .NET ecosystem. * [Official Website](https://dotnetfoundation.org/)

* .NET Source Code: Browsing the source code of the .NET runtime and libraries is an excellent way to learn how things work under the hood. * [dotnet/runtime on GitHub](https://github.com/dotnet/runtime)



