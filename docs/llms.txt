# Sobre este Repositório

Bem-vindo ao meu repositório pessoal de aprendizado de C# e .NET. Esta documentação é um projeto vivo onde organizo minhas anotações, exemplos de código e meu entendimento da linguagem C#, desde conceitos fundamentais até tópicos mais avançados.

O objetivo principal é construir uma base de conhecimento pessoal estruturada e detalhada que solidifique meu aprendizado e possa servir como uma referência rápida no futuro.

## Como Está Organizado

Esta base de conhecimento está dividida principalmente em duas áreas:

1. Tópicos (`/Writerside/topics/`): São artigos detalhados que explicam conceitos específicos de C#. Cada tópico visa ser uma explicação clara e concisa de um recurso, palavra-chave ou conceito de programação.

2. Projetos (`/projects/`): Este diretório contém pequenas aplicações C# práticas. Esses projetos são usados para aplicar o conhecimento teórico dos tópicos de forma prática.

Este projeto é construído usando JetBrains Writerside, que permite formatação rica e uma experiência de documentação estruturada.

## See also

### Writerside documentation

[Recursos Recomendados](references.html)



# Escopo

Em C#, "escopo" refere-se à região do código onde uma variável ou um membro de uma classe pode ser acessado. Entender o escopo é fundamental para escrever um código organizado e livre de erros, pois ele determina o ciclo de vida e a visibilidade das suas variáveis.

O escopo em C# é geralmente definido por blocos de código, que são delimitados por chaves `{}`.

## Níveis de Escopo

### 

1. Escopo de Classe (Campos ou Fields)

Variáveis declaradas diretamente dentro de uma classe, mas fora de qualquer método, são chamadas de campos (fields) ou variáveis de membro. Elas estão disponíveis para todos os métodos (e outros membros) dentro daquela classe.

* Seu ciclo de vida é o mesmo do objeto da classe.

* Podem ser acessadas usando a palavra-chave `this`.

```CSHARP
public class Personagem
{
    // 'nome' e 'pontosDeVida' são campos com escopo de classe.
    private string nome;
    private int pontosDeVida = 100;

    public Personagem(string nomeInicial)
    {
        this.nome = nomeInicial; // Acessando o campo 'nome'
    }

    public void ReceberDano(int dano)
    {
        // Acessando e modificando o campo 'pontosDeVida'
        this.pontosDeVida -= dano;
        Console.WriteLine($"{this.nome} recebeu {dano} de dano e agora tem {this.pontosDeVida} HP.");
    }
}
```

### 2. Escopo de Método (Variáveis Locais)

Variáveis declaradas dentro de um método são chamadas de variáveis locais. Elas só podem ser acessadas dentro do método onde foram declaradas.

* Elas são criadas quando o método é chamado e destruídas quando o método termina.

* Não podem ser acessadas por outros métodos.

```CSHARP
public class Calculadora
{
    public int Somar(int a, int b)
    {
        // 'resultado' é uma variável local com escopo de método.
        int resultado = a + b;
        return resultado;
    }

    public void OutroMetodo()
    {
        // A linha abaixo causaria um erro de compilação, pois 'resultado'
        // não existe neste escopo.
        // Console.WriteLine(resultado); 
    }
}
```

### 3. Escopo de Bloco

Variáveis declaradas dentro de um bloco de código (como um `if`, `for`, `while` ou mesmo um bloco `{}` avulso) só existem dentro daquele bloco.

* Este é o nível de escopo mais restrito.

```CSHARP
public void TestarEscopoDeBloco()
{
    int a = 10;

    if (a > 5)
    {
        // 'b' só existe dentro deste bloco 'if'.
        int b = 20;
        Console.WriteLine(a + b); // Válido: 'a' e 'b' estão em escopo.
    }

    // A linha abaixo causaria um erro de compilação, pois 'b' está fora de escopo.
    // Console.WriteLine(b);
}
```

## 

Sombreamento de Variáveis (Variable Shadowing)

O C# impede que você declare uma variável local com o mesmo nome de outra variável local que já esteja em um escopo externo (pai). Isso evita bugs e confusão.

```CSHARP
int x = 10; // Escopo do método

if (x > 5)
{
    int y = 20; // Escopo do bloco
    // int x = 30; // Erro de compilação! Não se pode declarar 'x' aqui porque já existe no escopo pai.
}
```

No entanto, uma variável local pode ter o mesmo nome de um campo da classe. Nesse caso, a variável local "sombra" (ou esconde) o campo. Para acessar o campo da classe, você deve usar a palavra-chave `this`.

```CSHARP
public class Exemplo
{
    private string nome = "Classe"; // Campo da classe

    public void MeuMetodo(string nome) // Parâmetro do método
    {
        // 'nome' aqui se refere ao parâmetro do método ("Método").
        Console.WriteLine($"Variável local: {nome}");

        // Para acessar o campo da classe, usamos 'this.nome'.
        Console.WriteLine($"Campo da classe: {this.nome}");
    }
}

// Uso:
Exemplo ex = new Exemplo();
ex.MeuMetodo("Método");
// Saída:
// Variável local: Método
// Campo da classe: Classe
```



# Namespaces

Em C#, um `namespace` é um contêiner organizacional para classes e outros namespaces. Sua principal finalidade é fornecer um nível de separação para o código, ajudando a evitar conflitos de nomes e a estruturar grandes projetos de forma lógica.

Pense em um namespace como o sobrenome de uma classe. Você pode ter duas pessoas chamadas "João", mas elas são diferentes se uma for "João Silva" e a outra "João Souza". Da mesma forma, você pode ter duas classes `Cliente`, desde que elas estejam em namespaces diferentes (ex: `MeuApp.Vendas.Cliente` e `MeuApp.Suporte.Cliente`).

## Declaração e Estrutura

Um namespace é declarado com a palavra-chave `namespace`, seguida por um nome e um bloco de código `{}` contendo as classes.

```CSHARP
// O nome do namespace geralmente segue a estrutura do projeto.
namespace MeuApp.Servicos
{
    public class EmailService
    {
        // ... código do serviço de email
    }
}
```

### Relação com a Estrutura de Pastas

Por convenção, a estrutura de namespaces de um projeto espelha a estrutura de pastas. Isso torna a navegação e a localização de arquivos muito mais intuitivas.

* Se você tem um arquivo na pasta `Projeto/Models/User.cs`, o namespace dentro de `User.cs` deve ser `Projeto.Models`.

* Se você tem um arquivo em `Projeto/Services/Payment/PayPalService.cs`, o namespace deve ser `Projeto.Services.Payment`.

As IDEs modernas, como o Visual Studio e o Rider, gerenciam essa estrutura automaticamente ao criar novos arquivos.

## Namespaces Aninhados

Você pode aninhar namespaces para criar hierarquias ainda mais detalhadas.

```CSHARP
namespace MeuApp.Servicos
{
    namespace Notificacoes
    {
        public class PushService { }
    }
}

// A classe PushService pode ser acessada usando seu nome completo:
// MeuApp.Servicos.Notificacoes.PushService service;
```

## O Namespace Global

Qualquer tipo que não é declarado dentro de um namespace reside no namespace global. Isso é geralmente desaconselhado para evitar poluir o escopo global e criar possíveis conflitos com outras bibliotecas.

## Boas Práticas

1. Um Tipo por Arquivo: Mantenha apenas uma classe, struct, interface ou enum por arquivo. O nome do arquivo deve corresponder ao nome do tipo (ex: `Cliente.cs` contém a classe `Cliente`).

2. Espelhe a Estrutura de Pastas: Sempre faça seus namespaces corresponderem à hierarquia de pastas do seu projeto.

3. Nomes Significativos: Use nomes que descrevam claramente a funcionalidade contida no namespace (ex: `MeuApp.Data`, `MeuApp.UI`, `MeuApp.Utilities`).



# A Palavra-Chave using

A palavra-chave `using` em C# é multifacetada e possui três contextos de uso distintos, todos com o objetivo de simplificar o código e gerenciar recursos de forma eficaz.

## 

1. Diretiva `using`: Importando Namespaces

Este é o uso mais comum. A diretiva `using` é colocada no topo de um arquivo de código e permite que você use os tipos de um namespace sem precisar especificar o nome completo do namespace toda vez.

Sem a diretiva `using`, você teria que escrever:

```CSHARP
// Nome completo do tipo é necessário
System.Collections.Generic.List<string> nomes = new System.Collections.Generic.List<string>();
System.Console.WriteLine("Olá");
```

Com a diretiva `using`, o código se torna muito mais limpo e legível:

```CSHARP
// Importamos os namespaces no topo do arquivo
using System;
using System.Collections.Generic;

// Agora podemos usar os tipos diretamente
List<string> nomes = new List<string>();
Console.WriteLine("Olá");
```

Note:

Por convenção, as diretivas `using` são sempre declaradas no início do arquivo.

## 

2. Instrução `using`: Gerenciamento de Recursos (`IDisposable`)

A instrução `using` garante que objetos que implementam a interface `IDisposable` sejam descartados corretamente, liberando recursos não gerenciados (como conexões de banco de dados, arquivos, handles de sistema) assim que não forem mais necessários.

O compilador transforma o bloco `using` em um bloco `try...finally`, garantindo que o método `Dispose()` do objeto seja chamado, mesmo que ocorram exceções.

Sintaxe Tradicional:

```CSHARP
// A classe 'StreamReader' implementa IDisposable
using (System.IO.StreamReader leitor = new System.IO.StreamReader("caminho/para/arquivo.txt"))
{
    string conteudo = leitor.ReadToEnd();
    Console.WriteLine(conteudo);
} // O método leitor.Dispose() é chamado automaticamente aqui, fechando o arquivo.
```

Sintaxe Simplificada (C# 8.0 e superior):

Se a variável declarada com `using` não for mais usada fora do escopo atual, você pode omitir as chaves.

```CSHARP
using System.IO.StreamReader leitor = new System.IO.StreamReader("arquivo.txt");
string conteudo = leitor.ReadToEnd();
Console.WriteLine(conteudo);
// O método leitor.Dispose() será chamado automaticamente no final do escopo (ex: no final do método).
```

## 

3. Diretiva `using static`: Importando Membros Estáticos

Esta diretiva permite que você acesse os membros estáticos (`métodos`, `propriedades`, `constantes`) de uma classe diretamente, sem precisar prefixá-los com o nome da classe.

Sem `using static`:

```CSHARP
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine(Math.PI);
        Console.WriteLine(Math.Pow(2, 3));
    }
}
```

Com `using static`, o código fica mais conciso:

```CSHARP
// Importamos todos os membros estáticos da classe System.Math e System.Console
using static System.Math;
using static System.Console;

class Program
{
    static void Main()
    {
        // Agora podemos chamar os métodos estáticos diretamente
        WriteLine(PI);       // Em vez de Math.PI
        WriteLine(Pow(2, 3)); // Em vez de Math.Pow(2, 3)
    }
}
```

Warning:

Use `using static` com moderação. Embora possa tornar o código mais curto, usá-lo excessivamente pode poluir o escopo e diminuir a legibilidade, tornando difícil saber de qual classe um método estático se origina.



# Variáveis

Variavel é um espaço na mémoria que vai guardar um dado

No C# como toda linguagem de programação temos tipos primitivos, por exemplo:

* int - inteiro

* string - texto

* bool - booleano (true ou false)

* double e float - número decimal

Note:

Lembrando que: double e float não são o mesmo pois o double possui uma precisão maior do que o float, mas o float ocupa menos memória.

No c# podemos declarar variaveis assim:

```CSHARP
int idade = 10;
string nome = "Joao";
bool estaAprovado = true;
double salario = 25.98;
float altura; 
altura = 1.76f; 
```

Warning:

Note que para declarar um float devemos colocar a letra f no final da declaração:

```CSHARP
float altura = 1.76f; 
```

## Declarações múltiplas

É possível declarar várias variáveis no mesmo comando separando-as por vírgula.

```CSHARP
int a, b, c;
```

Lembre-se sempre que você precisa inicializar uma variável antes de usá-la. E de que C# é uma linguagem fortemente
tipada, logo, precisamos definir o tipo dela ou seja, você deve especificar o tipo de dados quando declarar uma
variável. Ou podemos usar a inferência de tipos. Exemplo:

```CSHARP
var idade = 10;
var nome = "Joao";
var estaAprovado = true;
var salario = 25.98;
var altura = 1.76f; 
```

Assim o tipo de dado será inferido pelo compilador, deste modo não temos um controle real da tipagem

Note:

Para inferencia de tipos utilizamos a palavra reservada `var`. Mas não podemos utilizar desta forma na hora de criar uma
variavel:

```CSHARP
var x; // isso está errado!
```



# Constantes

Uma constante (`const`) é um campo cujo valor é definido em tempo de compilação e não pode ser alterado durante a execução do programa. Pense nela como um valor fixo e imutável.

Warning:

Regra Fundamental: Uma constante deve obrigatoriamente ser inicializada no momento em que é declarada. Tentar declarar uma constante sem um valor resultará em um erro de compilação.

Exemplo de Declaração Correta:

```CSHARP
const double PI = 3.14159;
const string NOME_EMPRESA = "MinhaApp";
```

Convenção de Nomenclatura: Por convenção, nomes de constantes em C# são escritos em `PascalCase` ou `ALL_CAPS_SNAKE_CASE` para distingui-los claramente de variáveis.

## 

Características das Constantes (`const`)

1. Valor em Tempo de Compilação: O valor de uma `const` é gravado diretamente no assembly do programa. O compilador substitui o uso da constante pelo seu valor literal em todo o código (semelhante a um "localizar e substituir").

2. Tipos Permitidos: Só podem ser dos tipos primitivos do C# (todos os tipos numéricos, `bool`, `char`, `string`) ou um tipo `enum`.

3. Implicitamente Estáticas: Uma `const` é sempre estática (`static`), mesmo que a palavra-chave `static` não seja usada. Ela pertence ao tipo, não a uma instância do objeto.

## 

`const` vs. `readonly`: Qual a Diferença?

Este é um ponto crucial que diferencia desenvolvedores experientes. C# também possui a palavra-chave `readonly`, que parece similar, mas tem um propósito diferente.

* `readonly` (Constante de Tempo de Execução): Um campo `readonly` também não pode ser alterado após sua inicialização. No entanto, sua inicialização pode ocorrer na declaração ou dentro do construtor da classe. Isso permite que cada instância de um objeto tenha um valor `readonly` diferente.

Tabela Comparativa:

| Característica |`const` |`readonly` |
---------------------------------------
| Quando o valor é definido? |Tempo de Compilação |Tempo de Execução (no construtor) |
| Pode ser diferente por instância? |Não (é estático) |Sim (pode ser de instância) |
| Pode ser de qualquer tipo? |Não (só primitivos/enum) |Sim (qualquer tipo, incluindo objetos) |
| Pode ser `static`? |Sim (implicitamente) |Sim (explicitamente, `static readonly`) |

Exemplo Prático:

```CSHARP
public class Circulo
{
    // 'PI' é o mesmo para todos os círculos. É uma constante de compilação.
    public const double PI = 3.14159;

    // 'Raio' e 'DataCriacao' podem ser diferentes para cada objeto Circulo.
    // Seus valores são definidos quando o objeto é criado e não podem ser mudados depois.
    public readonly double Raio;
    public readonly DateTime DataCriacao;

    public Circulo(double raio)
    {
        this.Raio = raio; // Inicialização de campo readonly no construtor
        this.DataCriacao = DateTime.Now;
    }
}

// Uso
Circulo c1 = new Circulo(5.0);
Circulo c2 = new Circulo(10.0);

// c1.Raio é 5.0, c2.Raio é 10.0. Ambos são imutáveis após a criação.
// Tentar fazer 'c1.Raio = 7.0;' resultaria em um erro de compilação.
```

### Quando Usar Qual?

* Use `const`: Para valores que são verdadeiramente universais e imutáveis, conhecidos antes mesmo do programa rodar (ex: `Math.PI`, número de meses no ano, uma string de conexão padrão para um ambiente de teste).

* Use `readonly`: Para valores que são específicos de uma instância de um objeto e que não devem mudar após a sua criação (ex: um ID de usuário, a data de criação de um registro).



# Palavras-Chave (Keywords)

Palavras-chave (ou keywords) são identificadores reservados que têm um significado especial para o compilador do C#. Elas são os blocos de construção fundamentais da linguagem e não podem ser usadas como nomes de variáveis, métodos ou classes (a menos que sejam prefixadas com `@`, o que é raro e geralmente desaconselhado).

Note:

Você não precisa memorizar todas. As IDEs modernas, como Visual Studio e Rider, destacam as palavras-chave e avisam se você tentar usá-las incorretamente. O objetivo aqui é entender as categorias e as mais comuns.

## Categorias de Palavras-Chave Comuns

### Modificadores de Acesso

Controlam a visibilidade (onde o código pode ser acessado).

* `public`: Acesso não restrito.

* `private`: Acesso limitado à classe que o contém.

* `protected`: Acesso limitado à classe que o contém e a classes derivadas (herança).

* `internal`: Acesso limitado ao assembly atual (ao projeto).

### Declaração de Tipos

Usadas para definir os diferentes tipos de estruturas de dados.

* `class`: Define um tipo de referência que contém dados (campos) e comportamento (métodos).

* `struct`: Define um tipo de valor, geralmente para pequenas estruturas de dados.

* `interface`: Define um contrato (um conjunto de métodos e propriedades) que uma classe ou struct pode implementar.

* `enum`: Define um conjunto de constantes nomeadas (ex: DiasDaSemana).

* `delegate`: Define um tipo que representa uma referência a um método com uma assinatura específica.

### Modificadores de Membros

Alteram o comportamento de membros de uma classe.

* `static`: Indica que um membro pertence ao tipo em si, não a uma instância.

* `const`: Declara um campo cujo valor é uma constante de tempo de compilação.

* `readonly`: Declara um campo cujo valor só pode ser definido na declaração ou no construtor.

* `abstract`: Indica que uma classe ou membro tem uma implementação ausente ou incompleta (deve ser implementado por uma classe derivada).

* `virtual`: Permite que um método em uma classe base seja sobrescrito por uma classe derivada.

* `override`: Sobrescreve um método `virtual` ou `abstract` de uma classe base.

### Nível de Método

Usadas dentro de métodos ou para definir o comportamento de métodos.

* `void`: Especifica que um método não retorna nenhum valor.

* `return`: Retorna o controle (e opcionalmente um valor) do método para quem o chamou.

* `params`: Permite que um método aceite um número variável de argumentos.

* `ref`, `out`, `in`: Modificadores de parâmetro que controlam como os argumentos são passados para os métodos.

### Instruções e Controle de Fluxo

Controlam a ordem em que o código é executado.

* `if`, `else`: Executam código condicionalmente.

* `switch`, `case`, `default`: Executam código com base em uma correspondência de padrões.

* `for`, `foreach`, `while`, `do`: Criam laços (loops).

* `break`: Sai de um laço ou de um `switch`.

* `continue`: Pula para a próxima iteração de um laço.

* `try`, `catch`, `finally`, `throw`: Manipulação de exceções.

### Gerenciamento de Namespaces e Tipos

* `using`: Importa um namespace ou gerencia recursos `IDisposable`.

* `namespace`: Declara um escopo para organizar o código.

* `new`: Cria uma nova instância de um tipo ou oculta um membro de uma classe base.

* `typeof`: Obtém o objeto `System.Type` para um tipo.

Para uma lista exaustiva e detalhada de todas as palavras-chave, a documentação oficial da Microsoft é a fonte definitiva.

[Referência Completa de Palavras-Chave do C# (Microsoft Docs)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/)



# Comentários

Comentários são anotações no código-fonte que são ignoradas pelo compilador. Eles existem exclusivamente para os desenvolvedores, servindo para esclarecer partes complexas do código, deixar lembretes ou gerar documentação externa.

## A Regra de Ouro: Comente o "Porquê", não o "O Quê"

Um bom código deve ser autoexplicativo. O código em si já mostra o que ele está fazendo. Comentários eficazes devem explicar por que o código está fazendo algo de uma maneira específica, especialmente se a lógica não for óbvia.

* Comentário Ruim (redundante): ```CSHARP // Incrementa i em 1 i++; ```

* Comentário Bom (explica a intenção): ```CSHARP // Usamos um algoritmo de ordenação customizado aqui porque os testes de performance // mostraram que ele é 2x mais rápido para o nosso conjunto de dados específico. CustomSort(minhaLista); ```

## Tipos de Comentários

### 

1. Comentários de Linha Única (`//`)

Começam com `//` e continuam até o final da linha. São ideais para notas curtas e explicações pontuais.

```CSHARP
// Verifica se o usuário tem permissão de administrador.
if (user.IsAdmin)
{
    // ...
}
```

### 

2. Comentários de Múltiplas Linhas (`/* ... */`)

Começam com `/*` и terminam com `*/`. Podem abranger várias linhas e são úteis para desativar temporariamente grandes blocos de código ou para comentários mais longos.

```CSHARP
/*
    Este é um método temporário para testes de carga.
    Ele simula a criação de 10.000 usuários e deve ser removido
    antes de enviarmos o código para produção.
*/
public void GerarCargaDeTeste()
{
    // ...
}
```

### 

3. Comentários de Documentação XML (`///`)

Estes são os comentários mais poderosos do C#. Eles começam com `///` e usam tags XML para descrever o que classes, métodos e propriedades fazem. O Visual Studio e outras IDEs usam esses comentários para fornecer o IntelliSense (autocompletar com documentação), e eles podem ser usados para gerar arquivos de documentação HTML automaticamente.

Tags XML Comuns:

* `<summary>`: Um resumo geral do que o membro faz.

* `<param name="nomeDoParametro">`: Descreve um parâmetro do método.

* `<returns>`: Descreve o valor de retorno do método.

* `<exception cref="TipoDaExcecao">`: Descreve uma exceção que o método pode lançar.

* `<remarks>`: Fornece informações adicionais mais detalhadas.

Exemplo Completo:

```CSHARP
/// <summary>
/// Calcula o pagamento mensal de um empréstimo com base na taxa de juros, 
/// número de parcelas e valor do empréstimo.
/// </summary>
/// <param name="taxaAnual">A taxa de juros anual (ex: 0.05 para 5%).</param>
/// <param name="numParcelas">O número total de parcelas.</param>
/// <param name="valorEmprestimo">O valor total do empréstimo.</param>
/// <returns>O valor do pagamento mensal.</returns>
/// <exception cref="ArgumentException">Lançada quando um dos parâmetros numéricos é negativo.</exception>
public double CalcularPagamentoMensal(double taxaAnual, int numParcelas, decimal valorEmprestimo)
{
    if (taxaAnual < 0 || numParcelas < 0 || valorEmprestimo < 0)
    {
        throw new ArgumentException("Parâmetros não podem ser negativos.");
    }
    // ... lógica de cálculo
    return 0.0;
}
```

Ao usar a função `CalcularPagamentoMensal` em outro lugar, a IDE mostrará a `summary`, as descrições dos parâmetros e o que ela retorna, tornando o código muito mais fácil de usar.



# System

Todos os tipos mesmo os built-in são derivados do tipo chamado: `system`

```CSHARP
int a = 10;
Console.WriteLine(a.GetType()); //System.Int32
```

```
Ele é a base para todos os objetos no .NET
```

Como ele está de modo implicito, não precisamos se preocupar em usar



# Tipos Primitivos (Built-in Types)

São os tipos de dados mais básicos que o C# possui. São eles:

* int: Inteiro, pode ser positivo ou negativo.

* float: Ponto flutuante, números com casas decimais.

* double: Double precision floating point number. Números com casas decimais.

* char: Caracteres individuais. Exemplo 'a', 'b' etc...

* bool: Booleano, verdadeiro ou falso.

Os tipos primitivos são usados para armazenar valores simples e podem ser declarados da seguinte forma:

```CSHARP
int myInt = 10;
float myFloat = 3.14f; // O sufixo "f" é usado para indicar que é um número de ponto flutuante.
double myDouble = 2.71828;
char myChar = 'A';
bool myBool = true;
```

Note:

Veja mais: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types)

## Classificação

Eles podem ser classificados em algumas categórias:

* Tipos Simples (Simple Types)

* Enumerados (Enum Types)

* Estruturas (Struct Types)

* Tipos Nulos (Nullable Types)

## Definições

Cada tipo possui sua capacidade em bytes e seu alcance máximo. Por exemplo:

* int: 4 bytes, -231 a 231-1

* float: 4 bytes, ~±1.5 x 10-45 to ±3.4 x 1038

* double: 8 bytes, ~±5.0 x 10-324 to ±1.7 x 10308

* char: 2 bytes, '\u0000' to '\uffff'

* bool: 1 byte, false or true

Warning:

Caso o o valor atribuido exceda o limite do tipo, ocorrerá um erro de overflow

Note:

Você também pode usar as palavras-chave `sizeof` e `typeof` para obter informações sobre esses tipos:

```CSHARP
Console.WriteLine(sizeof(int)); // Output: 4
Console.WriteLine(typeof(float).Name); // Output: Single
```



# Byte

O tipo byte é usado para representar de fato um byte.

Em diversos casos precisamos de uma cadeia de bytes num arquivo para ler ou escrever dados. O tipo byte pode ser usado para isso, pois ele representa um único byte

```CSHARP
byte b = 10;
Console.WriteLine(b);
```

Temos também o `sbyte` que permite valores negativos

Note:

Unsigned e signed:

Valores com sinal como "-" por exemplo, são chamados de signed numbers (números com sinal) e sem sinal são chamados unsigned numbers (números sem sinal).

Ex:

```CSHARP
int signedNumber = -5; //signed number
uint unsignedNumber = 5; //unsigned number
```

## Definições

* byte (8-bit): * escala: 0 a 255

* sbyte (8-bit): * escala: -127 a +127



# Números Inteiros

## Definições

Números inteiros são números que não possuem casas decimais. Exemplos de números inteiros: 1, -20, 356789.

## Classificação:

* short/unshort

* int/uint

* long/ulong

Note:

O `u` do `ushort`, `uint` e `ulong` significa unsigned (sem sinal)

Ou seja, esses tipos só armazenam valores que são possitivos ou zero

## Tabela de Tipos

| Tipo |Intervalo |Tamanho |Tipo .NET |
---------------------------------------
| `sbyte` |-128 a 127 |Inteiro de 8 bits com sinal |System.SByte |
| `byte` |0 a 255 |Inteiro de 8 bits sem sinal |System.Byte |
| `short` |-32,768 a 32,767 |Inteiro de 16 bits com sinal |System.Int16 |
| `ushort` |0 a 65,535 |Inteiro de 16 bits sem sinal |System.UInt16 |
| `int` |-2,147,483,648 a 2,147,483,647 |Inteiro de 32 bits com sinal |System.Int32 |
| `uint` |0 a 4,294,967,295 |Inteiro de 32 bits sem sinal |System.UInt32 |
| `long` |-9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 |Inteiro de 64 bits com sinal |System.Int64 |
| `ulong` |0 a 18,446,744,073,709,551,615 |Inteiro de 64 bits sem sinal |System.UInt64 |

## Referência

[Tipos de números integrais (referência de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)



# Números Reais

Números com casas decimais ou ponto flutuante são chamados de números reais. Em C#, o tipo `double` é usado para representar um número real. O exemplo a seguir mostra como declarar e inicializar uma variável do tipo `double`.

```CSHARP
double x = 3.14; // Declaração e inicialização
```

O valor da variável `x` é `3,14`. A declaração acima pode ser escrita em duas linhas.

```CSHARP
double x; // Declaração
x = 3.14; // Inicialização
```

Além do `double` também existem outros que são diferentes por causa da precisão e tamanho dos dados armazenados. Os outros são:

* `float`: tem menos precisão e menor tamanho.

* `decimal`: tem maior precisão e maior tamanho.

## Exemplos:

```CSHARP
using System;
class Program {
    static void Main(string[] args) {
        double x = 3.14;
        Console.WriteLine(x); // Imprime: 3.14
        
        float y = 2.71f;
        Console.WriteLine(y); // Imprime: 2.71
        
        decimal z = 1.618m;
        Console.WriteLine(z); // Imprime: 1.618
    }
}
```

## Inferencia de Tipos

Quando usamos o `var` sem declarar o tipo explicitamente, ele atribui automaticamente o tipo `double` porque ele estaria no meio entre `float` e `decimal`, mas se fosse muito próximo de `int` ele seria inferido como `int`.

```CSHARP
var x = 3.14; // Inferência de tipo: double
Console.WriteLine(x.GetType()); // Imprime: Double
```

Agora se quisermos dizer que vai ser float ou decimal devemos usar os sufixos `f` ou `m` respectivamente.

```CSHARP
var x = 3.14f; // Inferência de tipo: float
Console.WriteLine(x.GetType()); // Imprime: Single

var y = 3.14m; // Inferência de tipo: decimal
Console.WriteLine(y.GetType()); // Imprime: Decimal
```

## Tabela de Tipos

| Tipo |Intervalo Aproximado |Precisão |Tamanho |Tipo .NET |
------------------------------------------------------------
| `float` |±1.5 x 10⁻⁴⁵ a ±3.4 x 10³⁸ |6-9 dígitos |4 bytes |System.Single |
| `double` |±5.0 x 10⁻³²⁴ a ±1.7 x 10³⁰⁸ |15-17 dígitos |8 bytes |System.Double |
| `decimal` |±1.0 x 10⁻²⁸ a ±7.9 x 10²⁸ |28-29 dígitos |16 bytes |System.Decimal |

Note:

Os três tipos não usam unsigned ou signed, pois possuem tanto assimilação negativa e positiva por padrão

## Referência

[Tipos de ponto flutuante (referência de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)



# Bool

Bool é o tipo de dado booleano (no c# ele se chama bool) e pode receber apenas dois valores: `true` ou `false`.

## Exemplo

```CSHARP
using System;
class Program {
    static void Main(string[] args) {
        bool isTrue = true; // Variável do tipo booleana que recebe valor verdadeiro.
        Console.WriteLine(isTrue); // Imprime no console a variável criada.
    }
}
```

Quando fazemos a inferencia com `var` seguimos a mesma lógica que os outros tipos:

```CSHARP
using System;

class Program {
    static void Main(string[] args) {
        var isFalse = false; // Inferência da variável do tipo booleana que recebe valor falso.
        Console.WriteLine(isFalse);
    }
}
```



# Caracter

É o tipo de caracter que utilizamos para armazenar um  único caracter

Note:

Caracter é um tipo de dado primitivo e representa um único caracter no formato unicode (formato universal para a representação dos caracteres)

Warning:

OBS:
Para declarar uma variável do tipo char, devemos utilizar aspas simples

## Exemplos:

```CSHARP
char letra = 'a';
Console.WriteLine(letra); // imprime: a

char numero = '1';
Console.WriteLine(numero); // imprime: 1

char simbolo = '@';
Console.WriteLine(simbolo); // imprime: @

char espaco = ' ';
Console.WriteLine(espaco); // imprime: espaço em branco

char tabulacao = '\t'; // \t é uma sequência de escape que representa uma tabulação horizontal
Console.WriteLine(tabulacao); // imprime: tabulação horizontal

char novaLinha = '\n'; // \n é uma sequência de escape que representa uma nova linha
Console.WriteLine(novaLinha); // imprime: nova linha

char backspace = '\b'; // \b é uma sequência de escape que representa um caractere de retrocesso
Console.WriteLine(backspace); // imprime: caractere de retrocesso

// unicode
char unicode = '\u0041'; // \u seguido de quatro dígitos hexadecimais representa um caractere Unicode
Console.WriteLine(unicode); // imprime: A
```



# String

As strings são uma cadeia de caracters ou seja são mais de um caracter. Exemplo: "Hello World" é uma string.

Para criar uma variável do tipo string basta usar aspas duplas "" e colocar o texto dentro delas.
Exemplo:

```CSHARP
string nome;
nome = "João";
```

```CSHARP
string nome = "João";
Console.WriteLine(nome); // João
```

Você pode concatenar duas strings usando o operador +, exemplo:

```CSHARP
string nome = "João";
string sobrenome = "Silva";
string nomeCompleto = nome + " " + sobrenome; // João Silva
Console.WriteLine(nomeCompleto);
```

Warning:

IMPORTANTE: Strings SEMPRE serão com aspas duplas ("") e não simples ('')

Mesmo que inicializarmos uma variavel com string e deixar com um caracter e aspas duplas, ela será ainda uma string:

```CSHARP
string letra = "a"; // a
Console.WriteLine(letra.GetType()); // System.String
```



# Var

Var é uma palavra reservada do C#, que permite declarar variáveis sem especificar o tipo de dado. O compilador infere automaticamente o tipo da variável com base no valor atribuído a ela.

Aqui está um exemplo simples:

```CSHARP
var nome = "João";
int idade = 25;
double altura = 1.75;

Console.WriteLine($"Nome: {nome}, Idade: {idade}, Altura: {altura}");
```

Neste exemplo, não precisamos especificar explicitamente os tipos das variáveis `nome`, `idade` e `altura`. O compilador infere que `nome` é do tipo string, `idade` é do tipo int e `altura` é do tipo double.

MAS temos uma questão, o tipo que o compilador inferiu pela primeira vez sobre a variavel não pode ser alterado depois

Então se tivermos, a varivel `nome` como var e sendo inferido que ela é uma string, mas depois quisermos atribuir um inteiro para ela, teremos um erro:

```CSHARP
var nome = "João"; // Inferência de tipo: string
nome = 4; // Erro! Não é possível atribuir um inteiro a uma variável do tipo string.
```

![Erro de conversão implicita string para int](images/Erro%20de%20convers%C3%A3o%20implicita%20string%20para%20int)



# Object

É um tipo de dado genérico que pode aceitar qualquer tipo de valor ou objeto

Usado para por exemplo quando não sabe o tipo da informação ou ela é de varios tipos diferentes

```CSHARP
object obj = 10;
obj = "Hello World";
```

Note:

OBS: Não é recomendado usar pois a conversão entre os tipos deve ser feita manualmente e isso pode gerar erros em tempo de execução.

## Boxing and Unboxing

Boxing: Converte um tipo primitivo em object.

* Exemplo:

```CSHARP
int i = 5; // Tipo primitivo int
object obj = i; // Boxing, converte o tipo int em object
```

Unboxing: Converte um object em um tipo primitivo.

* Exemplo:

```CSHARP
object obj = 5; // Objeto do tipo object com valor inteiro
int i = (int)obj; // Unboxing, converte o objeto em um tipo primitivo int
```

Note:

Podemos pensar nesse boxing como um ato de colocar algo dentro de uma caixa, cujo o conteúdo pode ser qualquer coisa.

E o unboxing seria o ato de tirar algo dessa caixa.

Note:

Uma diferença entre `var`e `object` é que no caso do object você não precisa iniciar um valor por exemplo:

```CSHARP
object obj;
```

E quando fazer uma reatribuição de valor de um tipo diferente não dara problema, diferente do `var`:

```CSHARP
var var = 10;
var = "Hello World"; // Erro: Cannot implicitly convert type 'string' to 'int'
```

No caso do `object`, podemos fazer assim sem problemas:

```CSHARP
object obj = 10;
obj = "Hello World";
```



# Nullable Types

O tipo `null` significa "nulo" ou "vazio". Em C#, o valor padrão de um tipo é sempre definido como nulo. Por exemplo, se você declarar uma variável do tipo inteiro e não atribuir nenhum valor a ela, seu valor será zero.

Note:

Null é diferente de 0 (zero) e uma string vazia ("")". Null indica que a variável não tem nenhum valor válido enquanto 0 é um valor numérico válido.

E todo tipo primitivo ou complexo pode  receber nulo

Podemos marcar como Nullable Type, podemos fazer isso com:

Note:

A sintaxe para criar um tipo Nullable é colocando um ponto de interrogação após o nome do tipo.

```CSHARP
int? x = null;
```



# Alias

Alias, é um apelido que todo tipo no .NET tem por exemplo:

```CSHARP
int i = 0; // int é o alias de System.Int32
System.Int32 j = 1; // aqui estamos usando a classe Int32 diretamente.
```

O mesmo acontece com outros tipos como: `string` e `bool`, etc.

Note:

Você pode ver todos os aliases em [https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/built-in-types](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/built-in-types)



# Valores Parões

Todo tipo built-in possui um valor padrão.

Por exemplo, o valor padrão de `int` é 0 e o valor padrão de `bool` é false.

Note:

O valor padrão de uma variável não inicializada é sempre seu valor padrão.

## Tabela com alguns valores padrões:

| Tipo |Valor Padrão |
----------------------
| int |0 |
| bool |false |
| string |null |
| double |0.0 |
| float |0.0f |
| char |'\0' |
| decimal |0m |
| long |0L |
| short |0 |
| byte |0 |
| ulong |0UL |
| ushort |0U |
| uint |0U |
| sbyte |0S |
| DateTime |1/1/0001 |
| TimeSpan |0:00:00 |
| Guid |00000000-0000-0000-0000-0000000 |



# Casting

Em C#, "casting" (ou conversão explícita) é o processo de instruir o compilador a tratar uma variável de um tipo como se fosse de outro tipo. É uma operação fundamental, mas que deve ser compreendida para evitar perda de dados ou erros em tempo de execução.

O casting é diferente de usar classes utilitárias como `Convert` ou métodos como `Parse`. O casting é uma operação mais direta e de nível mais baixo, usada principalmente entre tipos numericamente compatíveis ou dentro de uma hierarquia de classes (herança).

## Conversão Implícita (Casting Implícito)

A conversão implícita, também conhecida como widening conversion, ocorre automaticamente quando um valor de um tipo "menor" é atribuído a uma variável de um tipo "maior", onde não há risco de perda de dados. É uma operação segura, e o compilador a realiza por você.

```CSHARP
// Um int (32 bits) cabe facilmente em um long (64 bits).
int meuInt = 2147483647;
long meuLong = meuInt; // Conversão implícita, totalmente segura.

// Um int (inteiro) cabe facilmente em um double (ponto flutuante).
int numero = 10;
double meuDouble = numero; // Conversão implícita. O valor se torna 10.0.

Console.WriteLine(meuDouble); // Saída: 10
```

## Conversão Explícita (Casting Explícito)

A conversão explícita, também chamada de narrowing conversion, é necessária quando há risco de perda de dados. Você deve instruir o compilador explicitamente usando a sintaxe de cast `(novoTipo)`. Ao fazer isso, você está dizendo ao compilador: "Eu sei que isso pode falhar ou perder dados, mas eu assumo a responsabilidade."

```CSHARP
double salario = 2599.95;

// Forçar a conversão de double para int. A parte decimal será perdida (truncada).
// Você DEVE usar o (int) para que o código compile.
int salarioInteiro = (int)salario;

Console.WriteLine(salarioInteiro); // Saída: 2599 (a informação .95 foi perdida)

// Outro exemplo de risco: converter um número grande para um tipo menor
long numeroGrande = 3000000000; // 3 bilhões

// int só pode armazenar até ~2.1 bilhões. Isso causará um Overflow.
// O resultado será um número inesperado e incorreto, sem lançar exceção em um contexto unchecked.
int intPequeno = (int)numeroGrande;

Console.WriteLine(intPequeno); // Saída: -1294967296 (lixo de memória)
```

Warning:

O casting explícito de tipos numéricos pode levar à **perda de dados** (truncamento) ou **estouro de capacidade** (overflow), resultando em valores incorretos. Use-o apenas quando tiver certeza de que o valor de origem caberá no tipo de destino.

## Casting em Programação Orientada a Objetos

O casting é essencial ao trabalhar com herança de classes.

```CSHARP
// Cenário de exemplo
public class Animal { }
public class Cachorro : Animal { public void Latir() { } }
public class Gato : Animal { public void Miar() { } }
```

### Upcasting (Implícito e Seguro)

Upcasting é converter uma referência de uma classe derivada (filha) para uma de sua classe base (mãe). Isso é sempre seguro e, portanto, implícito.

```CSHARP
Cachorro meuCachorro = new Cachorro();

// Upcasting: tratando um Cachorro como um Animal genérico.
// Isso é útil para criar listas de diferentes tipos de animais.
Animal animalGenerico = meuCachorro; // Upcasting implícito.
```

### Downcasting (Explícito e Arriscado)

Downcasting é o oposto: tentar converter uma referência de classe base de volta para sua classe derivada original. Isso é arriscado porque o `Animal` genérico poderia ser um `Gato`, e não um `Cachorro`. Tentar um downcast inválido lança uma `InvalidCastException`.

```CSHARP
// ...continuando de cima

// Tentativa de Downcasting
// O compilador exige o (Cachorro) porque a operação pode falhar.
Cachorro cachorroEspecifico = (Cachorro)animalGenerico; 
cachorroEspecifico.Latir(); // Funciona!

// Exemplo de falha
Animal outroAnimal = new Gato();
// A linha abaixo compila, mas lançará uma InvalidCastException em tempo de execução,
// porque um Gato não pode ser tratado como um Cachorro.
// Cachorro caoImpossivel = (Cachorro)outroAnimal; 
```

## 

Alternativas Seguras para Downcasting: `as` e `is`

Para evitar exceções, o C# fornece operadores mais seguros para downcasting.

* `is`: Verifica se a conversão é possível, retornando `true` ou `false`.

* `as`: Tenta a conversão. Se for bem-sucedida, retorna o objeto convertido. Se falhar, retorna `null` em vez de lançar uma exceção.

```CSHARP
Animal animalMisterioso = new Gato();

// Usando 'is' para verificar antes de converter
if (animalMisterioso is Cachorro)
{
    Cachorro caoVerificado = (Cachorro)animalMisterioso; // Seguro, mas verboso
    caoVerificado.Latir();
}
else
{
    Console.WriteLine("O animal misterioso não é um cachorro.");
}

// Usando 'as' para uma conversão segura e concisa (a abordagem preferida)
Cachorro caoComAs = animalMisterioso as Cachorro;
if (caoComAs != null)
{
    caoComAs.Latir();
}
else
{
    Console.WriteLine("A conversão com 'as' falhou, o animal não é um cachorro.");
}
```

## 

Guia Rápido: Casting vs. `Convert` vs. `Parse`

| Operação |Quando Usar |Exemplo |
----------------------------------
| Casting |Entre tipos numéricos ou em hierarquias de classes. |`int i = (int)10.5;` |
| `Convert` |Conversão segura entre muitos tipos base, especialmente com `nulls`. |`int i = Convert.ToInt32(null);` |
| `Parse` |Apenas para converter uma `string` para seu tipo correspondente. |`int i = int.Parse("10");` |



# Implicit Casting

A conversão implicita é quando  podemos executar essa transformação apenas com a passagem de dados

E os tipos são compatíveis entre si, como por exemplo:

* int -> long

* float -> double

* short -> int

* char -> int

## Exemplos:

```CSHARP
float value = 25.8f;
int newValue = (int)value; // Conversão implícita
```

Note:

Nesse caso, estamos atribuindo um valor do tipo float à uma variável do tipo int. O compilador irá realizar a conversão automaticamente, pois o tipo float pode ser convertido em um inteiro sem perda de precisão.



# Explicit Casting

Ocorre quando os tipos não são compativeis e é dada pelo uso do tipo entre parênteses antes da atribuição

## Exemplos:

```CSHARP
int inteiro = 100;
uint inteiroSemSinal = (uint)inteiro; //Conversão de int para uint
```



# Parse

O método `Parse` é uma funcionalidade estática presente na maioria dos tipos de valor do C# (como `int`, `double`, `bool`, `DateTime`, etc.). Sua função específica é converter a representação em string de um valor em uma instância real daquele tipo.

É a ferramenta ideal quando você tem um texto e precisa que ele se torne um tipo de dado funcional.

```CSHARP
string textoNumero = "123";

// O método Parse converte a string "123" para o inteiro 123.
int numero = int.Parse(textoNumero);

Console.WriteLine(numero * 2); // Saída: 246
Console.WriteLine(numero.GetType().Name); // Saída: Int32
```

## 

O Risco do `Parse`: Exceções

O método `Parse` é otimista: ele assume que a conversão será bem-sucedida. Se a string de entrada não estiver em um formato válido ou for nula, ele lançará uma exceção, interrompendo o fluxo normal do programa.

* `FormatException`: A string não corresponde ao formato esperado.

* `ArgumentNullException`: A string fornecida é `null`.

* `OverflowException`: O número na string é grande ou pequeno demais para o tipo de destino.

Para usar `Parse` de forma segura, você deve envolvê-lo em um bloco `try-catch`:

```CSHARP
string entradaUsuario = "não é um número";
try
{
    int resultado = int.Parse(entradaUsuario);
    Console.WriteLine($"Conversão bem-sucedida: {resultado}");
}
catch (FormatException)
{
    Console.WriteLine("Erro: O formato da entrada é inválido.");
}
catch (ArgumentNullException)
{
    Console.WriteLine("Erro: A entrada não pode ser nula.");
}
```

## 

A Alternativa Segura e Eficiente: `TryParse`

Lançar e capturar exceções é um processo computacionalmente caro. Para cenários de validação (como processar input de um usuário), onde uma falha de conversão é um evento esperado, o C# oferece uma alternativa muito mais eficiente: o padrão `TryParse`.

O método `TryParse` tenta realizar a conversão e, em vez de lançar uma exceção, ele retorna um `bool` que indica se a operação foi bem-sucedida. O valor convertido é retornado através de um parâmetro `out`.

```CSHARP
string entradaDoUsuario = "42";

// Tenta converter a string. 
// Se conseguir, 'numeroConvertido' receberá o valor 42 e o método retornará 'true'.
// Se não conseguir, 'numeroConvertido' receberá 0 (valor padrão) e o método retornará 'false'.
if (int.TryParse(entradaDoUsuario, out int numeroConvertido))
{
    // Este bloco só executa se a conversão funcionar
    Console.WriteLine($"Sucesso! O número é {numeroConvertido}");
}
else
{
    // Este bloco só executa se a conversão falhar
    Console.WriteLine("Falha na conversão. Por favor, insira um número válido.");
}
```

### 

Por que `TryParse` é melhor?

1. Performance: Evita o alto custo de criar e gerenciar exceções.

2. Clareza: O código fica mais limpo e a intenção (validar e converter) é mais clara.

3. Simplicidade: Permite a validação e a atribuição em uma única linha dentro de uma condição `if`.

## 

Tabela de Referência de Métodos `Parse` e `TryParse`

Abaixo está uma tabela de referência para os métodos `Parse` e `TryParse` nos tipos mais comuns.

| Tipo |Método `Parse` (Lança Exceção) |Método `TryParse` (Retorna `bool`) |
----------------------------------------------------------------------------
| `int` |`int.Parse(str)` |`int.TryParse(str, out int val)` |
| `long` |`long.Parse(str)` |`long.TryParse(str, out long val)` |
| `double` |`double.Parse(str)` |`double.TryParse(str, out double val)` |
| `decimal` |`decimal.Parse(str)` |`decimal.TryParse(str, out decimal val)` |
| `float` |`float.Parse(str)` |`float.TryParse(str, out float val)` |
| `bool` |`bool.Parse(str)` |`bool.TryParse(str, out bool val)` |
| `DateTime` |`DateTime.Parse(str)` |`DateTime.TryParse(str, out DateTime val)` |
| `Guid` |`Guid.Parse(str)` |`Guid.TryParse(str, out Guid val)` |

## Tópico Avançado: Sensibilidade à Cultura

Um detalhe crucial que diferencia um desenvolvedor sênior é o entendimento sobre cultura (`CultureInfo`). O método `Parse` por padrão utiliza as regras de formatação do sistema operacional onde o código está rodando.

Isso pode causar bugs difíceis de rastrear. Por exemplo, a string `"1,234.56"` representa mil duzentos e trinta e quatro em português, mas em inglês o `.` é o separador decimal.

```CSHARP
using System.Globalization;

string numeroAlemao = "1.234,56"; // Ponto como separador de milhar, vírgula como decimal

// Usando a cultura alemã (de-DE) para interpretar a string corretamente
CultureInfo culturaAlema = new CultureInfo("de-DE");
double valor = double.Parse(numeroAlemao, culturaAlema);

Console.WriteLine(valor); // Saída: 1234.56 (convertido para o formato padrão do sistema)

// A linha abaixo lançaria uma FormatException em um sistema com cultura pt-BR ou en-US
// double valorIncorreto = double.Parse(numeroAlemao); 
```

O `TryParse` também possui sobrecargas que aceitam `CultureInfo` para uma conversão segura e culturalmente correta.

## 

Guia de Decisão: `Parse` vs. `TryParse`

* Use `Parse` quando: * Você tem 100% de certeza que a string é válida (ex: vem de uma fonte interna confiável, como um valor fixo no código ou um banco de dados com dados já validados). * Uma falha na conversão representa um erro excepcional e inesperado no seu sistema.

* Use `TryParse` quando: * A string vem de uma fonte externa e não confiável (input de usuário, arquivo de texto, resposta de API, etc.). * A falha na conversão é um cenário esperado e faz parte da lógica de validação do seu programa.



# Convert

A classe `System.Convert` é uma ferramenta essencial no C#, fornecendo um conjunto de métodos estáticos para realizar conversões entre os tipos de dados base (primitivos). Ela atua como uma solução robusta e explícita, oferecendo mais flexibilidade e segurança em comparação com o casting direto ou os métodos `Parse`.

Pense na classe `Convert` como um tradutor universal para os tipos de dados do .NET.

## 

`Convert` vs. Casting vs. `Parse`

É crucial para um desenvolvedor C# entender quando usar cada mecanismo de conversão.

| Mecanismo |Sintaxe |Uso Principal |Comportamento em Falha |
-------------------------------------------------------------
| Casting |`(novoTipo)valor;` |Entre tipos numéricos compatíveis ou em hierarquias de classes (upcasting/downcasting). |`InvalidCastException` em tempo de execução se a conversão for inválida. |
| Parse |`tipo.Parse(string);` |Exclusivamente para converter uma `string` em seu tipo correspondente. |`FormatException` se a string não estiver no formato correto; `ArgumentNullException` se for nula. |
| Convert |`Convert.ToNovoTipo(valor);` |Entre uma grande variedade de tipos (números, strings, booleanos, objetos, etc.). |`FormatException` para strings mal formatadas; `OverflowException` para estouro de capacidade. |

### 

A Grande Vantagem: Tratamento de `null`

A principal diferença e vantagem da classe `Convert` é a forma como ela lida com valores `null`. Ao contrário do casting ou do `Parse`, que lançam uma exceção, `Convert` retorna o valor padrão do tipo de destino.

```CSHARP
string textoNulo = null;

// Lança ArgumentNullException
// int numeroComParse = int.Parse(textoNulo); 

// Retorna 0 (valor padrão de int)
int numeroComConvert = Convert.ToInt32(textoNulo); 

Console.WriteLine(numeroComConvert); // Saída: 0
```

Esse comportamento torna o `Convert` a escolha mais segura e previsível ao lidar com dados que podem ser nulos, como valores vindos de bancos de dados, APIs ou input do usuário.

## Comportamento de Arredondamento

Ao converter um número de ponto flutuante (como `double` ou `float`) para um inteiro, a classe `Convert` utiliza o "Arredondamento do Banqueiro" (`MidpointRounding.ToEven`). Neste método, números que estão exatamente no meio (como 2.5 ou 3.5) são arredondados para o número par mais próximo.

```CSHARP
double valor1 = 2.5;
double valor2 = 3.5;
double valor3 = 4.6;

Console.WriteLine(Convert.ToInt32(valor1)); // Saída: 2 (arredonda para o par mais próximo)
Console.WriteLine(Convert.ToInt32(valor2)); // Saída: 4 (arredonda para o par mais próximo)
Console.WriteLine(Convert.ToInt32(valor3)); // Saída: 5 (arredondamento normal)
```

## Exemplos de Conversões Comuns

A classe `Convert` é extremamente versátil.

```CSHARP
// De string para int
string strNumero = "123";
int numero = Convert.ToInt32(strNumero);

// De int para string
int valorInt = 456;
string strValor = Convert.ToString(valorInt);

// De double para int (com arredondamento)
double salario = 2589.72;
int salarioInt = Convert.ToInt32(salario); // Resultado: 2590

// De string para booleano (não diferencia maiúsculas/minúsculas)
string strBool = "True";
bool valorBool = Convert.ToBoolean(strBool); // Resultado: true

// De qualquer tipo para string
bool ativo = false;
string strAtivo = Convert.ToString(ativo); // Resultado: "False"

// De object para int (seguro contra nulos)
object objValor = null;
int valorObj = Convert.ToInt32(objValor); // Resultado: 0
```

## 

Tabela de Referência de Métodos `Convert`

Abaixo está uma tabela de referência rápida para os métodos de conversão mais utilizados da classe `Convert`.

| Método |Descrição |Exemplo de Uso |
-------------------------------------
| `Convert.ToBoolean(valor)` |Converte um valor (string, número, etc.) para `bool`. |`bool b = Convert.ToBoolean("true");` |
| `Convert.ToByte(valor)` |Converte um valor para `byte` (inteiro de 8 bits sem sinal). |`byte y = Convert.ToByte(12);` |
| `Convert.ToChar(valor)` |Converte uma string de um caractere ou número para `char`. |`char c = Convert.ToChar('A');` |
| `Convert.ToDateTime(valor)` |Converte uma string (em formato de data/hora válido) para `DateTime`. |`DateTime dt = Convert.ToDateTime("2025-07-14");` |
| `Convert.ToDecimal(valor)` |Converte um valor para `decimal` (alta precisão). |`decimal d = Convert.ToDecimal("123.45");` |
| `Convert.ToDouble(valor)` |Converte um valor para `double` (ponto flutuante de precisão dupla). |`double o = Convert.ToDouble("123.45");` |
| `Convert.ToInt16(valor)` |Converte um valor para `short` (inteiro de 16 bits). |`short s = Convert.ToInt16("123");` |
| `Convert.ToInt32(valor)` |Converte um valor para `int` (inteiro de 32 bits). |`int i = Convert.ToInt32("123");` |
| `Convert.ToInt64(valor)` |Converte um valor para `long` (inteiro de 64 bits). |`long l = Convert.ToInt64("123");` |
| `Convert.ToString(valor)` |Converte qualquer tipo base para sua representação em `string`. |`string str = Convert.ToString(123.45);` |

## Tópico Avançado: Conversão de Base Numérica

Um recurso poderoso e muitas vezes subutilizado da classe `Convert` é a capacidade de converter números entre diferentes bases (binário, octal, decimal, hexadecimal).

```CSHARP
// Convertendo um inteiro para sua representação em string binária e hexadecimal
int numeroDecimal = 255;
string binario = Convert.ToString(numeroDecimal, 2);    // Base 2
string hexadecimal = Convert.ToString(numeroDecimal, 16); // Base 16

Console.WriteLine($"Decimal: {numeroDecimal}");   // Saída: Decimal: 255
Console.WriteLine($"Binário: {binario}");       // Saída: Binário: 11111111
Console.WriteLine($"Hexadecimal: {hexadecimal.ToUpper()}"); // Saída: Hexadecimal: FF

// Convertendo de volta para inteiro
int deBinario = Convert.ToInt32("11111111", 2);
int deHexadecimal = Convert.ToInt32("FF", 16);

Console.WriteLine($"De Binário: {deBinario}");       // Saída: De Binário: 255
Console.WriteLine($"De Hexadecimal: {deHexadecimal}"); // Saída: De Hexadecimal: 255
```

## Tratamento de Exceções

Apesar de sua flexibilidade, `Convert` ainda pode lançar exceções se a conversão for impossível.

* `FormatException`: Ocorre se uma string de entrada não estiver em um formato válido para o tipo de destino.

* `OverflowException`: Ocorre se o número de origem for muito grande (ou muito pequeno) para caber na capacidade do tipo de destino.

É uma boa prática envolver as chamadas de `Convert` em um bloco `try-catch` quando a entrada não for confiável.

```CSHARP
string valorGigante = "9999999999999999999999999999";
try
{
    int resultado = Convert.ToInt32(valorGigante);
    Console.WriteLine(resultado);
}
catch (FormatException ex)
{
    Console.WriteLine("Erro de formato: A string não é um número válido.");
}
catch (OverflowException ex)
{
    Console.WriteLine("Erro de Overflow: O número é grande demais para um inteiro.");
}
```

Tip:

Para cenários onde você espera que a conversão de uma string possa falhar e não quer lidar com exceções, a abordagem `tipo.TryParse()` continua sendo a melhor prática.



# Operadores Aritméticos

Operadores aritméticos são símbolos usados para realizar cálculos matemáticos em operandos numéricos. São a base da manipulação de números em C#.

## Tabela de Operadores Aritméticos

| Operador |Descrição |Exemplo |Resultado |
-------------------------------------------
| `+` |Adição |`5 + 3` |`8` |
| `-` |Subtração |`5 - 3` |`2` |
| `*` |Multiplicação |`5 * 3` |`15` |
| `/` |Divisão |`5 / 3` |`1` |
| `%` |Módulo (Resto da Divisão) |`5 % 3` |`2` |

### A Armadilha da Divisão de Inteiros

Um ponto de atenção crucial em C# é a divisão entre dois números inteiros. O resultado será sempre um inteiro, com a parte decimal sendo truncada (removida), não arredondada.

```CSHARP
int a = 5;
int b = 3;

// Como 'a' e 'b' são inteiros, o resultado é 1, não 1.66.
int resultadoInteiro = a / b; 
Console.WriteLine(resultadoInteiro); // Saída: 1
```

Para obter um resultado com precisão decimal, pelo menos um dos operandos deve ser um tipo de ponto flutuante (`double`, `float`, `decimal`).

```CSHARP
// Convertendo (casting) um dos inteiros para double antes da divisão
double resultadoDouble = (double)a / b;
Console.WriteLine(resultadoDouble); // Saída: 1.66666...
```

## Operadores de Incremento e Decremento

Estes operadores unários modificam uma variável, adicionando ou subtraindo 1. A posição do operador (`++` ou `--`) em relação à variável muda o comportamento da expressão.

* Pós-fixado (`variavel++` ou `variavel--`): O valor da variável é primeiro retornado para a expressão e depois modificado.

* Pré-fixado (`++variavel` ou `--variavel`): O valor da variável é primeiro modificado e depois o novo valor é retornado para a expressão.

```CSHARP
int a = 5;
int b = 5;

// Pós-fixado: 'c' recebe o valor original de 'a' (5), depois 'a' vira 6.
int c = a++; 

// Pré-fixado: 'b' primeiro vira 6, depois 'd' recebe o novo valor de 'b' (6).
int d = ++b;

Console.WriteLine($"a: {a}, c: {c}"); // Saída: a: 6, c: 5
Console.WriteLine($"b: {b}, d: {d}"); // Saída: b: 6, d: 6
```

## Precedência de Operadores

A precedência define a ordem em que as operações são executadas em uma expressão complexa. Operadores com maior precedência são avaliados primeiro.

| Ordem |Categoria |Operadores |
--------------------------------
| 1 |Primário |`()` (Parênteses para forçar a ordem) |
| 2 |Unário |`++` (pré-fixado), `--` (pré-fixado), `+` (positivo), `-` (negativo) |
| 3 |Multiplicativo |`*`, `/`, `%` |
| 4 |Aditivo |`+`, `-` |
| 5 |Pós-fixado |`++` (pós-fixado), `--` (pós-fixado) |

Note:

O operador de exponenciação (`**`) não existe em C#. Para cálculos de potência, utilize o método `Math.Pow(base, expoente)`.

Você pode usar parênteses `()` para forçar uma ordem de avaliação diferente da padrão, o que também melhora a legibilidade do código.

```CSHARP
// Sem parênteses: 2 * 3 = 6, depois 6 + 4 = 10
int resultado1 = 2 * 3 + 4; // resultado1 = 10

// Com parênteses: 3 + 4 = 7, depois 2 * 7 = 14
int resultado2 = 2 * (3 + 4); // resultado2 = 14
```



# Operadores de Atribuição

Operadores de atribuição são usados para designar um valor a uma variável. O operador de atribuição fundamental é o sinal de igual (`=`), que atribui o valor do operando à direita para a variável à esquerda.

```CSHARP
// A variável 'idade' recebe o valor 30.
int idade = 30;

// A variável 'nome' recebe o valor da string "Alice".
string nome = "Alice";
```

## Operadores de Atribuição Composta

C# oferece operadores de atribuição composta que combinam uma operação aritmética com a atribuição. Eles são atalhos úteis que tornam o código mais conciso e, em alguns casos, mais eficiente.

A expressão `x op= y` é, em geral, equivalente a `x = x op y`, onde `op` é um operador aritmético.

### Tabela de Operadores de Atribuição Composta

| Operador |Exemplo |Equivalente a |Descrição |
-----------------------------------------------
| `+=` |`x += y` |`x = x + y` |Adiciona `y` a `x` e atribui o resultado a `x`. |
| `-=` |`x -= y` |`x = x - y` |Subtrai `y` de `x` e atribui o resultado a `x`. |
| `*=` |`x *= y` |`x = x * y` |Multiplica `x` por `y` e atribui o resultado a `x`. |
| `/=` |`x /= y` |`x = x / y` |Divide `x` por `y` e atribui o resultado a `x`. |
| `%=` |`x %= y` |`x = x % y` |Calcula o resto da divisão de `x` por `y` e atribui a `x`. |

### Exemplos Práticos

```CSHARP
int saldo = 100;

saldo += 50; // saldo agora é 150 (100 + 50)
Console.WriteLine($"Após depósito: {saldo}");

saldo -= 30; // saldo agora é 120 (150 - 30)
Console.WriteLine($"Após saque: {saldo}");

int multiplicador = 5;
multiplicador *= 2; // multiplicador agora é 10 (5 * 2)
Console.WriteLine($"Multiplicado: {multiplicador}");

int dividendo = 20;
dividendo /= 4; // dividendo agora é 5 (20 / 4)
Console.WriteLine($"Dividido: {dividendo}");

int resto = 10;
resto %= 3; // resto agora é 1 (10 % 3)
Console.WriteLine($"Resto: {resto}");
```

Note:

O uso de operadores de atribuição composta é considerado uma boa prática em C#, pois pode levar a um código mais limpo e fácil de ler, especialmente em operações de atualização de variáveis.



# Operadores de Comparação

Operadores de comparação (ou relacionais) são usados para comparar dois operandos. O resultado de uma operação de comparação é sempre um valor booleano: `true` ou `false`. Eles são a base para a tomada de decisões e o controle de fluxo em C#, sendo essenciais em estruturas como `if`, `while` e `for`.

## Tabela de Operadores de Comparação

| Operador |Descrição |Exemplo (com `a = 5`, `b = 10`) |Resultado |
-------------------------------------------------------------------
| `==` |Igual a |`a == 5` |`true` |
| `!=` |Diferente de |`a != b` |`true` |
| `<` |Menor que |`a < b` |`true` |
| `>` |Maior que |`a > b` |`false` |
| `<=` |Menor ou igual a |`a <= 5` |`true` |
| `>=` |Maior ou igual a |`b >= 10` |`true` |

## Exemplos de Uso no Controle de Fluxo

O principal uso dos operadores de comparação é em declarações condicionais para direcionar o fluxo do programa.

```CSHARP
int idade = 18;

// Usando '==' para verificar igualdade
if (idade == 18)
{
    Console.WriteLine("Tem exatamente 18 anos.");
}

// Usando '>=' para verificar maioridade
if (idade >= 18)
{
    Console.WriteLine("É maior de idade.");
}

// Usando '!=' para verificar diferença
string nome = "Alice";
if (nome != "Bob")
{
    Console.WriteLine("O nome não é Bob.");
}

// Usando em um loop 'while'
int contador = 0;
while (contador < 5)
{
    Console.WriteLine($"O contador é {contador}");
    contador++; // Essencial para evitar um loop infinito
}
```

## Comparando Tipos de Referência vs. Tipos de Valor

É crucial entender a diferença ao usar `==` com tipos de valor e tipos de referência.

* Tipos de Valor (`int`, `double`, `bool`, `struct`): O operador `==` compara os valores reais contidos nas variáveis. ```CSHARP int a = 10; int b = 10; Console.WriteLine(a == b); // Saída: true (porque 10 é igual a 10) ```

* Tipos de Referência (`string`, `class`, `array`): Por padrão, o operador `==` compara as referências de memória, ou seja, ele verifica se as duas variáveis apontam para o mesmo objeto na memória, e não se seus conteúdos são iguais. ```CSHARP public class Pessoa { public string Nome { get; set; } } Pessoa p1 = new Pessoa { Nome = "Alex" }; Pessoa p2 = new Pessoa { Nome = "Alex" }; Pessoa p3 = p1; Console.WriteLine(p1 == p2); // Saída: false (são dois objetos diferentes na memória) Console.WriteLine(p1 == p3); // Saída: true (ambos apontam para o mesmo objeto) ```

Note:

O tipo `string` é uma exceção especial. Embora seja um tipo de referência, o operador `==` foi sobrecarregado para comparar o **conteúdo** das strings, não suas referências. Portanto, `"hello" == "hello"` retorna `true`, que é o comportamento que a maioria dos desenvolvedores espera.



# Operadores Lógicos e Condicionais

Em C#, operadores lógicos e condicionais são usados para trabalhar com valores booleanos (`true`/`false`) e para tomar decisões baseadas em condições. Eles são a cola que une as comparações para criar regras de negócio e fluxos de controle complexos.

## Operadores Lógicos Condicionais (Short-Circuiting)

Estes são os operadores lógicos mais comuns. Eles são chamados de "condicionais" ou "short-circuiting" porque só avaliam o segundo operando se for estritamente necessário.

| Operador |Nome |Exemplo |Descrição |
--------------------------------------
| `&&` |E (AND) |`expr1 && expr2` |Retorna `true` somente se ambas as expressões forem `true`. |
| `\|\|` |OU (OR) |`expr1 \|\| expr2` |Retorna `true` se pelo menos uma das expressões for `true`. |
| `!` |NÃO (NOT) |`!expr1` |Inverte o valor booleano da expressão (de `true` para `false` e vice-versa). |

### A Importância do Short-Circuiting

* `&&` (E): Se a primeira expressão (`expr1`) for `false`, o resultado da operação será sempre `false`, independentemente da segunda expressão. Portanto, `expr2` não é avaliada. Isso é útil para evitar erros. ```CSHARP string nome = null; // A segunda verificação (nome.Length > 0) nunca é executada, evitando uma NullReferenceException. if (nome != null && nome.Length > 0) { Console.WriteLine("Nome válido."); } else { Console.WriteLine("Nome inválido ou nulo."); } ```

* `||` (OU): Se a primeira expressão (`expr1`) for `true`, o resultado da operação será sempre `true`. Portanto, `expr2` não é avaliada. Isso pode ser usado para otimização. ```CSHARP bool usuarioAdmin = true; // A função VerificarPermissao() nunca é chamada, economizando processamento. if (usuarioAdmin || VerificarPermissao()) { Console.WriteLine("Acesso concedido."); } ```

## Operadores Condicionais

### 

Operador Ternário (`? :`)

O operador condicional ternário é um atalho conciso para uma instrução `if-else`. Ele avalia uma condição booleana e retorna um de dois valores.

Sintaxe: `condição ? valor_se_verdadeiro : valor_se_falso;`

```CSHARP
int idade = 20;
string status = (idade >= 18) ? "Maior de idade" : "Menor de idade";

Console.WriteLine(status); // Saída: Maior de idade

// O código acima é um atalho para:
// string status;
// if (idade >= 18)
// {
//     status = "Maior de idade";
// }
// else
// {
//     status = "Menor de idade";
// }
```

### 

Operador de Coalescência Nula (`??`)

Este operador é usado para fornecer um valor padrão para tipos de referência ou tipos de valor anuláveis. Ele retorna o operando da esquerda se ele não for nulo; caso contrário, ele retorna o operando da direita.

```CSHARP
string nomeDoBanco = null;

// Se nomeDoBanco for nulo, use "Convidado". Caso contrário, use o próprio valor.
string nomeUsuario = nomeDoBanco ?? "Convidado";

Console.WriteLine(nomeUsuario); // Saída: Convidado

string nomeValido = "Alice";
nomeUsuario = nomeValido ?? "Convidado";
Console.WriteLine(nomeUsuario); // Saída: Alice
```

## Tópico Avançado: Operadores Lógicos Booleanos e Bitwise

C# também possui operadores que parecem lógicos, mas têm um propósito diferente e mais específico. É crucial não confundi-los com os operadores condicionais `&&` e `||`.

### 

Operadores Lógicos Booleanos (`&` e `|`)

Estes operadores são similares a `&&` e `||`, mas com uma diferença fundamental: eles sempre avaliam ambos os operandos, ou seja, não fazem short-circuiting. Seu uso é raro em lógica condicional do dia a dia.

| Operador |Nome |Exemplo |Descrição |
--------------------------------------
| `&` |E (AND) Lógico |`expr1 & expr2` |Retorna `true` se ambas forem `true`. Sempre avalia as duas expressões. |
| `\|` |OU (OR) Lógico |`expr1 \| expr2` |Retorna `true` se uma delas for `true`. Sempre avalia as duas expressões. |
| `^` |OU Exclusivo (XOR) |`expr1 ^ expr2` |Retorna `true` se apenas uma das expressões for `true`. |

### 

Operadores Bitwise (`&`, `|`, `^`, `~`, `<<`, `>>`)

Quando usados com tipos de dados inteiros (`int`, `long`, `byte`, etc.), estes símbolos atuam como operadores bitwise. Eles manipulam a representação binária (os bits) dos números, sendo usados em cenários de baixo nível, como manipulação de flags, criptografia ou otimizações de performance.

* `&` (AND): Compara os bits de dois números. Um bit de resultado é 1 somente se ambos os bits correspondentes forem 1.

* `|` (OR): Compara os bits. Um bit de resultado é 1 se pelo menos um dos bits correspondentes for 1.

* `^` (XOR): Compara os bits. Um bit de resultado é 1 se os bits correspondentes forem diferentes.

* `~` (NOT): Inverte todos os bits de um número.

* `<<` (Shift Left): Desloca os bits para a esquerda, preenchendo com zeros (multiplicação por 2).

* `>>` (Shift Right): Desloca os bits para a direita (divisão por 2).

```CSHARP
// Exemplo de Bitwise AND
//   5 = 0101 (binário)
//   3 = 0011 (binário)
// -------------------
// AND = 0001 (binário) = 1 (decimal)
int resultado = 5 & 3;
Console.WriteLine(resultado); // Saída: 1
```



# Estruturas Condicionais

Estruturas condicionais permitem que um programa execute diferentes blocos de código com base em condições booleanas (`true` ou `false`). Elas são a principal maneira de criar lógica e tomar decisões em C#.

## 

A Estrutura `if`

A instrução `if` é a estrutura condicional mais fundamental. Ela executa um bloco de código somente se a condição especificada for `true`.

Sintaxe:

```
if (condição)
{
    // Bloco de código a ser executado se a condição for verdadeira.
}
```

Exemplo:

```CSHARP
int idade = 20;
if (idade >= 18)
{
    Console.WriteLine("Você é maior de idade.");
}
```

## 

A Estrutura `if-else`

A instrução `else` pode ser adicionada a um `if` para executar um bloco de código alternativo quando a condição do `if` for `false`.

Sintaxe:

```
if (condição)
{
    // Bloco de código se a condição for verdadeira.
}
else
{
    // Bloco de código se a condição for falsa.
}
```

Exemplo:

```CSHARP
int temperatura = 15;
if (temperatura > 25)
{
    Console.WriteLine("Está calor.");
}
else
{
    Console.WriteLine("Não está calor.");
}
```

## 

A Estrutura `if-else if-else`

Para testar múltiplas condições em sequência, você pode usar a estrutura `else if`. O C# avaliará as condições na ordem em que aparecem e executará o primeiro bloco de código cuja condição seja `true`. O bloco `else` final é opcional e serve como uma condição "pega-tudo" se nenhuma das anteriores for satisfeita.

Sintaxe:

```
if (condição1)
{
    // Bloco 1
}
else if (condição2)
{
    // Bloco 2
}
else
{
    // Bloco 3 (opcional)
}
```

Exemplo:

```CSHARP
int numero = 0;

if (numero > 0)
{
    Console.WriteLine("O número é positivo.");
}
else if (numero < 0)
{
    Console.WriteLine("O número é negativo.");
}
else
{
    Console.WriteLine("O número é zero.");
}
```

## Variações de Sintaxe e Boas Práticas

### 

Omissão de Chaves (`{}`)

Em C#, se o bloco de código dentro de uma instrução `if`, `else if` ou `else` contém apenas uma única linha de comando, as chaves `{}` são opcionais.

Exemplo:

```CSHARP
int temperatura = 30;

if (temperatura > 25)
    Console.WriteLine("Está calor.");
else
    Console.WriteLine("Não está calor.");
```

Warning:

Cuidado com a omissão de chaves!

Embora a sintaxe seja permitida, ela é uma fonte comum de bugs. Se você adicionar uma segunda linha de código ao `if` ou `else` sem adicionar as chaves, apenas a primeira linha será condicional. A segunda linha será executada incondicionalmente, o que pode levar a um comportamento inesperado.

Exemplo de Bug:

```CSHARP
bool usuarioLogado = false;

if (usuarioLogado)
    Console.WriteLine("Bem-vindo!");
    RenderizarPainelDeControle(); // Esta linha será executada SEMPRE, mesmo se o usuário não estiver logado!
```

Boa Prática: Para evitar erros e melhorar a legibilidade e a manutenção do código, é altamente recomendável sempre usar chaves, mesmo para blocos de uma única linha.

```CSHARP
// Forma segura e recomendada
if (usuarioLogado)
{
    Console.WriteLine("Bem-vindo!");
}
```

## 

A Instrução `switch`

A instrução `switch` é uma alternativa à estrutura `if-else if-else`, ideal para quando você precisa comparar uma única variável contra uma lista de valores constantes.

* `case`: Define um valor a ser comparado com a variável do `switch`.

* `break`: É obrigatório ao final de cada `case` para sair do `switch` e impedir a execução do próximo `case` (fall-through).

* `default`: É opcional e funciona como o `else` final, sendo executado se nenhum `case` corresponder.

Exemplo:

```CSHARP
int diaDaSemana = 3;
string nomeDoDia;

switch (diaDaSemana)
{
    case 1:
        nomeDoDia = "Domingo";
        break;
    case 2:
        nomeDoDia = "Segunda-feira";
        break;
    case 3:
        nomeDoDia = "Terça-feira";
        break;
    // ... outros casos
    default:
        nomeDoDia = "Dia inválido";
        break;
}

Console.WriteLine(nomeDoDia); // Saída: Terça-feira
```

## 

Expressões `switch` (C# 8.0 e superior)

Versões mais recentes do C# introduziram a expressão `switch`, uma forma mais moderna e concisa que é especialmente útil para atribuir um valor a uma variável com base em uma condição.

* É uma expressão, o que significa que ela retorna um valor.

* Usa a sintaxe `=>` (lambda).

* Não precisa de `case` ou `break`.

* Usa o descarte (`_`) para o caso `default`.

* Suporta pattern matching avançado.

Exemplo:

```CSHARP
int diaDaSemana = 3;

string nomeDoDia = diaDaSemana switch
{
    1 => "Domingo",
    2 => "Segunda-feira",
    3 => "Terça-feira",
    4 => "Quarta-feira",
    5 => "Quinta-feira",
    6 => "Sexta-feira",
    7 => "Sábado",
    _ => "Dia inválido" // Caso default
};

Console.WriteLine(nomeDoDia); // Saída: Terça-feira
```

### 

Quando Usar `if` vs. `switch`

* Use `if-else if`: Para condições complexas, comparações de intervalos (ex: `idade > 18 && idade < 60`) ou quando múltiplas variáveis estão envolvidas.

* Use `switch`: Para comparar uma única variável contra um conjunto de valores constantes e distintos. A expressão `switch` é a abordagem moderna e preferida quando disponível.



# Laço de Repetição for

O laço `for` em C# é uma estrutura de controle de fluxo que permite executar um bloco de código repetidamente. É ideal para situações em que o número de iterações é conhecido antes do início do loop.

A estrutura do `for` é composta por três partes principais, separadas por ponto e vírgula, que controlam a execução do laço:

1. Inicializador (`initializer`): Executado apenas uma vez, no início do laço. Geralmente, é aqui que uma variável de controle do laço é declarada e inicializada.

2. Condição (`condition`): Avaliada antes de cada iteração. Se a condição for `true`, o bloco de código dentro do laço é executado. Se for `false`, o laço é encerrado.

3. Iterador (`iterator`): Executado ao final de cada iteração. Normalmente, é usado para incrementar ou decrementar a variável de controle do laço.

## Sintaxe

A sintaxe básica do laço `for` é a seguinte:

```CSHARP
for (inicializador; condição; iterador)
{
    // Bloco de código a ser executado
}
```

### Exemplo Prático

O exemplo mais comum é iterar um número fixo de vezes. O código abaixo imprime os números de 0 a 9 no console.

```CSHARP
// Imprime os números de 0 a 9
for (int i = 0; i < 10; i++)
{
    Console.WriteLine($"O valor de i é: {i}");
}
```

Análise do Exemplo:

* `int i = 0;`: A variável `i` é declarada e inicializada com `0`. Isso acontece apenas uma vez.

* `i < 10;`: Antes de cada iteração, o programa verifica se `i` é menor que `10`.

* `i++`: Ao final de cada iteração, o valor de `i` é incrementado em 1.

* `Console.WriteLine(...)`: Este é o corpo do laço, que é executado enquanto a condição `i < 10` for verdadeira.

## Casos de Uso e Variações

### Laço Infinito

É possível criar um laço infinito omitindo todas as três partes da declaração `for`. Nesses casos, é preciso ter um mecanismo de saída dentro do corpo do laço, como a instrução `break`.

```CSHARP
for (;;)
{
    Console.WriteLine("Este é um laço infinito! Pressione 's' para sair.");
    if (Console.ReadKey().KeyChar == 's')
    {
        break; // Encerra o laço
    }
    Console.WriteLine();
}
```

### Múltiplas Variáveis

Você pode inicializar e iterar múltiplas variáveis dentro de um laço `for`.

```CSHARP
for (int i = 0, j = 10; i <= 10; i++, j--)
{
    Console.WriteLine($"i = {i}, j = {j}");
}
```

### Omitindo Partes

Qualquer uma das partes do `for` (inicializador, condição ou iterador) pode ser omitida, desde que a lógica seja controlada de outra forma.

```CSHARP
int i = 0;
for (; i < 5; )
{
    Console.WriteLine(i);
    i++; // O iterador é movido para dentro do corpo do laço
}
```

O laço `for` é uma ferramenta poderosa e flexível para controlar a repetição de tarefas em seus programas C#.



# Laço de Repetição while

O laço `while` em C# é uma estrutura de controle que executa um bloco de código repetidamente enquanto uma determinada condição booleana for `true`. Diferente do laço `for`, o `while` é ideal para situações em que o número de iterações não é conhecido de antemão.

A principal característica do `while` é que a condição é testada antes da execução do bloco de código. Se a condição for `false` na primeira verificação, o corpo do laço nunca será executado.

## Sintaxe

A sintaxe do laço `while` é simples e direta:

```CSHARP
while (condição)
{
    // Bloco de código a ser executado
}
```

* `condição`: Uma expressão booleana (`true` ou `false`). O laço continua enquanto esta expressão for `true`.

### Exemplo Prático

Vamos supor que queremos ler a entrada do usuário até que ele digite a palavra "sair".

```CSHARP
string entrada = "";
while (entrada.ToLower() != "sair")
{
    Console.Write("Digite algo (ou 'sair' para terminar): ");
    entrada = Console.ReadLine();
    Console.WriteLine($"Você digitou: {entrada}");
}

Console.WriteLine("Programa encerrado.");
```

Análise do Exemplo:

1. A variável `entrada` é inicializada como uma string vazia.

2. A condição `entrada.ToLower() != "sair"` é verificada. Na primeira vez, `"" != "sair"` é `true`, então o laço começa.

3. Dentro do laço, o programa solicita a entrada do usuário e a armazena na variável `entrada`.

4. O laço se repete, e a condição é verificada novamente com o novo valor de `entrada`.

5. Quando o usuário finalmente digita "sair", a condição se torna `false`, e o laço é encerrado.

## Cuidado com Laços Infinitos

Um erro comum ao usar o `while` é criar um laço infinito. Isso acontece se a condição de parada nunca for alcançada. É crucial garantir que alguma variável dentro da condição seja modificada no corpo do laço para que, em algum momento, a condição se torne `false`.

Exemplo de laço infinito (EVITAR):

```CSHARP
int i = 0;
while (i < 10)
{
    // Erro: a variável 'i' nunca é incrementada.
    // Este laço executará para sempre.
    Console.WriteLine("Isso é um laço infinito!");
}
```

Para corrigir, basta adicionar o iterador:

```CSHARP
int i = 0;
while (i < 10)
{
    Console.WriteLine(i);
    i++; // Correção: garante que o laço terminará
}
```

O laço `while` é fundamental para algoritmos onde a repetição depende de um estado que muda durante a execução, como processamento de dados, interação com o usuário ou espera por um evento.



# Laço de Repetição do-while

O laço `do-while` é uma variação do laço `while`. A principal e mais importante diferença é que o `do-while` garante que o bloco de código seja executado pelo menos uma vez.

Isso ocorre porque a condição booleana é verificada ao final de cada iteração, e não no início.

## Sintaxe

A sintaxe do `do-while` reflete essa característica: o bloco `do` vem antes da verificação `while`.

```CSHARP
do
{
    // Bloco de código a ser executado
} while (condição);
```

* `do { ... }`: O bloco de código que será executado.

* `while (condição)`: A expressão booleana que é avaliada no final de cada iteração. Se for `true`, o laço continua; se for `false`, ele termina. Note o ponto e vírgula obrigatório no final.

### Exemplo Prático

O `do-while` é especialmente útil para menus de opções ou para validar a entrada do usuário, onde você precisa executar a ação (mostrar o menu, pedir a entrada) pelo menos uma vez.

Neste exemplo, o programa pede ao usuário para inserir um número entre 1 e 10. O laço continuará até que uma entrada válida seja fornecida.

```CSHARP
int numero;
do
{
    Console.Write("Digite um número entre 1 e 10: ");
    string entrada = Console.ReadLine();
    // Tenta converter a entrada para um inteiro.
    // int.TryParse retorna true se a conversão for bem-sucedida.
    int.TryParse(entrada, out numero);

    if (numero < 1 || numero > 10)
    {
        Console.WriteLine("Entrada inválida. Tente novamente.");
    }

} while (numero < 1 || numero > 10);

Console.WriteLine($"Ótimo! Você digitou o número válido: {numero}");
```

Análise do Exemplo:

1. O bloco `do` é executado imediatamente. O programa solicita um número sem qualquer verificação prévia.

2. A entrada do usuário é lida e o programa tenta convertê-la para um inteiro.

3. Ao final do bloco, a condição `while (numero < 1 || numero > 10)` é verificada.

4. Se o número estiver fora do intervalo desejado (ou se `TryParse` falhar, deixando `numero` como `0`), a condição será `true`, e o laço se repetirá.

5. O laço só termina quando o usuário digita um número válido entre 1 e 10.

## 

`while` vs. `do-while`: Qual Usar?

* Use `while` quando você não tem certeza se o laço precisa ser executado. A execução depende inteiramente da condição inicial. * Exemplo: Processar itens em uma lista. Se a lista estiver vazia, o laço não executa.

* Use `do-while` quando você precisa que o corpo do laço seja executado pelo menos uma vez, independentemente da condição. * Exemplo: Apresentar um menu de opções ao usuário. O menu deve ser exibido antes que o usuário possa fazer uma escolha.



# Funções (Métodos com Retorno)

Em programação, uma "função" é um bloco de código reutilizável que executa uma tarefa e retorna um valor. Em C#, o termo técnico é método com tipo de retorno. A principal finalidade de uma função é processar dados de entrada e produzir um resultado, sem (idealmente) causar efeitos colaterais em outras partes do programa.

## Declaração

A sintaxe para declarar um método com retorno é:

```CSHARP
[modificador_de_acesso] static [tipo_de_retorno] [NomeDaFuncao]([parametros])
{
    // Corpo da função
    return [valor_a_retornar];
}
```

* `[tipo_de_retorno]`: O tipo de dado que a função irá retornar (`int`, `string`, `bool`, ou um tipo complexo). Não pode ser `void`.

* `return`: A palavra-chave que envia o resultado de volta e encerra a função. O valor retornado deve ser compatível com o `tipo_de_retorno`.

### Exemplo: Função Pura

Uma função "pura" é aquela cujo resultado depende exclusivamente de seus parâmetros de entrada, sem interagir com ou modificar estados externos. Elas são previsíveis e fáceis de testar.

```CSHARP
// Função pura que calcula o preço com desconto
public static decimal CalcularPrecoFinal(decimal precoOriginal, decimal percentualDesconto)
{
    decimal valorDesconto = precoOriginal * (percentualDesconto / 100);
    return precoOriginal - valorDesconto;
}

// Uso
decimal preco = CalcularPrecoFinal(150.0m, 10.0m); // Retorna 135.0m
```

## Parâmetros Avançados

### 

Passagem por Referência: `ref` vs. `out`

Por padrão, os tipos de valor (como `int`, `double`, `bool`) são passados para métodos por valor (pass-by-value). Isso significa que o método recebe uma cópia da variável, e qualquer alteração dentro do método não afeta a variável original.

As palavras-chave `ref` e `out` mudam esse comportamento, permitindo passar a variável por referência (pass-by-reference). O método recebe uma referência à localização da variável na memória, permitindo que ele modifique o valor original. Embora pareçam semelhantes, eles têm propósitos e regras diferentes.

#### 

A Palavra-Chave `ref`

Usa-se `ref` quando você quer que um método leia e potencialmente modifique uma variável existente.

Contrato do `ref`:

1. A variável deve ser inicializada pelo código que chama o método antes de ser passada.

2. O método pode ler o valor do parâmetro antes de modificá-lo.

Caso de Uso: Ideal para quando uma função precisa alterar o estado de uma variável de entrada. Pense em um fluxo de dados bidirecional: o valor entra no método e pode sair modificado.

```CSHARP
// Função que adiciona juros a um saldo existente
public static void AdicionarJuros(ref decimal saldo, decimal taxaDeJuros)
{
    decimal juros = saldo * taxaDeJuros;
    saldo += juros; // Modifica a variável original
}

// Uso
decimal minhaPoupanca = 1000m;
AdicionarJuros(ref minhaPoupanca, 0.05m);
Console.WriteLine(minhaPoupanca); // Saída: 1050
```

#### 

A Palavra-Chave `out`

Usa-se `out` quando o propósito principal de um método é retornar múltiplos valores ou quando uma operação de "tentativa" (como `TryParse`) precisa retornar um status de sucesso (`bool`) e o resultado da operação.

Contrato do `out`:

1. A variável passada como `out` não precisa ser inicializada antes da chamada.

2. O método é obrigado a atribuir um valor ao parâmetro `out` antes de retornar.

3. O método não pode ler o valor do parâmetro `out` antes de atribuir um valor a ele.

Caso de Uso: Perfeito para quando uma função precisa "produzir" um valor sem ter um valor de entrada. O fluxo de dados é unidirecional: o valor apenas sai do método.

```CSHARP
// Função que tenta dividir e retorna o quociente e o resto
public static bool TentarDividir(int dividendo, int divisor, out int quociente, out int resto)
{
    quociente = 0;
    resto = 0;
    if (divisor == 0)
    {
        return false; // Falha na operação
    }

    quociente = dividendo / divisor;
    resto = dividendo % divisor;
    return true; // Sucesso
}

// Uso
if (TentarDividir(10, 3, out int q, out int r))
{
    Console.WriteLine($"Quociente: {q}, Resto: {r}"); // Saída: Quociente: 3, Resto: 1
}
```

### 

Tabela Comparativa: `ref` vs. `out`

| Característica |`ref` |`out` |
--------------------------------
| Propósito |Modificar uma variável existente. |Retornar um ou mais valores. |
| Inicialização |Obrigatória antes da chamada. |Não necessária antes da chamada. |
| Atribuição no Método |Opcional. |Obrigatória antes do retorno. |
| Fluxo de Dados |Bidirecional (Entrada e Saída). |Unidirecional (Apenas Saída). |

### Parâmetros Opcionais e Argumentos Nomeados

Você pode atribuir valores padrão aos parâmetros, tornando-os opcionais. Para evitar ambiguidade, você pode usar argumentos nomeados na chamada da função.

```CSHARP
// 'logCompleto' é um parâmetro opcional
public static void RegistrarLog(string mensagem, bool logCompleto = false)
{
    string timestamp = DateTime.Now.ToString();
    if (logCompleto)
    {
        Console.WriteLine($"[LOG COMPLETO - {timestamp}] {mensagem}");
    }
    else
    {
        Console.WriteLine($"[LOG - {timestamp}] {mensagem}");
    }
}

// Uso
RegistrarLog("Iniciando processo..."); // Usa o valor padrão (false)
RegistrarLog("Erro crítico!", true); // Passa o valor explicitamente
RegistrarLog(logCompleto: true, mensagem: "Ordem invertida com argumentos nomeados.");
```

## Funções Recursivas

Uma função recursiva é aquela que chama a si mesma. É uma técnica poderosa para resolver problemas que podem ser divididos em subproblemas menores e idênticos. É crucial ter uma condição de parada para evitar um loop infinito (stack overflow).

```CSHARP
// Calcula o fatorial de um número usando recursão
public static int Fatorial(int n)
{
    // Condição de parada
    if (n == 0)
    {
        return 1;
    }
    
    // Chamada recursiva
    return n * Fatorial(n - 1);
}

// Uso
int resultado = Fatorial(5); // 5 * 4 * 3 * 2 * 1 = 120
```

## 

Expression-Bodied Members (`=>`)

Para funções que contêm apenas uma única instrução `return`, você pode usar uma sintaxe mais concisa com `=>`.

```CSHARP
// Função de soma reescrita
public static int Somar(int a, int b) => a + b;

// Função Fatorial reescrita com expressão condicional ternária
public static int Fatorial(int n) => n == 0 ? 1 : n * Fatorial(n - 1);
```



# Procedimentos

Em C#, o termo "procedimento" é mais conhecido como um método que não retorna nenhum valor, indicado pela palavra-chave `void`. O propósito principal de um método `void` é executar uma ação e causar um efeito colateral (side effect), como modificar o estado de uma variável externa, imprimir algo no console, ou interagir com um banco de dados.

A principal característica é que eles executam uma tarefa, mas não retornam um valor para o código que os chamou.

## Declaração

A sintaxe para declarar um método `void` é a seguinte:

```CSHARP
[modificador_de_acesso] static void [NomeDoMetodo]([parametros])
{
    // Corpo do método: código a ser executado
}
```

* `[modificador_de_acesso]`: Define a visibilidade (`public`, `private`, etc.).

* `static`: Indica que o método pertence à própria classe e pode ser chamado sem criar uma instância.

* `void`: Palavra-chave que especifica que o método não retorna valor.

* `[NomeDoMetodo]`: O nome do método, que deve ser um verbo ou frase verbal que descreva a ação (ex: `CalcularImpostos`, `ImprimirRelatorio`).

* `[parametros]`: A lista de dados que o método recebe para trabalhar.

### Exemplo: Método com Parâmetros

Métodos `void` frequentemente usam parâmetros para direcionar sua ação.

```CSHARP
// Declaração de um método que saúda um usuário
public static void SaudarUsuario(string nome)
{
    Console.WriteLine($"Olá, {nome}! Bem-vindo ao sistema.");
}

// Chamada ao método
SaudarUsuario("Ana"); // Saída: Olá, Ana! Bem-vindo ao sistema.
```

## 

Modificando Dados Externos com `ref`

Mesmo sem retornar um valor, um método `void` pode modificar variáveis que foram passadas a ele por referência usando a palavra-chave `ref`. Isso permite que o método altere o valor da variável original.

Tip:

Atenção: A variável passada como `ref` deve ser inicializada antes da chamada do método.

```CSHARP
// Método que troca os valores de duas variáveis
public static void TrocarValores(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// Uso
int x = 5;
int y = 10;
Console.WriteLine($"Antes: x = {x}, y = {y}");

TrocarValores(ref x, ref y);

Console.WriteLine($"Depois: x = {x}, y = {y}"); // Saída: Depois: x = 10, y = 5
```

## 

A Instrução `return` em Métodos `void`

Embora métodos `void` não retornem um valor, você pode usar a instrução `return;` para encerrar a execução do método prematuramente. Isso é uma técnica de controle de fluxo valiosa, conhecida como early exit.

```CSHARP
public static void ProcessarPedido(int quantidade)
{
    if (quantidade <= 0)
    {
        Console.WriteLine("Erro: A quantidade deve ser positiva.");
        return; // Sai do método imediatamente
    }

    if (quantidade > 100)
    {
        Console.WriteLine("Erro: Pedido excede o limite de estoque.");
        return; // Outro ponto de saída
    }

    // Este código só será executado se as validações passarem
    Console.WriteLine($"Pedido de {quantidade} unidades processado com sucesso.");
}
```

Note:

Em C#, tanto os métodos que retornam valor (funções) quanto os que não retornam (procedimentos `void`) são chamados genericamente de métodos. A escolha entre um método `void` e um com retorno depende da sua intenção: você quer realizar uma ação (`void`) ou obter um valor (com retorno)?



# Stack vs. Heap: Gerenciamento de Memória em C#

Todo programa .NET utiliza duas áreas de memória fundamentais para sua execução: a Stack (Pilha) e a Heap (Monte). Compreender como elas funcionam e o que é armazenado em cada uma é crucial para escrever código eficiente e prever seu comportamento, especialmente no que diz respeito a performance e ciclo de vida das variáveis.

## A Stack (Pilha)

A Stack é uma estrutura de dados do tipo LIFO (Last-In, First-Out), ou seja, o último item a entrar é o primeiro a sair. É uma área de memória extremamente rápida e eficiente, usada para gerenciar o fluxo de execução do programa.

O que é armazenado na Stack?

1. Tipos de Valor (`Value Types`): Variáveis locais de tipos como `int`, `double`, `bool`, `char`, e `structs` são armazenadas diretamente na Stack.

2. Parâmetros de Métodos: Os valores passados como argumentos para um método são colocados na Stack.

3. Referências a Objetos: Quando você cria um objeto (um tipo de referência), o objeto em si vai para a Heap, mas a variável que aponta para ele (a referência/ponteiro) é armazenada na Stack.

4. Controle de Execução: A Stack gerencia qual método está em execução no momento. Cada chamada de método cria um "quadro" (stack frame) que contém suas variáveis locais e parâmetros. Quando o método termina, seu quadro é removido da pilha.

Características Principais:

* Velocidade: Alocação e desalocação são instantâneas (apenas o ponteiro da Stack é movido).

* Tamanho Fixo: A memória para um quadro de pilha é alocada no início da chamada do método.

* Gerenciamento Automático: A memória é liberada automaticamente quando a variável sai de escopo (o método termina). O Garbage Collector não atua na Stack.

* Limitação de Tamanho: A Stack tem um tamanho limitado. Chamadas recursivas infinitas podem causar um `StackOverflowException`.

### Diagrama da Stack

```TEXT
// Código
void MetodoA() {
    int x = 10;
    MetodoB();
}

void MetodoB() {
    bool y = true;
}
```

```TEXT
      STACK (Durante a execução de MetodoB)
+--------------------+
| Frame do MetodoB:  |  <-- Topo da Stack
|   y = true         |
+--------------------+
| Frame do MetodoA:  |
|   x = 10           |
+--------------------+
| ... (outros frames) ...
+--------------------+
```

## A Heap (Monte)

A Heap é uma área de memória maior e mais flexível, usada para alocação dinâmica. É aqui que os objetos (instâncias de classes) residem.

O que é armazenado na Heap?

1. Instâncias de Tipos de Referência (`Reference Types`): Qualquer objeto criado com a palavra-chave `new` (como instâncias de `class`, `arrays`, `string`, `delegates`) é alocado na Heap.

Características Principais:

* Alocação Dinâmica: Objetos podem ser alocados e desalocados em qualquer ordem.

* Velocidade: A alocação na Heap é mais lenta que na Stack, pois o sistema precisa encontrar um bloco de memória livre que seja grande o suficiente.

* Gerenciamento pelo Garbage Collector (GC): A memória na Heap não é liberada automaticamente. O GC é um processo que roda em segundo plano, identifica objetos na Heap que não são mais referenciados por nenhuma variável na Stack e libera o espaço que eles ocupavam.

* Tamanho Maior: A Heap é muito maior que a Stack, limitada apenas pela memória virtual disponível no sistema.

## Exemplo Combinado: Stack e Heap em Ação

Vamos analisar um exemplo que usa ambos os tipos e visualizar a memória.

```CSHARP
public class Estudante // Reference Type
{
    public int Matricula { get; set; }
}

public void Executar()
{
    int idade = 25; // Value Type
    Estudante aluno = new Estudante(); // Reference Type
    aluno.Matricula = 101;
}
```

### Diagrama da Memória Durante a Execução

```TEXT
          STACK                                  HEAP
+-------------------------+          +----------------------------+
| Frame do método Executar: |
|                         |
|   idade = 25            |          // Objeto alocado na Heap
|                         |
|   aluno (ref: 0xA1B2)   |--------->+ Objeto Estudante (0xA1B2)  |
|                         |          |   - Matricula: 101         |
+-------------------------+          +----------------------------+
| ... (outros frames) ... |
+-------------------------+
```

Análise:

1. A variável `idade` (tipo `int`) é um tipo de valor, então seu dado (`25`) é armazenado diretamente na Stack.

2. A variável `aluno` é uma referência. Ela também fica na Stack, mas seu valor não é o objeto em si, e sim o endereço (`0xA1B2`) onde o objeto `Estudante` foi alocado na Heap.

3. O objeto `Estudante` real, com seu campo `Matricula`, reside na Heap.

## Tabela Comparativa

| Característica |Stack (Pilha) |Heap (Monte) |
-----------------------------------------------
| Velocidade |Muito Rápida |Mais Lenta |
| Gerenciamento |Automático (LIFO) |Garbage Collector (GC) |
| Armazena |Tipos de Valor, Referências |Instâncias de Tipos de Referência |
| Ciclo de Vida |Curto (limitado ao escopo do método) |Longo (até não ser mais referenciado) |
| Tamanho |Pequeno e Fixo (por thread) |Grande e Dinâmico |



# Tipos de Valor (Value Types)

No C#, todo tipo é classificado como um tipo de valor ou um tipo de referência. Entender a diferença é fundamental para prever o comportamento do seu código e gerenciar a memória de forma eficiente.

Tipos de valor são aqueles cujas variáveis contêm diretamente o seu dado. A variável e o valor são uma coisa só.

## Como Funciona a Memória?

Tipos de valor são, na maioria das vezes, armazenados em uma área da memória chamada Stack (Pilha). A Stack é uma estrutura de dados altamente eficiente, do tipo LIFO (Last-In, First-Out), que gerencia a memória de forma muito rápida. Quando uma variável de tipo de valor é declarada dentro de um método, um espaço é alocado na Stack para armazenar seu valor.

### Diagrama: Variável na Stack

Imagine a Stack como uma pilha de caixas. Cada vez que você declara uma variável, uma nova caixa é colocada no topo, contendo o valor.

```TEXT
      STACK
+------------------+
|                  |  <-- Topo da Stack
+------------------+
|   idade = 30     |
+------------------+
|   saldo = 150.75 |
+------------------+
| ...outras vars...|
+------------------+
```

## Comportamento na Atribuição

Esta é a característica mais importante dos tipos de valor. Quando você atribui uma variável de tipo de valor a outra, o valor é copiado. O resultado são duas variáveis completamente independentes, cada uma com sua própria cópia do dado.

### Exemplo de Código

```CSHARP
// 1. 'a' é criado na Stack com o valor 10.
int a = 10;

// 2. O valor de 'a' é COPIADO para a nova variável 'b'.
int b = a;

Console.WriteLine($"a: {a}, b: {b}"); // Saída: a: 10, b: 10

// 3. Modificamos apenas 'b'.
b = 20;

// 4. A variável 'a' permanece inalterada, pois elas são independentes.
Console.WriteLine($"Após a mudança, a: {a}, b: {b}"); // Saída: a: 10, b: 20
```

### Diagrama: Cópia de Valor

Após a atribuição `int b = a;`, a Stack fica assim:

```TEXT
      STACK
+------------------+
|                  |  <-- Topo da Stack
+------------------+
|      b = 10      |  (Cópia independente)
+------------------+
|      a = 10      |
+------------------+
| ...outras vars...|
+------------------+
```

Quando `b` é alterado para `20`, apenas a sua "caixa" na Stack é afetada.

## O Garbage Collector e a Stack

O Garbage Collector (Coletor de Lixo) do .NET é responsável por limpar a memória na Heap, mas ele não gerencia a Stack. A memória da Stack é liberada automaticamente quando uma variável sai de escopo (por exemplo, quando o método onde ela foi declarada termina sua execução). Esse gerenciamento automático é o que torna a alocação e desalocação na Stack extremamente rápidas.

## Exemplos de Tipos de Valor

* Tipos numéricos primitivos: `int`, `double`, `float`, `decimal`, `long`, `byte`, etc.

* `bool`: O tipo booleano `true`/`false`.

* `char`: Um único caractere Unicode.

* `struct`: Estruturas definidas pelo usuário. São a forma de criar seus próprios tipos de valor complexos.

* `enum`: Enumerações, que representam um conjunto de constantes nomeadas.



# Tipos de Referência (Reference Types)

Tipos de referência são um dos dois pilares fundamentais do sistema de tipos do C#. Diferente dos tipos de valor, uma variável de tipo de referência não armazena o dado diretamente. Em vez disso, ela armazena um endereço de memória (uma referência ou ponteiro) que aponta para o local onde o objeto real está armazenado. Esse local é uma área da memória chamada Heap.

## Como Funciona a Memória?

A gestão da memória para tipos de referência envolve duas áreas:

1. Stack: A variável em si é criada na Stack. Ela é leve e contém apenas o endereço de memória do objeto.

2. Heap: O objeto real, com todos os seus dados, é alocado na Heap. A Heap é uma área de memória maior e mais flexível, gerenciada por um processo chamado Garbage Collector (Coletor de Lixo).

### Diagrama: Variável e Objeto na Memória

Quando você cria um objeto, a variável na Stack aponta para o objeto na Heap.

```TEXT
      STACK                         HEAP
+------------------+      +-------------------------+
|                  |      |                         |
|  minhaConta      |----->|  Objeto Conta           |
| (Endereço: 0x2A) |      |  (Endereço: 0x2A)       |
|                  |      |  - Saldo: 1000          |
+------------------+      |  - Titular: "Ana"       |
|                  |      |                         |
+------------------+      +-------------------------+
```

## Comportamento na Atribuição

Esta é a diferença mais crucial. Quando você atribui uma variável de referência a outra, você não está copiando o objeto, mas sim copiando o endereço de memória.

O resultado é que ambas as variáveis passam a apontar para o mesmo objeto na Heap. Qualquer modificação feita através de uma variável será visível através da outra.

### Exemplo de Código

```CSHARP
// Vamos supor que temos uma classe simples
public class ContaBancaria
{
    public decimal Saldo { get; set; }
}

// 1. Criamos uma instância. 'contaA' aponta para um novo objeto.
var contaA = new ContaBancaria { Saldo = 1000 };

// 2. Copiamos a referência. Agora 'contaB' aponta para o MESMO objeto que 'contaA'.
var contaB = contaA;

Console.WriteLine($"Saldo (contaA): {contaA.Saldo}"); // Saída: 1000
Console.WriteLine($"Saldo (contaB): {contaB.Saldo}"); // Saída: 1000

// 3. Modificamos o objeto usando 'contaB'.
contaB.Saldo = 500;

// 4. A mudança é refletida em 'contaA', pois ambas apontam para o mesmo lugar.
Console.WriteLine($"Saldo (contaA) após mudança: {contaA.Saldo}"); // Saída: 500
Console.WriteLine($"Saldo (contaB) após mudança: {contaB.Saldo}"); // Saída: 500
```

### Diagrama: Cópia de Referência

Após `var contaB = contaA;`, a situação da memória é a seguinte:

```TEXT
      STACK                         HEAP
+------------------+      +-------------------------+
|                  |      |                         |
|      contaA      |----->|  Objeto Conta           |
| (Endereço: 0x5B) |      |  (Endereço: 0x5B)       |
+------------------+      |  - Saldo: 1000          |
|                  |      |                         |
|      contaB      |----->|                         |
| (Endereço: 0x5B) |      +-------------------------+
|                  |
+------------------+
```

## O Garbage Collector (GC)

Como a Heap é gerenciada dinamicamente, precisamos de um mecanismo para limpar objetos que não são mais necessários. É aqui que entra o Garbage Collector.

O GC periodicamente verifica a Heap em busca de objetos que não possuem mais nenhuma referência apontando para eles. Quando encontra esses objetos "órfãos", ele os remove e libera a memória para que possa ser reutilizada.

Se no nosso exemplo fizermos `contaA = null;` e `contaB = null;`, o objeto `ContaBancaria` na Heap se tornaria elegível para a coleta de lixo.

## Exemplos de Tipos de Referência

* `class`: O exemplo mais comum. Todas as classes que você cria são tipos de referência.

* `object`: O tipo base para todos os outros tipos no .NET.

* `string`: Embora às vezes se comporte como um tipo de valor (devido à sua imutabilidade), `string` é um tipo de referência.

* Arrays: Vetores e matrizes (ex: `int[]`, `string[]`) são sempre tipos de referência.

* Delegates e Interfaces.



# Structs

Tipos de dados estruturado, servem apenas para definir a estrutura

Sendo tipo de valor

Armazenam apenas outros tipos de dados, e é definido pela palavra:

```CSHARP
struct NomeDaEstrutura{
    //Aqui vai as propriedades da estrutura
}
```

Composto por metodos e propriedades

Nome sempre com letras maiuscula

* Igual para propriedades e métodos

Criado apartir da palavra `new`

* Neste momento que temos os valores iniciais das propriedades

Exemplo:

```CSHARP
struct Pessoa{
    public string nome;
}
Pessoa pessoa = new Pessoa();
pessoa.nome = "João";
Console.WriteLine(pessoa.nome);
```

Também podemos criar um construtor padrão para inicializar o objeto:

```CSHARP
struct Pessoa{
    public string nome;
    public int idade;
    public Pessoa(string nome){
        this.nome = nome;
    }
}
Pessoa pessoa = new Pessoa("João");
Console.WriteLine(pessoa.nome);
```

E assim criamos metodos dentro do struct:

```CSHARP
struct Pessoa{
    public string nome;
    public int idade;
    public void MostrarDados(){
        Console.WriteLine($"Nome: {nome} Idade: {idade}");
    }
}
Pessoa pessoa = new Pessoa("João", 20);
pessoa.MostrarDados();
```

Podemos também usar o método `ToString()` para retornar uma string com os dados do objeto:

```CSHARP
struct Pessoa{
    public string nome;
    public int idade;
    public override string ToString(){
        return $"Nome: {nome} Idade: {idade}";
    }
}
Pessoa pessoa = new Pessoa("João", 20);
Console.WriteLine(pessoa.ToString());
```



# Enums

Um Enum serve para fornecer uma melhor visualização do código e também facilitar a leitura e entendimento de um código.

Usados em listas curtas e Usados em dados fixos:

* Hard Coded

Note:

No .NET a conveção é usar o PascalCase e começar com a letra maiúscula E sempre

Exemplo:

```CSHARP
class Program {
    enum StatusPedido {
        AguardandoPagamento,
        Pago,
        Cancelado
    }
    
    static void Main(string[] args) 
    {
        StatusPedido statusAtual = StatusPedido.AguardandoPagamento;
        Console.WriteLine(statusAtual); // Aguardando Pagamento
    }
}
```



# References

This page contains a curated list of high-quality resources for learning and mastering C# and the .NET ecosystem.

## Official Documentation

* Microsoft C# Docs: The official and most comprehensive source for C# documentation. It includes tutorials, language references, and how-to guides. * [C# Documentation Home](https://docs.microsoft.com/en-us/dotnet/csharp/) * [C# Language Reference](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/) * [.NET Documentation](https://docs.microsoft.com/en-us/dotnet/)

## Books

* C# in Depth by Jon Skeet: An essential book for intermediate to advanced developers looking to understand the nuances of the C# language and its evolution.

## Online Courses & Tutorials

* Microsoft Learn: An interactive platform with free tutorials and learning paths for C#, .NET, and Azure. * [Take your first steps with C#](https://learn.microsoft.com/en-us/training/paths/csharp-first-steps/)

## Community & Code

* .NET Foundation: An independent organization to foster open development and collaboration around the .NET ecosystem. * [Official Website](https://dotnetfoundation.org/)

* .NET Source Code: Browsing the source code of the .NET runtime and libraries is an excellent way to learn how things work under the hood. * [dotnet/runtime on GitHub](https://github.com/dotnet/runtime)



