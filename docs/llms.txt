# Sobre este Repositório

Bem-vindo ao meu repositório pessoal de aprendizado de C# e .NET. Esta documentação é um projeto vivo onde organizo minhas anotações, exemplos de código e meu entendimento da linguagem C#, desde conceitos fundamentais até tópicos mais avançados.

O objetivo principal é construir uma base de conhecimento pessoal estruturada e detalhada que solidifique meu aprendizado e possa servir como uma referência rápida no futuro.

## Como Está Organizado

Esta base de conhecimento está dividida principalmente em duas áreas:

1. Tópicos (`/Writerside/topics/`): São artigos detalhados que explicam conceitos específicos de C#. Cada tópico visa ser uma explicação clara e concisa de um recurso, palavra-chave ou conceito de programação.

2. Projetos (`/projects/`): Este diretório contém pequenas aplicações C# práticas. Esses projetos são usados para aplicar o conhecimento teórico dos tópicos de forma prática.

Este projeto é construído usando JetBrains Writerside, que permite formatação rica e uma experiência de documentação estruturada.

## See also

### Writerside documentation

[Recursos Recomendados](references.html)



# Escopo

Em C#, "escopo" refere-se à região do código onde uma variável ou um membro de uma classe pode ser acessado. Entender o escopo é fundamental para escrever um código organizado e livre de erros, pois ele determina o ciclo de vida e a visibilidade das suas variáveis.

O escopo em C# é geralmente definido por blocos de código, que são delimitados por chaves `{}`.

## Níveis de Escopo

### 

1. Escopo de Classe (Campos ou Fields)

Variáveis declaradas diretamente dentro de uma classe, mas fora de qualquer método, são chamadas de campos (fields) ou variáveis de membro. Elas estão disponíveis para todos os métodos (e outros membros) dentro daquela classe.

* Seu ciclo de vida é o mesmo do objeto da classe.

* Podem ser acessadas usando a palavra-chave `this`.

```CSHARP
public class Personagem
{
    // 'nome' e 'pontosDeVida' são campos com escopo de classe.
    private string nome;
    private int pontosDeVida = 100;

    public Personagem(string nomeInicial)
    {
        this.nome = nomeInicial; // Acessando o campo 'nome'
    }

    public void ReceberDano(int dano)
    {
        // Acessando e modificando o campo 'pontosDeVida'
        this.pontosDeVida -= dano;
        Console.WriteLine($"{this.nome} recebeu {dano} de dano e agora tem {this.pontosDeVida} HP.");
    }
}
```

### 2. Escopo de Método (Variáveis Locais)

Variáveis declaradas dentro de um método são chamadas de variáveis locais. Elas só podem ser acessadas dentro do método onde foram declaradas.

* Elas são criadas quando o método é chamado e destruídas quando o método termina.

* Não podem ser acessadas por outros métodos.

```CSHARP
public class Calculadora
{
    public int Somar(int a, int b)
    {
        // 'resultado' é uma variável local com escopo de método.
        int resultado = a + b;
        return resultado;
    }

    public void OutroMetodo()
    {
        // A linha abaixo causaria um erro de compilação, pois 'resultado'
        // não existe neste escopo.
        // Console.WriteLine(resultado); 
    }
}
```

### 3. Escopo de Bloco

Variáveis declaradas dentro de um bloco de código (como um `if`, `for`, `while` ou mesmo um bloco `{}` avulso) só existem dentro daquele bloco.

* Este é o nível de escopo mais restrito.

```CSHARP
public void TestarEscopoDeBloco()
{
    int a = 10;

    if (a > 5)
    {
        // 'b' só existe dentro deste bloco 'if'.
        int b = 20;
        Console.WriteLine(a + b); // Válido: 'a' e 'b' estão em escopo.
    }

    // A linha abaixo causaria um erro de compilação, pois 'b' está fora de escopo.
    // Console.WriteLine(b);
}
```

## 

Sombreamento de Variáveis (Variable Shadowing)

O C# impede que você declare uma variável local com o mesmo nome de outra variável local que já esteja em um escopo externo (pai). Isso evita bugs e confusão.

```CSHARP
int x = 10; // Escopo do método

if (x > 5)
{
    int y = 20; // Escopo do bloco
    // int x = 30; // Erro de compilação! Não se pode declarar 'x' aqui porque já existe no escopo pai.
}
```

No entanto, uma variável local pode ter o mesmo nome de um campo da classe. Nesse caso, a variável local "sombra" (ou esconde) o campo. Para acessar o campo da classe, você deve usar a palavra-chave `this`.

```CSHARP
public class Exemplo
{
    private string nome = "Classe"; // Campo da classe

    public void MeuMetodo(string nome) // Parâmetro do método
    {
        // 'nome' aqui se refere ao parâmetro do método ("Método").
        Console.WriteLine($"Variável local: {nome}");

        // Para acessar o campo da classe, usamos 'this.nome'.
        Console.WriteLine($"Campo da classe: {this.nome}");
    }
}

// Uso:
Exemplo ex = new Exemplo();
ex.MeuMetodo("Método");
// Saída:
// Variável local: Método
// Campo da classe: Classe
```



# Namespaces

Em C#, um `namespace` é um contêiner organizacional para classes e outros namespaces. Sua principal finalidade é fornecer um nível de separação para o código, ajudando a evitar conflitos de nomes e a estruturar grandes projetos de forma lógica.

Pense em um namespace como o sobrenome de uma classe. Você pode ter duas pessoas chamadas "João", mas elas são diferentes se uma for "João Silva" e a outra "João Souza". Da mesma forma, você pode ter duas classes `Cliente`, desde que elas estejam em namespaces diferentes (ex: `MeuApp.Vendas.Cliente` e `MeuApp.Suporte.Cliente`).

## Declaração e Estrutura

Um namespace é declarado com a palavra-chave `namespace`, seguida por um nome e um bloco de código `{}` contendo as classes.

```CSHARP
// O nome do namespace geralmente segue a estrutura do projeto.
namespace MeuApp.Servicos
{
    public class EmailService
    {
        // ... código do serviço de email
    }
}
```

### Relação com a Estrutura de Pastas

Por convenção, a estrutura de namespaces de um projeto espelha a estrutura de pastas. Isso torna a navegação e a localização de arquivos muito mais intuitivas.

* Se você tem um arquivo na pasta `Projeto/Models/User.cs`, o namespace dentro de `User.cs` deve ser `Projeto.Models`.

* Se você tem um arquivo em `Projeto/Services/Payment/PayPalService.cs`, o namespace deve ser `Projeto.Services.Payment`.

As IDEs modernas, como o Visual Studio e o Rider, gerenciam essa estrutura automaticamente ao criar novos arquivos.

## Namespaces Aninhados

Você pode aninhar namespaces para criar hierarquias ainda mais detalhadas.

```CSHARP
namespace MeuApp.Servicos
{
    namespace Notificacoes
    {
        public class PushService { }
    }
}

// A classe PushService pode ser acessada usando seu nome completo:
// MeuApp.Servicos.Notificacoes.PushService service;
```

## O Namespace Global

Qualquer tipo que não é declarado dentro de um namespace reside no namespace global. Isso é geralmente desaconselhado para evitar poluir o escopo global e criar possíveis conflitos com outras bibliotecas.

## Boas Práticas

1. Um Tipo por Arquivo: Mantenha apenas uma classe, struct, interface ou enum por arquivo. O nome do arquivo deve corresponder ao nome do tipo (ex: `Cliente.cs` contém a classe `Cliente`).

2. Espelhe a Estrutura de Pastas: Sempre faça seus namespaces corresponderem à hierarquia de pastas do seu projeto.

3. Nomes Significativos: Use nomes que descrevam claramente a funcionalidade contida no namespace (ex: `MeuApp.Data`, `MeuApp.UI`, `MeuApp.Utilities`).



# A Palavra-Chave using

A palavra-chave `using` em C# é multifacetada e possui três contextos de uso distintos, todos com o objetivo de simplificar o código e gerenciar recursos de forma eficaz.

## 

1. Diretiva `using`: Importando Namespaces

Este é o uso mais comum. A diretiva `using` é colocada no topo de um arquivo de código e permite que você use os tipos de um namespace sem precisar especificar o nome completo do namespace toda vez.

Sem a diretiva `using`, você teria que escrever:

```CSHARP
// Nome completo do tipo é necessário
System.Collections.Generic.List<string> nomes = new System.Collections.Generic.List<string>();
System.Console.WriteLine("Olá");
```

Com a diretiva `using`, o código se torna muito mais limpo e legível:

```CSHARP
// Importamos os namespaces no topo do arquivo
using System;
using System.Collections.Generic;

// Agora podemos usar os tipos diretamente
List<string> nomes = new List<string>();
Console.WriteLine("Olá");
```

Note:

Por convenção, as diretivas `using` são sempre declaradas no início do arquivo.

## 

2. Instrução `using`: Gerenciamento de Recursos (`IDisposable`)

A instrução `using` garante que objetos que implementam a interface `IDisposable` sejam descartados corretamente, liberando recursos não gerenciados (como conexões de banco de dados, arquivos, handles de sistema) assim que não forem mais necessários.

O compilador transforma o bloco `using` em um bloco `try...finally`, garantindo que o método `Dispose()` do objeto seja chamado, mesmo que ocorram exceções.

Sintaxe Tradicional:

```CSHARP
// A classe 'StreamReader' implementa IDisposable
using (System.IO.StreamReader leitor = new System.IO.StreamReader("caminho/para/arquivo.txt"))
{
    string conteudo = leitor.ReadToEnd();
    Console.WriteLine(conteudo);
} // O método leitor.Dispose() é chamado automaticamente aqui, fechando o arquivo.
```

Sintaxe Simplificada (C# 8.0 e superior):

Se a variável declarada com `using` não for mais usada fora do escopo atual, você pode omitir as chaves.

```CSHARP
using System.IO.StreamReader leitor = new System.IO.StreamReader("arquivo.txt");
string conteudo = leitor.ReadToEnd();
Console.WriteLine(conteudo);
// O método leitor.Dispose() será chamado automaticamente no final do escopo (ex: no final do método).
```

## 

3. Diretiva `using static`: Importando Membros Estáticos

Esta diretiva permite que você acesse os membros estáticos (`métodos`, `propriedades`, `constantes`) de uma classe diretamente, sem precisar prefixá-los com o nome da classe.

Sem `using static`:

```CSHARP
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine(Math.PI);
        Console.WriteLine(Math.Pow(2, 3));
    }
}
```

Com `using static`, o código fica mais conciso:

```CSHARP
// Importamos todos os membros estáticos da classe System.Math e System.Console
using static System.Math;
using static System.Console;

class Program
{
    static void Main()
    {
        // Agora podemos chamar os métodos estáticos diretamente
        WriteLine(PI);       // Em vez de Math.PI
        WriteLine(Pow(2, 3)); // Em vez de Math.Pow(2, 3)
    }
}
```

Warning:

Use `using static` com moderação. Embora possa tornar o código mais curto, usá-lo excessivamente pode poluir o escopo e diminuir a legibilidade, tornando difícil saber de qual classe um método estático se origina.



# Palavras-Chave (Keywords)

Palavras-chave (ou keywords) são identificadores reservados que têm um significado especial para o compilador do C#. Elas são os blocos de construção fundamentais da linguagem e não podem ser usadas como nomes de variáveis, métodos ou classes (a menos que sejam prefixadas com `@`, o que é raro e geralmente desaconselhado).

Note:

Você não precisa memorizar todas. As IDEs modernas, como Visual Studio e Rider, destacam as palavras-chave e avisam se você tentar usá-las incorretamente. O objetivo aqui é entender as categorias e as mais comuns.

## Categorias de Palavras-Chave Comuns

### Modificadores de Acesso

Controlam a visibilidade (onde o código pode ser acessado).

* `public`: Acesso não restrito.

* `private`: Acesso limitado à classe que o contém.

* `protected`: Acesso limitado à classe que o contém e a classes derivadas (herança).

* `internal`: Acesso limitado ao assembly atual (ao projeto).

### Declaração de Tipos

Usadas para definir os diferentes tipos de estruturas de dados.

* `class`: Define um tipo de referência que contém dados (campos) e comportamento (métodos).

* `struct`: Define um tipo de valor, geralmente para pequenas estruturas de dados.

* `interface`: Define um contrato (um conjunto de métodos e propriedades) que uma classe ou struct pode implementar.

* `enum`: Define um conjunto de constantes nomeadas (ex: DiasDaSemana).

* `delegate`: Define um tipo que representa uma referência a um método com uma assinatura específica.

### Modificadores de Membros

Alteram o comportamento de membros de uma classe.

* `static`: Indica que um membro pertence ao tipo em si, não a uma instância.

* `const`: Declara um campo cujo valor é uma constante de tempo de compilação.

* `readonly`: Declara um campo cujo valor só pode ser definido na declaração ou no construtor.

* `abstract`: Indica que uma classe ou membro tem uma implementação ausente ou incompleta (deve ser implementado por uma classe derivada).

* `virtual`: Permite que um método em uma classe base seja sobrescrito por uma classe derivada.

* `override`: Sobrescreve um método `virtual` ou `abstract` de uma classe base.

### Nível de Método

Usadas dentro de métodos ou para definir o comportamento de métodos.

* `void`: Especifica que um método não retorna nenhum valor.

* `return`: Retorna o controle (e opcionalmente um valor) do método para quem o chamou.

* `params`: Permite que um método aceite um número variável de argumentos.

* `ref`, `out`, `in`: Modificadores de parâmetro que controlam como os argumentos são passados para os métodos.

### Instruções e Controle de Fluxo

Controlam a ordem em que o código é executado.

* `if`, `else`: Executam código condicionalmente.

* `switch`, `case`, `default`: Executam código com base em uma correspondência de padrões.

* `for`, `foreach`, `while`, `do`: Criam laços (loops).

* `break`: Sai de um laço ou de um `switch`.

* `continue`: Pula para a próxima iteração de um laço.

* `try`, `catch`, `finally`, `throw`: Manipulação de exceções.

### Gerenciamento de Namespaces e Tipos

* `using`: Importa um namespace ou gerencia recursos `IDisposable`.

* `namespace`: Declara um escopo para organizar o código.

* `new`: Cria uma nova instância de um tipo ou oculta um membro de uma classe base.

* `typeof`: Obtém o objeto `System.Type` para um tipo.

Para uma lista exaustiva e detalhada de todas as palavras-chave, a documentação oficial da Microsoft é a fonte definitiva.

[Referência Completa de Palavras-Chave do C# (Microsoft Docs)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/)



# Comentários

Comentários são anotações no código-fonte que são ignoradas pelo compilador. Eles existem exclusivamente para os desenvolvedores, servindo para esclarecer partes complexas do código, deixar lembretes ou gerar documentação externa.

## A Regra de Ouro: Comente o "Porquê", não o "O Quê"

Um bom código deve ser autoexplicativo. O código em si já mostra o que ele está fazendo. Comentários eficazes devem explicar por que o código está fazendo algo de uma maneira específica, especialmente se a lógica não for óbvia.

* Comentário Ruim (redundante): ```CSHARP // Incrementa i em 1 i++; ```

* Comentário Bom (explica a intenção): ```CSHARP // Usamos um algoritmo de ordenação customizado aqui porque os testes de performance // mostraram que ele é 2x mais rápido para o nosso conjunto de dados específico. CustomSort(minhaLista); ```

## Tipos de Comentários

### 

1. Comentários de Linha Única (`//`)

Começam com `//` e continuam até o final da linha. São ideais para notas curtas e explicações pontuais.

```CSHARP
// Verifica se o usuário tem permissão de administrador.
if (user.IsAdmin)
{
    // ...
}
```

### 

2. Comentários de Múltiplas Linhas (`/* ... */`)

Começam com `/*` и terminam com `*/`. Podem abranger várias linhas e são úteis para desativar temporariamente grandes blocos de código ou para comentários mais longos.

```CSHARP
/*
    Este é um método temporário para testes de carga.
    Ele simula a criação de 10.000 usuários e deve ser removido
    antes de enviarmos o código para produção.
*/
public void GerarCargaDeTeste()
{
    // ...
}
```

### 

3. Comentários de Documentação XML (`///`)

Estes são os comentários mais poderosos do C#. Eles começam com `///` e usam tags XML para descrever o que classes, métodos e propriedades fazem. O Visual Studio e outras IDEs usam esses comentários para fornecer o IntelliSense (autocompletar com documentação), e eles podem ser usados para gerar arquivos de documentação HTML automaticamente.

Tags XML Comuns:

* `<summary>`: Um resumo geral do que o membro faz.

* `<param name="nomeDoParametro">`: Descreve um parâmetro do método.

* `<returns>`: Descreve o valor de retorno do método.

* `<exception cref="TipoDaExcecao">`: Descreve uma exceção que o método pode lançar.

* `<remarks>`: Fornece informações adicionais mais detalhadas.

Exemplo Completo:

```CSHARP
/// <summary>
/// Calcula o pagamento mensal de um empréstimo com base na taxa de juros, 
/// número de parcelas e valor do empréstimo.
/// </summary>
/// <param name="taxaAnual">A taxa de juros anual (ex: 0.05 para 5%).</param>
/// <param name="numParcelas">O número total de parcelas.</param>
/// <param name="valorEmprestimo">O valor total do empréstimo.</param>
/// <returns>O valor do pagamento mensal.</returns>
/// <exception cref="ArgumentException">Lançada quando um dos parâmetros numéricos é negativo.</exception>
public double CalcularPagamentoMensal(double taxaAnual, int numParcelas, decimal valorEmprestimo)
{
    if (taxaAnual < 0 || numParcelas < 0 || valorEmprestimo < 0)
    {
        throw new ArgumentException("Parâmetros não podem ser negativos.");
    }
    // ... lógica de cálculo
    return 0.0;
}
```

Ao usar a função `CalcularPagamentoMensal` em outro lugar, a IDE mostrará a `summary`, as descrições dos parâmetros e o que ela retorna, tornando o código muito mais fácil de usar.



# Variáveis

Variavel é um espaço na mémoria que vai guardar um dado

No C# como toda linguagem de programação temos tipos primitivos, por exemplo:

* int - inteiro

* string - texto

* bool - booleano (true ou false)

* double e float - número decimal

Note:

Lembrando que: double e float não são o mesmo pois o double possui uma precisão maior do que o float, mas o float ocupa menos memória.

No c# podemos declarar variaveis assim:

```CSHARP
int idade = 10;
string nome = "Joao";
bool estaAprovado = true;
double salario = 25.98;
float altura; 
altura = 1.76f; 
```

Warning:

Note que para declarar um float devemos colocar a letra f no final da declaração:

```CSHARP
float altura = 1.76f; 
```

## Declarações múltiplas

É possível declarar várias variáveis no mesmo comando separando-as por vírgula.

```CSHARP
int a, b, c;
```

Lembre-se sempre que você precisa inicializar uma variável antes de usá-la. E de que C# é uma linguagem fortemente
tipada, logo, precisamos definir o tipo dela ou seja, você deve especificar o tipo de dados quando declarar uma
variável. Ou podemos usar a inferência de tipos. Exemplo:

```CSHARP
var idade = 10;
var nome = "Joao";
var estaAprovado = true;
var salario = 25.98;
var altura = 1.76f; 
```

Assim o tipo de dado será inferido pelo compilador, deste modo não temos um controle real da tipagem

Note:

Para inferencia de tipos utilizamos a palavra reservada `var`. Mas não podemos utilizar desta forma na hora de criar uma
variavel:

```CSHARP
var x; // isso está errado!
```



# Constantes

Uma constante (`const`) é um campo cujo valor é definido em tempo de compilação e não pode ser alterado durante a execução do programa. Pense nela como um valor fixo e imutável.

Warning:

Regra Fundamental: Uma constante deve obrigatoriamente ser inicializada no momento em que é declarada. Tentar declarar uma constante sem um valor resultará em um erro de compilação.

Exemplo de Declaração Correta:

```CSHARP
const double PI = 3.14159;
const string NOME_EMPRESA = "MinhaApp";
```

Convenção de Nomenclatura: Por convenção, nomes de constantes em C# são escritos em `PascalCase` ou `ALL_CAPS_SNAKE_CASE` para distingui-los claramente de variáveis.

## 

Características das Constantes (`const`)

1. Valor em Tempo de Compilação: O valor de uma `const` é gravado diretamente no assembly do programa. O compilador substitui o uso da constante pelo seu valor literal em todo o código (semelhante a um "localizar e substituir").

2. Tipos Permitidos: Só podem ser dos tipos primitivos do C# (todos os tipos numéricos, `bool`, `char`, `string`) ou um tipo `enum`.

3. Implicitamente Estáticas: Uma `const` é sempre estática (`static`), mesmo que a palavra-chave `static` não seja usada. Ela pertence ao tipo, não a uma instância do objeto.

## 

`const` vs. `readonly`: Qual a Diferença?

Este é um ponto crucial que diferencia desenvolvedores experientes. C# também possui a palavra-chave `readonly`, que parece similar, mas tem um propósito diferente.

* `readonly` (Constante de Tempo de Execução): Um campo `readonly` também não pode ser alterado após sua inicialização. No entanto, sua inicialização pode ocorrer na declaração ou dentro do construtor da classe. Isso permite que cada instância de um objeto tenha um valor `readonly` diferente.

Tabela Comparativa:

| Característica |`const` |`readonly` |
---------------------------------------
| Quando o valor é definido? |Tempo de Compilação |Tempo de Execução (no construtor) |
| Pode ser diferente por instância? |Não (é estático) |Sim (pode ser de instância) |
| Pode ser de qualquer tipo? |Não (só primitivos/enum) |Sim (qualquer tipo, incluindo objetos) |
| Pode ser `static`? |Sim (implicitamente) |Sim (explicitamente, `static readonly`) |

Exemplo Prático:

```CSHARP
public class Circulo
{
    // 'PI' é o mesmo para todos os círculos. É uma constante de compilação.
    public const double PI = 3.14159;

    // 'Raio' e 'DataCriacao' podem ser diferentes para cada objeto Circulo.
    // Seus valores são definidos quando o objeto é criado e não podem ser mudados depois.
    public readonly double Raio;
    public readonly DateTime DataCriacao;

    public Circulo(double raio)
    {
        this.Raio = raio; // Inicialização de campo readonly no construtor
        this.DataCriacao = DateTime.Now;
    }
}

// Uso
Circulo c1 = new Circulo(5.0);
Circulo c2 = new Circulo(10.0);

// c1.Raio é 5.0, c2.Raio é 10.0. Ambos são imutáveis após a criação.
// Tentar fazer 'c1.Raio = 7.0;' resultaria em um erro de compilação.
```

### Quando Usar Qual?

* Use `const`: Para valores que são verdadeiramente universais e imutáveis, conhecidos antes mesmo do programa rodar (ex: `Math.PI`, número de meses no ano, uma string de conexão padrão para um ambiente de teste).

* Use `readonly`: Para valores que são específicos de uma instância de um objeto e que não devem mudar após a sua criação (ex: um ID de usuário, a data de criação de um registro).



# System

Todos os tipos mesmo os built-in são derivados do tipo chamado: `system`

```CSHARP
int a = 10;
Console.WriteLine(a.GetType()); //System.Int32
```

```
Ele é a base para todos os objetos no .NET
```

Como ele está de modo implicito, não precisamos se preocupar em usar



# Tipos Primitivos (Built-in Types)

São os tipos de dados mais básicos que o C# possui. São eles:

* int: Inteiro, pode ser positivo ou negativo.

* float: Ponto flutuante, números com casas decimais.

* double: Double precision floating point number. Números com casas decimais.

* char: Caracteres individuais. Exemplo 'a', 'b' etc...

* bool: Booleano, verdadeiro ou falso.

Os tipos primitivos são usados para armazenar valores simples e podem ser declarados da seguinte forma:

```CSHARP
int myInt = 10;
float myFloat = 3.14f; // O sufixo "f" é usado para indicar que é um número de ponto flutuante.
double myDouble = 2.71828;
char myChar = 'A';
bool myBool = true;
```

Note:

Veja mais: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types)

## Classificação

Eles podem ser classificados em algumas categórias:

* Tipos Simples (Simple Types)

* Enumerados (Enum Types)

* Estruturas (Struct Types)

* Tipos Nulos (Nullable Types)

## Definições

Cada tipo possui sua capacidade em bytes e seu alcance máximo. Por exemplo:

* int: 4 bytes, -231 a 231-1

* float: 4 bytes, ~±1.5 x 10-45 to ±3.4 x 1038

* double: 8 bytes, ~±5.0 x 10-324 to ±1.7 x 10308

* char: 2 bytes, '\u0000' to '\uffff'

* bool: 1 byte, false or true

Warning:

Caso o o valor atribuido exceda o limite do tipo, ocorrerá um erro de overflow

Note:

Você também pode usar as palavras-chave `sizeof` e `typeof` para obter informações sobre esses tipos:

```CSHARP
Console.WriteLine(sizeof(int)); // Output: 4
Console.WriteLine(typeof(float).Name); // Output: Single
```



# Byte

O tipo byte é usado para representar de fato um byte.

Em diversos casos precisamos de uma cadeia de bytes num arquivo para ler ou escrever dados. O tipo byte pode ser usado para isso, pois ele representa um único byte

```CSHARP
byte b = 10;
Console.WriteLine(b);
```

Temos também o `sbyte` que permite valores negativos

Note:

Unsigned e signed:

Valores com sinal como "-" por exemplo, são chamados de signed numbers (números com sinal) e sem sinal são chamados unsigned numbers (números sem sinal).

Ex:

```CSHARP
int signedNumber = -5; //signed number
uint unsignedNumber = 5; //unsigned number
```

## Definições

* byte (8-bit): * escala: 0 a 255

* sbyte (8-bit): * escala: -127 a +127



# Números Inteiros

## Definições

Números inteiros são números que não possuem casas decimais. Exemplos de números inteiros: 1, -20, 356789.

## Classificação:

* short/unshort

* int/uint

* long/ulong

Note:

O `u` do `ushort`, `uint` e `ulong` significa unsigned (sem sinal)

Ou seja, esses tipos só armazenam valores que são possitivos ou zero

## Tabela de Tipos

| Tipo |Intervalo |Tamanho |Tipo .NET |
---------------------------------------
| `sbyte` |-128 a 127 |Inteiro de 8 bits com sinal |System.SByte |
| `byte` |0 a 255 |Inteiro de 8 bits sem sinal |System.Byte |
| `short` |-32,768 a 32,767 |Inteiro de 16 bits com sinal |System.Int16 |
| `ushort` |0 a 65,535 |Inteiro de 16 bits sem sinal |System.UInt16 |
| `int` |-2,147,483,648 a 2,147,483,647 |Inteiro de 32 bits com sinal |System.Int32 |
| `uint` |0 a 4,294,967,295 |Inteiro de 32 bits sem sinal |System.UInt32 |
| `long` |-9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 |Inteiro de 64 bits com sinal |System.Int64 |
| `ulong` |0 a 18,446,744,073,709,551,615 |Inteiro de 64 bits sem sinal |System.UInt64 |

## Referência

[Tipos de números integrais (referência de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)



# Números Reais

Números com casas decimais ou ponto flutuante são chamados de números reais. Em C#, o tipo `double` é usado para representar um número real. O exemplo a seguir mostra como declarar e inicializar uma variável do tipo `double`.

```CSHARP
double x = 3.14; // Declaração e inicialização
```

O valor da variável `x` é `3,14`. A declaração acima pode ser escrita em duas linhas.

```CSHARP
double x; // Declaração
x = 3.14; // Inicialização
```

Além do `double` também existem outros que são diferentes por causa da precisão e tamanho dos dados armazenados. Os outros são:

* `float`: tem menos precisão e menor tamanho.

* `decimal`: tem maior precisão e maior tamanho.

## Exemplos:

```CSHARP
using System;
class Program {
    static void Main(string[] args) {
        double x = 3.14;
        Console.WriteLine(x); // Imprime: 3.14
        
        float y = 2.71f;
        Console.WriteLine(y); // Imprime: 2.71
        
        decimal z = 1.618m;
        Console.WriteLine(z); // Imprime: 1.618
    }
}
```

## Inferencia de Tipos

Quando usamos o `var` sem declarar o tipo explicitamente, ele atribui automaticamente o tipo `double` porque ele estaria no meio entre `float` e `decimal`, mas se fosse muito próximo de `int` ele seria inferido como `int`.

```CSHARP
var x = 3.14; // Inferência de tipo: double
Console.WriteLine(x.GetType()); // Imprime: Double
```

Agora se quisermos dizer que vai ser float ou decimal devemos usar os sufixos `f` ou `m` respectivamente.

```CSHARP
var x = 3.14f; // Inferência de tipo: float
Console.WriteLine(x.GetType()); // Imprime: Single

var y = 3.14m; // Inferência de tipo: decimal
Console.WriteLine(y.GetType()); // Imprime: Decimal
```

## Tabela de Tipos

| Tipo |Intervalo Aproximado |Precisão |Tamanho |Tipo .NET |
------------------------------------------------------------
| `float` |±1.5 x 10⁻⁴⁵ a ±3.4 x 10³⁸ |6-9 dígitos |4 bytes |System.Single |
| `double` |±5.0 x 10⁻³²⁴ a ±1.7 x 10³⁰⁸ |15-17 dígitos |8 bytes |System.Double |
| `decimal` |±1.0 x 10⁻²⁸ a ±7.9 x 10²⁸ |28-29 dígitos |16 bytes |System.Decimal |

Note:

Os três tipos não usam unsigned ou signed, pois possuem tanto assimilação negativa e positiva por padrão

## Referência

[Tipos de ponto flutuante (referência de C#)](https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)



# Bool

Bool é o tipo de dado booleano (no c# ele se chama bool) e pode receber apenas dois valores: `true` ou `false`.

## Exemplo

```CSHARP
using System;
class Program {
    static void Main(string[] args) {
        bool isTrue = true; // Variável do tipo booleana que recebe valor verdadeiro.
        Console.WriteLine(isTrue); // Imprime no console a variável criada.
    }
}
```

Quando fazemos a inferencia com `var` seguimos a mesma lógica que os outros tipos:

```CSHARP
using System;

class Program {
    static void Main(string[] args) {
        var isFalse = false; // Inferência da variável do tipo booleana que recebe valor falso.
        Console.WriteLine(isFalse);
    }
}
```



# Caracter

É o tipo de caracter que utilizamos para armazenar um  único caracter

Note:

Caracter é um tipo de dado primitivo e representa um único caracter no formato unicode (formato universal para a representação dos caracteres)

Warning:

OBS:
Para declarar uma variável do tipo char, devemos utilizar aspas simples

## Exemplos:

```CSHARP
char letra = 'a';
Console.WriteLine(letra); // imprime: a

char numero = '1';
Console.WriteLine(numero); // imprime: 1

char simbolo = '@';
Console.WriteLine(simbolo); // imprime: @

char espaco = ' ';
Console.WriteLine(espaco); // imprime: espaço em branco

char tabulacao = '\t'; // \t é uma sequência de escape que representa uma tabulação horizontal
Console.WriteLine(tabulacao); // imprime: tabulação horizontal

char novaLinha = '\n'; // \n é uma sequência de escape que representa uma nova linha
Console.WriteLine(novaLinha); // imprime: nova linha

char backspace = '\b'; // \b é uma sequência de escape que representa um caractere de retrocesso
Console.WriteLine(backspace); // imprime: caractere de retrocesso

// unicode
char unicode = '\u0041'; // \u seguido de quatro dígitos hexadecimais representa um caractere Unicode
Console.WriteLine(unicode); // imprime: A
```



# String

As strings são uma cadeia de caracters ou seja são mais de um caracter. Exemplo: "Hello World" é uma string.

Para criar uma variável do tipo string basta usar aspas duplas "" e colocar o texto dentro delas.
Exemplo:

```CSHARP
string nome;
nome = "João";
```

```CSHARP
string nome = "João";
Console.WriteLine(nome); // João
```

Você pode concatenar duas strings usando o operador +, exemplo:

```CSHARP
string nome = "João";
string sobrenome = "Silva";
string nomeCompleto = nome + " " + sobrenome; // João Silva
Console.WriteLine(nomeCompleto);
```

Warning:

IMPORTANTE: Strings SEMPRE serão com aspas duplas ("") e não simples ('')

Mesmo que inicializarmos uma variavel com string e deixar com um caracter e aspas duplas, ela será ainda uma string:

```CSHARP
string letra = "a"; // a
Console.WriteLine(letra.GetType()); // System.String
```



# Var

Var é uma palavra reservada do C#, que permite declarar variáveis sem especificar o tipo de dado. O compilador infere automaticamente o tipo da variável com base no valor atribuído a ela.

Aqui está um exemplo simples:

```CSHARP
var nome = "João";
int idade = 25;
double altura = 1.75;

Console.WriteLine($"Nome: {nome}, Idade: {idade}, Altura: {altura}");
```

Neste exemplo, não precisamos especificar explicitamente os tipos das variáveis `nome`, `idade` e `altura`. O compilador infere que `nome` é do tipo string, `idade` é do tipo int e `altura` é do tipo double.

MAS temos uma questão, o tipo que o compilador inferiu pela primeira vez sobre a variavel não pode ser alterado depois

Então se tivermos, a varivel `nome` como var e sendo inferido que ela é uma string, mas depois quisermos atribuir um inteiro para ela, teremos um erro:

```CSHARP
var nome = "João"; // Inferência de tipo: string
nome = 4; // Erro! Não é possível atribuir um inteiro a uma variável do tipo string.
```

![Erro de conversão implicita string para int](images/Erro%20de%20convers%C3%A3o%20implicita%20string%20para%20int)



# Object

É um tipo de dado genérico que pode aceitar qualquer tipo de valor ou objeto

Usado para por exemplo quando não sabe o tipo da informação ou ela é de varios tipos diferentes

```CSHARP
object obj = 10;
obj = "Hello World";
```

Note:

OBS: Não é recomendado usar pois a conversão entre os tipos deve ser feita manualmente e isso pode gerar erros em tempo de execução.

## Boxing and Unboxing

Boxing: Converte um tipo primitivo em object.

* Exemplo:

```CSHARP
int i = 5; // Tipo primitivo int
object obj = i; // Boxing, converte o tipo int em object
```

Unboxing: Converte um object em um tipo primitivo.

* Exemplo:

```CSHARP
object obj = 5; // Objeto do tipo object com valor inteiro
int i = (int)obj; // Unboxing, converte o objeto em um tipo primitivo int
```

Note:

Podemos pensar nesse boxing como um ato de colocar algo dentro de uma caixa, cujo o conteúdo pode ser qualquer coisa.

E o unboxing seria o ato de tirar algo dessa caixa.

Note:

Uma diferença entre `var`e `object` é que no caso do object você não precisa iniciar um valor por exemplo:

```CSHARP
object obj;
```

E quando fazer uma reatribuição de valor de um tipo diferente não dara problema, diferente do `var`:

```CSHARP
var var = 10;
var = "Hello World"; // Erro: Cannot implicitly convert type 'string' to 'int'
```

No caso do `object`, podemos fazer assim sem problemas:

```CSHARP
object obj = 10;
obj = "Hello World";
```



# Nullable Types

O tipo `null` significa "nulo" ou "vazio". Em C#, o valor padrão de um tipo é sempre definido como nulo. Por exemplo, se você declarar uma variável do tipo inteiro e não atribuir nenhum valor a ela, seu valor será zero.

Note:

Null é diferente de 0 (zero) e uma string vazia ("")". Null indica que a variável não tem nenhum valor válido enquanto 0 é um valor numérico válido.

E todo tipo primitivo ou complexo pode  receber nulo

Podemos marcar como Nullable Type, podemos fazer isso com:

Note:

A sintaxe para criar um tipo Nullable é colocando um ponto de interrogação após o nome do tipo.

```CSHARP
int? x = null;
```



# Valores Parões

Todo tipo built-in possui um valor padrão.

Por exemplo, o valor padrão de `int` é 0 e o valor padrão de `bool` é false.

Note:

O valor padrão de uma variável não inicializada é sempre seu valor padrão.

## Tabela com alguns valores padrões:

| Tipo |Valor Padrão |
----------------------
| int |0 |
| bool |false |
| string |null |
| double |0.0 |
| float |0.0f |
| char |'\0' |
| decimal |0m |
| long |0L |
| short |0 |
| byte |0 |
| ulong |0UL |
| ushort |0U |
| uint |0U |
| sbyte |0S |
| DateTime |1/1/0001 |
| TimeSpan |0:00:00 |
| Guid |00000000-0000-0000-0000-0000000 |



# Alias

Alias, é um apelido que todo tipo no .NET tem por exemplo:

```CSHARP
int i = 0; // int é o alias de System.Int32
System.Int32 j = 1; // aqui estamos usando a classe Int32 diretamente.
```

O mesmo acontece com outros tipos como: `string` e `bool`, etc.

Note:

Você pode ver todos os aliases em [https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/built-in-types](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/built-in-types)



# Casting

Em C#, "casting" (ou conversão explícita) é o processo de instruir o compilador a tratar uma variável de um tipo como se fosse de outro tipo. É uma operação fundamental, mas que deve ser compreendida para evitar perda de dados ou erros em tempo de execução.

O casting é diferente de usar classes utilitárias como `Convert` ou métodos como `Parse`. O casting é uma operação mais direta e de nível mais baixo, usada principalmente entre tipos numericamente compatíveis ou dentro de uma hierarquia de classes (herança).

## Conversão Implícita (Casting Implícito)

A conversão implícita, também conhecida como widening conversion, ocorre automaticamente quando um valor de um tipo "menor" é atribuído a uma variável de um tipo "maior", onde não há risco de perda de dados. É uma operação segura, e o compilador a realiza por você.

```CSHARP
// Um int (32 bits) cabe facilmente em um long (64 bits).
int meuInt = 2147483647;
long meuLong = meuInt; // Conversão implícita, totalmente segura.

// Um int (inteiro) cabe facilmente em um double (ponto flutuante).
int numero = 10;
double meuDouble = numero; // Conversão implícita. O valor se torna 10.0.

Console.WriteLine(meuDouble); // Saída: 10
```

## Conversão Explícita (Casting Explícito)

A conversão explícita, também chamada de narrowing conversion, é necessária quando há risco de perda de dados. Você deve instruir o compilador explicitamente usando a sintaxe de cast `(novoTipo)`. Ao fazer isso, você está dizendo ao compilador: "Eu sei que isso pode falhar ou perder dados, mas eu assumo a responsabilidade."

```CSHARP
double salario = 2599.95;

// Forçar a conversão de double para int. A parte decimal será perdida (truncada).
// Você DEVE usar o (int) para que o código compile.
int salarioInteiro = (int)salario;

Console.WriteLine(salarioInteiro); // Saída: 2599 (a informação .95 foi perdida)

// Outro exemplo de risco: converter um número grande para um tipo menor
long numeroGrande = 3000000000; // 3 bilhões

// int só pode armazenar até ~2.1 bilhões. Isso causará um Overflow.
// O resultado será um número inesperado e incorreto, sem lançar exceção em um contexto unchecked.
int intPequeno = (int)numeroGrande;

Console.WriteLine(intPequeno); // Saída: -1294967296 (lixo de memória)
```

Warning:

O casting explícito de tipos numéricos pode levar à **perda de dados** (truncamento) ou **estouro de capacidade** (overflow), resultando em valores incorretos. Use-o apenas quando tiver certeza de que o valor de origem caberá no tipo de destino.

## Casting em Programação Orientada a Objetos

O casting é essencial ao trabalhar com herança de classes.

```CSHARP
// Cenário de exemplo
public class Animal { }
public class Cachorro : Animal { public void Latir() { } }
public class Gato : Animal { public void Miar() { } }
```

### Upcasting (Implícito e Seguro)

Upcasting é converter uma referência de uma classe derivada (filha) para uma de sua classe base (mãe). Isso é sempre seguro e, portanto, implícito.

```CSHARP
Cachorro meuCachorro = new Cachorro();

// Upcasting: tratando um Cachorro como um Animal genérico.
// Isso é útil para criar listas de diferentes tipos de animais.
Animal animalGenerico = meuCachorro; // Upcasting implícito.
```

### Downcasting (Explícito e Arriscado)

Downcasting é o oposto: tentar converter uma referência de classe base de volta para sua classe derivada original. Isso é arriscado porque o `Animal` genérico poderia ser um `Gato`, e não um `Cachorro`. Tentar um downcast inválido lança uma `InvalidCastException`.

```CSHARP
// ...continuando de cima

// Tentativa de Downcasting
// O compilador exige o (Cachorro) porque a operação pode falhar.
Cachorro cachorroEspecifico = (Cachorro)animalGenerico; 
cachorroEspecifico.Latir(); // Funciona!

// Exemplo de falha
Animal outroAnimal = new Gato();
// A linha abaixo compila, mas lançará uma InvalidCastException em tempo de execução,
// porque um Gato não pode ser tratado como um Cachorro.
// Cachorro caoImpossivel = (Cachorro)outroAnimal; 
```

## 

Alternativas Seguras para Downcasting: `as` e `is`

Para evitar exceções, o C# fornece operadores mais seguros para downcasting.

* `is`: Verifica se a conversão é possível, retornando `true` ou `false`.

* `as`: Tenta a conversão. Se for bem-sucedida, retorna o objeto convertido. Se falhar, retorna `null` em vez de lançar uma exceção.

```CSHARP
Animal animalMisterioso = new Gato();

// Usando 'is' para verificar antes de converter
if (animalMisterioso is Cachorro)
{
    Cachorro caoVerificado = (Cachorro)animalMisterioso; // Seguro, mas verboso
    caoVerificado.Latir();
}
else
{
    Console.WriteLine("O animal misterioso não é um cachorro.");
}

// Usando 'as' para uma conversão segura e concisa (a abordagem preferida)
Cachorro caoComAs = animalMisterioso as Cachorro;
if (caoComAs != null)
{
    caoComAs.Latir();
}
else
{
    Console.WriteLine("A conversão com 'as' falhou, o animal não é um cachorro.");
}
```

## 

Guia Rápido: Casting vs. `Convert` vs. `Parse`

| Operação |Quando Usar |Exemplo |
----------------------------------
| Casting |Entre tipos numéricos ou em hierarquias de classes. |`int i = (int)10.5;` |
| `Convert` |Conversão segura entre muitos tipos base, especialmente com `nulls`. |`int i = Convert.ToInt32(null);` |
| `Parse` |Apenas para converter uma `string` para seu tipo correspondente. |`int i = int.Parse("10");` |



# Implicit Casting

A conversão implicita é quando  podemos executar essa transformação apenas com a passagem de dados

E os tipos são compatíveis entre si, como por exemplo:

* int -> long

* float -> double

* short -> int

* char -> int

## Exemplos:

```CSHARP
float value = 25.8f;
int newValue = (int)value; // Conversão implícita
```

Note:

Nesse caso, estamos atribuindo um valor do tipo float à uma variável do tipo int. O compilador irá realizar a conversão automaticamente, pois o tipo float pode ser convertido em um inteiro sem perda de precisão.



# Explicit Casting

Ocorre quando os tipos não são compativeis e é dada pelo uso do tipo entre parênteses antes da atribuição

## Exemplos:

```CSHARP
int inteiro = 100;
uint inteiroSemSinal = (uint)inteiro; //Conversão de int para uint
```



# Parse

O método `Parse` é uma funcionalidade estática presente na maioria dos tipos de valor do C# (como `int`, `double`, `bool`, `DateTime`, etc.). Sua função específica é converter a representação em string de um valor em uma instância real daquele tipo.

É a ferramenta ideal quando você tem um texto e precisa que ele se torne um tipo de dado funcional.

```CSHARP
string textoNumero = "123";

// O método Parse converte a string "123" para o inteiro 123.
int numero = int.Parse(textoNumero);

Console.WriteLine(numero * 2); // Saída: 246
Console.WriteLine(numero.GetType().Name); // Saída: Int32
```

## 

O Risco do `Parse`: Exceções

O método `Parse` é otimista: ele assume que a conversão será bem-sucedida. Se a string de entrada não estiver em um formato válido ou for nula, ele lançará uma exceção, interrompendo o fluxo normal do programa.

* `FormatException`: A string não corresponde ao formato esperado.

* `ArgumentNullException`: A string fornecida é `null`.

* `OverflowException`: O número na string é grande ou pequeno demais para o tipo de destino.

Para usar `Parse` de forma segura, você deve envolvê-lo em um bloco `try-catch`:

```CSHARP
string entradaUsuario = "não é um número";
try
{
    int resultado = int.Parse(entradaUsuario);
    Console.WriteLine($"Conversão bem-sucedida: {resultado}");
}
catch (FormatException)
{
    Console.WriteLine("Erro: O formato da entrada é inválido.");
}
catch (ArgumentNullException)
{
    Console.WriteLine("Erro: A entrada não pode ser nula.");
}
```

## 

A Alternativa Segura e Eficiente: `TryParse`

Lançar e capturar exceções é um processo computacionalmente caro. Para cenários de validação (como processar input de um usuário), onde uma falha de conversão é um evento esperado, o C# oferece uma alternativa muito mais eficiente: o padrão `TryParse`.

O método `TryParse` tenta realizar a conversão e, em vez de lançar uma exceção, ele retorna um `bool` que indica se a operação foi bem-sucedida. O valor convertido é retornado através de um parâmetro `out`.

```CSHARP
string entradaDoUsuario = "42";

// Tenta converter a string. 
// Se conseguir, 'numeroConvertido' receberá o valor 42 e o método retornará 'true'.
// Se não conseguir, 'numeroConvertido' receberá 0 (valor padrão) e o método retornará 'false'.
if (int.TryParse(entradaDoUsuario, out int numeroConvertido))
{
    // Este bloco só executa se a conversão funcionar
    Console.WriteLine($"Sucesso! O número é {numeroConvertido}");
}
else
{
    // Este bloco só executa se a conversão falhar
    Console.WriteLine("Falha na conversão. Por favor, insira um número válido.");
}
```

### 

Por que `TryParse` é melhor?

1. Performance: Evita o alto custo de criar e gerenciar exceções.

2. Clareza: O código fica mais limpo e a intenção (validar e converter) é mais clara.

3. Simplicidade: Permite a validação e a atribuição em uma única linha dentro de uma condição `if`.

## 

Tabela de Referência de Métodos `Parse` e `TryParse`

Abaixo está uma tabela de referência para os métodos `Parse` e `TryParse` nos tipos mais comuns.

| Tipo |Método `Parse` (Lança Exceção) |Método `TryParse` (Retorna `bool`) |
----------------------------------------------------------------------------
| `int` |`int.Parse(str)` |`int.TryParse(str, out int val)` |
| `long` |`long.Parse(str)` |`long.TryParse(str, out long val)` |
| `double` |`double.Parse(str)` |`double.TryParse(str, out double val)` |
| `decimal` |`decimal.Parse(str)` |`decimal.TryParse(str, out decimal val)` |
| `float` |`float.Parse(str)` |`float.TryParse(str, out float val)` |
| `bool` |`bool.Parse(str)` |`bool.TryParse(str, out bool val)` |
| `DateTime` |`DateTime.Parse(str)` |`DateTime.TryParse(str, out DateTime val)` |
| `Guid` |`Guid.Parse(str)` |`Guid.TryParse(str, out Guid val)` |

## Tópico Avançado: Sensibilidade à Cultura

Um detalhe crucial que diferencia um desenvolvedor sênior é o entendimento sobre cultura (`CultureInfo`). O método `Parse` por padrão utiliza as regras de formatação do sistema operacional onde o código está rodando.

Isso pode causar bugs difíceis de rastrear. Por exemplo, a string `"1,234.56"` representa mil duzentos e trinta e quatro em português, mas em inglês o `.` é o separador decimal.

```CSHARP
using System.Globalization;

string numeroAlemao = "1.234,56"; // Ponto como separador de milhar, vírgula como decimal

// Usando a cultura alemã (de-DE) para interpretar a string corretamente
CultureInfo culturaAlema = new CultureInfo("de-DE");
double valor = double.Parse(numeroAlemao, culturaAlema);

Console.WriteLine(valor); // Saída: 1234.56 (convertido para o formato padrão do sistema)

// A linha abaixo lançaria uma FormatException em um sistema com cultura pt-BR ou en-US
// double valorIncorreto = double.Parse(numeroAlemao); 
```

O `TryParse` também possui sobrecargas que aceitam `CultureInfo` para uma conversão segura e culturalmente correta.

## 

Guia de Decisão: `Parse` vs. `TryParse`

* Use `Parse` quando: * Você tem 100% de certeza que a string é válida (ex: vem de uma fonte interna confiável, como um valor fixo no código ou um banco de dados com dados já validados). * Uma falha na conversão representa um erro excepcional e inesperado no seu sistema.

* Use `TryParse` quando: * A string vem de uma fonte externa e não confiável (input de usuário, arquivo de texto, resposta de API, etc.). * A falha na conversão é um cenário esperado e faz parte da lógica de validação do seu programa.



# Convert

A classe `System.Convert` é uma ferramenta essencial no C#, fornecendo um conjunto de métodos estáticos para realizar conversões entre os tipos de dados base (primitivos). Ela atua como uma solução robusta e explícita, oferecendo mais flexibilidade e segurança em comparação com o casting direto ou os métodos `Parse`.

Pense na classe `Convert` como um tradutor universal para os tipos de dados do .NET.

## 

`Convert` vs. Casting vs. `Parse`

É crucial para um desenvolvedor C# entender quando usar cada mecanismo de conversão.

| Mecanismo |Sintaxe |Uso Principal |Comportamento em Falha |
-------------------------------------------------------------
| Casting |`(novoTipo)valor;` |Entre tipos numéricos compatíveis ou em hierarquias de classes (upcasting/downcasting). |`InvalidCastException` em tempo de execução se a conversão for inválida. |
| Parse |`tipo.Parse(string);` |Exclusivamente para converter uma `string` em seu tipo correspondente. |`FormatException` se a string não estiver no formato correto; `ArgumentNullException` se for nula. |
| Convert |`Convert.ToNovoTipo(valor);` |Entre uma grande variedade de tipos (números, strings, booleanos, objetos, etc.). |`FormatException` para strings mal formatadas; `OverflowException` para estouro de capacidade. |

### 

A Grande Vantagem: Tratamento de `null`

A principal diferença e vantagem da classe `Convert` é a forma como ela lida com valores `null`. Ao contrário do casting ou do `Parse`, que lançam uma exceção, `Convert` retorna o valor padrão do tipo de destino.

```CSHARP
string textoNulo = null;

// Lança ArgumentNullException
// int numeroComParse = int.Parse(textoNulo); 

// Retorna 0 (valor padrão de int)
int numeroComConvert = Convert.ToInt32(textoNulo); 

Console.WriteLine(numeroComConvert); // Saída: 0
```

Esse comportamento torna o `Convert` a escolha mais segura e previsível ao lidar com dados que podem ser nulos, como valores vindos de bancos de dados, APIs ou input do usuário.

## Comportamento de Arredondamento

Ao converter um número de ponto flutuante (como `double` ou `float`) para um inteiro, a classe `Convert` utiliza o "Arredondamento do Banqueiro" (`MidpointRounding.ToEven`). Neste método, números que estão exatamente no meio (como 2.5 ou 3.5) são arredondados para o número par mais próximo.

```CSHARP
double valor1 = 2.5;
double valor2 = 3.5;
double valor3 = 4.6;

Console.WriteLine(Convert.ToInt32(valor1)); // Saída: 2 (arredonda para o par mais próximo)
Console.WriteLine(Convert.ToInt32(valor2)); // Saída: 4 (arredonda para o par mais próximo)
Console.WriteLine(Convert.ToInt32(valor3)); // Saída: 5 (arredondamento normal)
```

## Exemplos de Conversões Comuns

A classe `Convert` é extremamente versátil.

```CSHARP
// De string para int
string strNumero = "123";
int numero = Convert.ToInt32(strNumero);

// De int para string
int valorInt = 456;
string strValor = Convert.ToString(valorInt);

// De double para int (com arredondamento)
double salario = 2589.72;
int salarioInt = Convert.ToInt32(salario); // Resultado: 2590

// De string para booleano (não diferencia maiúsculas/minúsculas)
string strBool = "True";
bool valorBool = Convert.ToBoolean(strBool); // Resultado: true

// De qualquer tipo para string
bool ativo = false;
string strAtivo = Convert.ToString(ativo); // Resultado: "False"

// De object para int (seguro contra nulos)
object objValor = null;
int valorObj = Convert.ToInt32(objValor); // Resultado: 0
```

## 

Tabela de Referência de Métodos `Convert`

Abaixo está uma tabela de referência rápida para os métodos de conversão mais utilizados da classe `Convert`.

| Método |Descrição |Exemplo de Uso |
-------------------------------------
| `Convert.ToBoolean(valor)` |Converte um valor (string, número, etc.) para `bool`. |`bool b = Convert.ToBoolean("true");` |
| `Convert.ToByte(valor)` |Converte um valor para `byte` (inteiro de 8 bits sem sinal). |`byte y = Convert.ToByte(12);` |
| `Convert.ToChar(valor)` |Converte uma string de um caractere ou número para `char`. |`char c = Convert.ToChar('A');` |
| `Convert.ToDateTime(valor)` |Converte uma string (em formato de data/hora válido) para `DateTime`. |`DateTime dt = Convert.ToDateTime("2025-07-14");` |
| `Convert.ToDecimal(valor)` |Converte um valor para `decimal` (alta precisão). |`decimal d = Convert.ToDecimal("123.45");` |
| `Convert.ToDouble(valor)` |Converte um valor para `double` (ponto flutuante de precisão dupla). |`double o = Convert.ToDouble("123.45");` |
| `Convert.ToInt16(valor)` |Converte um valor para `short` (inteiro de 16 bits). |`short s = Convert.ToInt16("123");` |
| `Convert.ToInt32(valor)` |Converte um valor para `int` (inteiro de 32 bits). |`int i = Convert.ToInt32("123");` |
| `Convert.ToInt64(valor)` |Converte um valor para `long` (inteiro de 64 bits). |`long l = Convert.ToInt64("123");` |
| `Convert.ToString(valor)` |Converte qualquer tipo base para sua representação em `string`. |`string str = Convert.ToString(123.45);` |

## Tópico Avançado: Conversão de Base Numérica

Um recurso poderoso e muitas vezes subutilizado da classe `Convert` é a capacidade de converter números entre diferentes bases (binário, octal, decimal, hexadecimal).

```CSHARP
// Convertendo um inteiro para sua representação em string binária e hexadecimal
int numeroDecimal = 255;
string binario = Convert.ToString(numeroDecimal, 2);    // Base 2
string hexadecimal = Convert.ToString(numeroDecimal, 16); // Base 16

Console.WriteLine($"Decimal: {numeroDecimal}");   // Saída: Decimal: 255
Console.WriteLine($"Binário: {binario}");       // Saída: Binário: 11111111
Console.WriteLine($"Hexadecimal: {hexadecimal.ToUpper()}"); // Saída: Hexadecimal: FF

// Convertendo de volta para inteiro
int deBinario = Convert.ToInt32("11111111", 2);
int deHexadecimal = Convert.ToInt32("FF", 16);

Console.WriteLine($"De Binário: {deBinario}");       // Saída: De Binário: 255
Console.WriteLine($"De Hexadecimal: {deHexadecimal}"); // Saída: De Hexadecimal: 255
```

## Tratamento de Exceções

Apesar de sua flexibilidade, `Convert` ainda pode lançar exceções se a conversão for impossível.

* `FormatException`: Ocorre se uma string de entrada não estiver em um formato válido para o tipo de destino.

* `OverflowException`: Ocorre se o número de origem for muito grande (ou muito pequeno) para caber na capacidade do tipo de destino.

É uma boa prática envolver as chamadas de `Convert` em um bloco `try-catch` quando a entrada não for confiável.

```CSHARP
string valorGigante = "9999999999999999999999999999";
try
{
    int resultado = Convert.ToInt32(valorGigante);
    Console.WriteLine(resultado);
}
catch (FormatException ex)
{
    Console.WriteLine("Erro de formato: A string não é um número válido.");
}
catch (OverflowException ex)
{
    Console.WriteLine("Erro de Overflow: O número é grande demais para um inteiro.");
}
```

Tip:

Para cenários onde você espera que a conversão de uma string possa falhar e não quer lidar com exceções, a abordagem `tipo.TryParse()` continua sendo a melhor prática.



# Operadores Aritméticos

Operadores aritméticos são símbolos usados para realizar cálculos matemáticos em operandos numéricos. São a base da manipulação de números em C#.

## Tabela de Operadores Aritméticos

| Operador |Descrição |Exemplo |Resultado |
-------------------------------------------
| `+` |Adição |`5 + 3` |`8` |
| `-` |Subtração |`5 - 3` |`2` |
| `*` |Multiplicação |`5 * 3` |`15` |
| `/` |Divisão |`5 / 3` |`1` |
| `%` |Módulo (Resto da Divisão) |`5 % 3` |`2` |

### A Armadilha da Divisão de Inteiros

Um ponto de atenção crucial em C# é a divisão entre dois números inteiros. O resultado será sempre um inteiro, com a parte decimal sendo truncada (removida), não arredondada.

```CSHARP
int a = 5;
int b = 3;

// Como 'a' e 'b' são inteiros, o resultado é 1, não 1.66.
int resultadoInteiro = a / b; 
Console.WriteLine(resultadoInteiro); // Saída: 1
```

Para obter um resultado com precisão decimal, pelo menos um dos operandos deve ser um tipo de ponto flutuante (`double`, `float`, `decimal`).

```CSHARP
// Convertendo (casting) um dos inteiros para double antes da divisão
double resultadoDouble = (double)a / b;
Console.WriteLine(resultadoDouble); // Saída: 1.66666...
```

## Operadores de Incremento e Decremento

Estes operadores unários modificam uma variável, adicionando ou subtraindo 1. A posição do operador (`++` ou `--`) em relação à variável muda o comportamento da expressão.

* Pós-fixado (`variavel++` ou `variavel--`): O valor da variável é primeiro retornado para a expressão e depois modificado.

* Pré-fixado (`++variavel` ou `--variavel`): O valor da variável é primeiro modificado e depois o novo valor é retornado para a expressão.

```CSHARP
int a = 5;
int b = 5;

// Pós-fixado: 'c' recebe o valor original de 'a' (5), depois 'a' vira 6.
int c = a++; 

// Pré-fixado: 'b' primeiro vira 6, depois 'd' recebe o novo valor de 'b' (6).
int d = ++b;

Console.WriteLine($"a: {a}, c: {c}"); // Saída: a: 6, c: 5
Console.WriteLine($"b: {b}, d: {d}"); // Saída: b: 6, d: 6
```

## Precedência de Operadores

A precedência define a ordem em que as operações são executadas em uma expressão complexa. Operadores com maior precedência são avaliados primeiro.

| Ordem |Categoria |Operadores |
--------------------------------
| 1 |Primário |`()` (Parênteses para forçar a ordem) |
| 2 |Unário |`++` (pré-fixado), `--` (pré-fixado), `+` (positivo), `-` (negativo) |
| 3 |Multiplicativo |`*`, `/`, `%` |
| 4 |Aditivo |`+`, `-` |
| 5 |Pós-fixado |`++` (pós-fixado), `--` (pós-fixado) |

Note:

O operador de exponenciação (`**`) não existe em C#. Para cálculos de potência, utilize o método `Math.Pow(base, expoente)`.

Você pode usar parênteses `()` para forçar uma ordem de avaliação diferente da padrão, o que também melhora a legibilidade do código.

```CSHARP
// Sem parênteses: 2 * 3 = 6, depois 6 + 4 = 10
int resultado1 = 2 * 3 + 4; // resultado1 = 10

// Com parênteses: 3 + 4 = 7, depois 2 * 7 = 14
int resultado2 = 2 * (3 + 4); // resultado2 = 14
```



# Operadores de Atribuição

Operadores de atribuição são usados para designar um valor a uma variável. O operador de atribuição fundamental é o sinal de igual (`=`), que atribui o valor do operando à direita para a variável à esquerda.

```CSHARP
// A variável 'idade' recebe o valor 30.
int idade = 30;

// A variável 'nome' recebe o valor da string "Alice".
string nome = "Alice";
```

## Operadores de Atribuição Composta

C# oferece operadores de atribuição composta que combinam uma operação aritmética com a atribuição. Eles são atalhos úteis que tornam o código mais conciso e, em alguns casos, mais eficiente.

A expressão `x op= y` é, em geral, equivalente a `x = x op y`, onde `op` é um operador aritmético.

### Tabela de Operadores de Atribuição Composta

| Operador |Exemplo |Equivalente a |Descrição |
-----------------------------------------------
| `+=` |`x += y` |`x = x + y` |Adiciona `y` a `x` e atribui o resultado a `x`. |
| `-=` |`x -= y` |`x = x - y` |Subtrai `y` de `x` e atribui o resultado a `x`. |
| `*=` |`x *= y` |`x = x * y` |Multiplica `x` por `y` e atribui o resultado a `x`. |
| `/=` |`x /= y` |`x = x / y` |Divide `x` por `y` e atribui o resultado a `x`. |
| `%=` |`x %= y` |`x = x % y` |Calcula o resto da divisão de `x` por `y` e atribui a `x`. |

### Exemplos Práticos

```CSHARP
int saldo = 100;

saldo += 50; // saldo agora é 150 (100 + 50)
Console.WriteLine($"Após depósito: {saldo}");

saldo -= 30; // saldo agora é 120 (150 - 30)
Console.WriteLine($"Após saque: {saldo}");

int multiplicador = 5;
multiplicador *= 2; // multiplicador agora é 10 (5 * 2)
Console.WriteLine($"Multiplicado: {multiplicador}");

int dividendo = 20;
dividendo /= 4; // dividendo agora é 5 (20 / 4)
Console.WriteLine($"Dividido: {dividendo}");

int resto = 10;
resto %= 3; // resto agora é 1 (10 % 3)
Console.WriteLine($"Resto: {resto}");
```

Note:

O uso de operadores de atribuição composta é considerado uma boa prática em C#, pois pode levar a um código mais limpo e fácil de ler, especialmente em operações de atualização de variáveis.



# Operadores de Comparação

Operadores de comparação (ou relacionais) são usados para comparar dois operandos. O resultado de uma operação de comparação é sempre um valor booleano: `true` ou `false`. Eles são a base para a tomada de decisões e o controle de fluxo em C#, sendo essenciais em estruturas como `if`, `while` e `for`.

## Tabela de Operadores de Comparação

| Operador |Descrição |Exemplo (com `a = 5`, `b = 10`) |Resultado |
-------------------------------------------------------------------
| `==` |Igual a |`a == 5` |`true` |
| `!=` |Diferente de |`a != b` |`true` |
| `<` |Menor que |`a < b` |`true` |
| `>` |Maior que |`a > b` |`false` |
| `<=` |Menor ou igual a |`a <= 5` |`true` |
| `>=` |Maior ou igual a |`b >= 10` |`true` |

## Exemplos de Uso no Controle de Fluxo

O principal uso dos operadores de comparação é em declarações condicionais para direcionar o fluxo do programa.

```CSHARP
int idade = 18;

// Usando '==' para verificar igualdade
if (idade == 18)
{
    Console.WriteLine("Tem exatamente 18 anos.");
}

// Usando '>=' para verificar maioridade
if (idade >= 18)
{
    Console.WriteLine("É maior de idade.");
}

// Usando '!=' para verificar diferença
string nome = "Alice";
if (nome != "Bob")
{
    Console.WriteLine("O nome não é Bob.");
}

// Usando em um loop 'while'
int contador = 0;
while (contador < 5)
{
    Console.WriteLine($"O contador é {contador}");
    contador++; // Essencial para evitar um loop infinito
}
```

## Comparando Tipos de Referência vs. Tipos de Valor

É crucial entender a diferença ao usar `==` com tipos de valor e tipos de referência.

* Tipos de Valor (`int`, `double`, `bool`, `struct`): O operador `==` compara os valores reais contidos nas variáveis. ```CSHARP int a = 10; int b = 10; Console.WriteLine(a == b); // Saída: true (porque 10 é igual a 10) ```

* Tipos de Referência (`string`, `class`, `array`): Por padrão, o operador `==` compara as referências de memória, ou seja, ele verifica se as duas variáveis apontam para o mesmo objeto na memória, e não se seus conteúdos são iguais. ```CSHARP public class Pessoa { public string Nome { get; set; } } Pessoa p1 = new Pessoa { Nome = "Alex" }; Pessoa p2 = new Pessoa { Nome = "Alex" }; Pessoa p3 = p1; Console.WriteLine(p1 == p2); // Saída: false (são dois objetos diferentes na memória) Console.WriteLine(p1 == p3); // Saída: true (ambos apontam para o mesmo objeto) ```

Note:

O tipo `string` é uma exceção especial. Embora seja um tipo de referência, o operador `==` foi sobrecarregado para comparar o **conteúdo** das strings, não suas referências. Portanto, `"hello" == "hello"` retorna `true`, que é o comportamento que a maioria dos desenvolvedores espera.



# Operadores Lógicos e Condicionais

Em C#, operadores lógicos e condicionais são usados para trabalhar com valores booleanos (`true`/`false`) e para tomar decisões baseadas em condições. Eles são a cola que une as comparações para criar regras de negócio e fluxos de controle complexos.

## Operadores Lógicos Condicionais (Short-Circuiting)

Estes são os operadores lógicos mais comuns. Eles são chamados de "condicionais" ou "short-circuiting" porque só avaliam o segundo operando se for estritamente necessário.

| Operador |Nome |Exemplo |Descrição |
--------------------------------------
| `&&` |E (AND) |`expr1 && expr2` |Retorna `true` somente se ambas as expressões forem `true`. |
| `\|\|` |OU (OR) |`expr1 \|\| expr2` |Retorna `true` se pelo menos uma das expressões for `true`. |
| `!` |NÃO (NOT) |`!expr1` |Inverte o valor booleano da expressão (de `true` para `false` e vice-versa). |

### A Importância do Short-Circuiting

* `&&` (E): Se a primeira expressão (`expr1`) for `false`, o resultado da operação será sempre `false`, independentemente da segunda expressão. Portanto, `expr2` não é avaliada. Isso é útil para evitar erros. ```CSHARP string nome = null; // A segunda verificação (nome.Length > 0) nunca é executada, evitando uma NullReferenceException. if (nome != null && nome.Length > 0) { Console.WriteLine("Nome válido."); } else { Console.WriteLine("Nome inválido ou nulo."); } ```

* `||` (OU): Se a primeira expressão (`expr1`) for `true`, o resultado da operação será sempre `true`. Portanto, `expr2` não é avaliada. Isso pode ser usado para otimização. ```CSHARP bool usuarioAdmin = true; // A função VerificarPermissao() nunca é chamada, economizando processamento. if (usuarioAdmin || VerificarPermissao()) { Console.WriteLine("Acesso concedido."); } ```

## Operadores Condicionais

### 

Operador Ternário (`? :`)

O operador condicional ternário é um atalho conciso para uma instrução `if-else`. Ele avalia uma condição booleana e retorna um de dois valores.

Sintaxe: `condição ? valor_se_verdadeiro : valor_se_falso;`

```CSHARP
int idade = 20;
string status = (idade >= 18) ? "Maior de idade" : "Menor de idade";

Console.WriteLine(status); // Saída: Maior de idade

// O código acima é um atalho para:
// string status;
// if (idade >= 18)
// {
//     status = "Maior de idade";
// }
// else
// {
//     status = "Menor de idade";
// }
```

### 

Operador de Coalescência Nula (`??`)

Este operador é usado para fornecer um valor padrão para tipos de referência ou tipos de valor anuláveis. Ele retorna o operando da esquerda se ele não for nulo; caso contrário, ele retorna o operando da direita.

```CSHARP
string nomeDoBanco = null;

// Se nomeDoBanco for nulo, use "Convidado". Caso contrário, use o próprio valor.
string nomeUsuario = nomeDoBanco ?? "Convidado";

Console.WriteLine(nomeUsuario); // Saída: Convidado

string nomeValido = "Alice";
nomeUsuario = nomeValido ?? "Convidado";
Console.WriteLine(nomeUsuario); // Saída: Alice
```

## Tópico Avançado: Operadores Lógicos Booleanos e Bitwise

C# também possui operadores que parecem lógicos, mas têm um propósito diferente e mais específico. É crucial não confundi-los com os operadores condicionais `&&` e `||`.

### 

Operadores Lógicos Booleanos (`&` e `|`)

Estes operadores são similares a `&&` e `||`, mas com uma diferença fundamental: eles sempre avaliam ambos os operandos, ou seja, não fazem short-circuiting. Seu uso é raro em lógica condicional do dia a dia.

| Operador |Nome |Exemplo |Descrição |
--------------------------------------
| `&` |E (AND) Lógico |`expr1 & expr2` |Retorna `true` se ambas forem `true`. Sempre avalia as duas expressões. |
| `\|` |OU (OR) Lógico |`expr1 \| expr2` |Retorna `true` se uma delas for `true`. Sempre avalia as duas expressões. |
| `^` |OU Exclusivo (XOR) |`expr1 ^ expr2` |Retorna `true` se apenas uma das expressões for `true`. |

### 

Operadores Bitwise (`&`, `|`, `^`, `~`, `<<`, `>>`)

Quando usados com tipos de dados inteiros (`int`, `long`, `byte`, etc.), estes símbolos atuam como operadores bitwise. Eles manipulam a representação binária (os bits) dos números, sendo usados em cenários de baixo nível, como manipulação de flags, criptografia ou otimizações de performance.

* `&` (AND): Compara os bits de dois números. Um bit de resultado é 1 somente se ambos os bits correspondentes forem 1.

* `|` (OR): Compara os bits. Um bit de resultado é 1 se pelo menos um dos bits correspondentes for 1.

* `^` (XOR): Compara os bits. Um bit de resultado é 1 se os bits correspondentes forem diferentes.

* `~` (NOT): Inverte todos os bits de um número.

* `<<` (Shift Left): Desloca os bits para a esquerda, preenchendo com zeros (multiplicação por 2).

* `>>` (Shift Right): Desloca os bits para a direita (divisão por 2).

```CSHARP
// Exemplo de Bitwise AND
//   5 = 0101 (binário)
//   3 = 0011 (binário)
// -------------------
// AND = 0001 (binário) = 1 (decimal)
int resultado = 5 & 3;
Console.WriteLine(resultado); // Saída: 1
```



# Estruturas Condicionais

Estruturas condicionais permitem que um programa execute diferentes blocos de código com base em condições booleanas (`true` ou `false`). Elas são a principal maneira de criar lógica e tomar decisões em C#.

## 

A Estrutura `if`

A instrução `if` é a estrutura condicional mais fundamental. Ela executa um bloco de código somente se a condição especificada for `true`.

Sintaxe:

```
if (condição)
{
    // Bloco de código a ser executado se a condição for verdadeira.
}
```

Exemplo:

```CSHARP
int idade = 20;
if (idade >= 18)
{
    Console.WriteLine("Você é maior de idade.");
}
```

## 

A Estrutura `if-else`

A instrução `else` pode ser adicionada a um `if` para executar um bloco de código alternativo quando a condição do `if` for `false`.

Sintaxe:

```
if (condição)
{
    // Bloco de código se a condição for verdadeira.
}
else
{
    // Bloco de código se a condição for falsa.
}
```

Exemplo:

```CSHARP
int temperatura = 15;
if (temperatura > 25)
{
    Console.WriteLine("Está calor.");
}
else
{
    Console.WriteLine("Não está calor.");
}
```

## 

A Estrutura `if-else if-else`

Para testar múltiplas condições em sequência, você pode usar a estrutura `else if`. O C# avaliará as condições na ordem em que aparecem e executará o primeiro bloco de código cuja condição seja `true`. O bloco `else` final é opcional e serve como uma condição "pega-tudo" se nenhuma das anteriores for satisfeita.

Sintaxe:

```
if (condição1)
{
    // Bloco 1
}
else if (condição2)
{
    // Bloco 2
}
else
{
    // Bloco 3 (opcional)
}
```

Exemplo:

```CSHARP
int numero = 0;

if (numero > 0)
{
    Console.WriteLine("O número é positivo.");
}
else if (numero < 0)
{
    Console.WriteLine("O número é negativo.");
}
else
{
    Console.WriteLine("O número é zero.");
}
```

## Variações de Sintaxe e Boas Práticas

### 

Omissão de Chaves (`{}`)

Em C#, se o bloco de código dentro de uma instrução `if`, `else if` ou `else` contém apenas uma única linha de comando, as chaves `{}` são opcionais.

Exemplo:

```CSHARP
int temperatura = 30;

if (temperatura > 25)
    Console.WriteLine("Está calor.");
else
    Console.WriteLine("Não está calor.");
```

Warning:

Cuidado com a omissão de chaves!

Embora a sintaxe seja permitida, ela é uma fonte comum de bugs. Se você adicionar uma segunda linha de código ao `if` ou `else` sem adicionar as chaves, apenas a primeira linha será condicional. A segunda linha será executada incondicionalmente, o que pode levar a um comportamento inesperado.

Exemplo de Bug:

```CSHARP
bool usuarioLogado = false;

if (usuarioLogado)
    Console.WriteLine("Bem-vindo!");
    RenderizarPainelDeControle(); // Esta linha será executada SEMPRE, mesmo se o usuário não estiver logado!
```

Boa Prática: Para evitar erros e melhorar a legibilidade e a manutenção do código, é altamente recomendável sempre usar chaves, mesmo para blocos de uma única linha.

```CSHARP
// Forma segura e recomendada
if (usuarioLogado)
{
    Console.WriteLine("Bem-vindo!");
}
```

## 

A Instrução `switch`

A instrução `switch` é uma alternativa à estrutura `if-else if-else`, ideal para quando você precisa comparar uma única variável contra uma lista de valores constantes.

* `case`: Define um valor a ser comparado com a variável do `switch`.

* `break`: É obrigatório ao final de cada `case` para sair do `switch` e impedir a execução do próximo `case` (fall-through).

* `default`: É opcional e funciona como o `else` final, sendo executado se nenhum `case` corresponder.

Exemplo:

```CSHARP
int diaDaSemana = 3;
string nomeDoDia;

switch (diaDaSemana)
{
    case 1:
        nomeDoDia = "Domingo";
        break;
    case 2:
        nomeDoDia = "Segunda-feira";
        break;
    case 3:
        nomeDoDia = "Terça-feira";
        break;
    // ... outros casos
    default:
        nomeDoDia = "Dia inválido";
        break;
}

Console.WriteLine(nomeDoDia); // Saída: Terça-feira
```

## 

Expressões `switch` (C# 8.0 e superior)

Versões mais recentes do C# introduziram a expressão `switch`, uma forma mais moderna e concisa que é especialmente útil para atribuir um valor a uma variável com base em uma condição.

* É uma expressão, o que significa que ela retorna um valor.

* Usa a sintaxe `=>` (lambda).

* Não precisa de `case` ou `break`.

* Usa o descarte (`_`) para o caso `default`.

* Suporta pattern matching avançado.

Exemplo:

```CSHARP
int diaDaSemana = 3;

string nomeDoDia = diaDaSemana switch
{
    1 => "Domingo",
    2 => "Segunda-feira",
    3 => "Terça-feira",
    4 => "Quarta-feira",
    5 => "Quinta-feira",
    6 => "Sexta-feira",
    7 => "Sábado",
    _ => "Dia inválido" // Caso default
};

Console.WriteLine(nomeDoDia); // Saída: Terça-feira
```

### 

Quando Usar `if` vs. `switch`

* Use `if-else if`: Para condições complexas, comparações de intervalos (ex: `idade > 18 && idade < 60`) ou quando múltiplas variáveis estão envolvidas.

* Use `switch`: Para comparar uma única variável contra um conjunto de valores constantes e distintos. A expressão `switch` é a abordagem moderna e preferida quando disponível.



# Laço de Repetição for

O laço `for` em C# é uma estrutura de controle de fluxo que permite executar um bloco de código repetidamente. É ideal para situações em que o número de iterações é conhecido antes do início do loop.

A estrutura do `for` é composta por três partes principais, separadas por ponto e vírgula, que controlam a execução do laço:

1. Inicializador (`initializer`): Executado apenas uma vez, no início do laço. Geralmente, é aqui que uma variável de controle do laço é declarada e inicializada.

2. Condição (`condition`): Avaliada antes de cada iteração. Se a condição for `true`, o bloco de código dentro do laço é executado. Se for `false`, o laço é encerrado.

3. Iterador (`iterator`): Executado ao final de cada iteração. Normalmente, é usado para incrementar ou decrementar a variável de controle do laço.

## Sintaxe

A sintaxe básica do laço `for` é a seguinte:

```CSHARP
for (inicializador; condição; iterador)
{
    // Bloco de código a ser executado
}
```

### Exemplo Prático

O exemplo mais comum é iterar um número fixo de vezes. O código abaixo imprime os números de 0 a 9 no console.

```CSHARP
// Imprime os números de 0 a 9
for (int i = 0; i < 10; i++)
{
    Console.WriteLine($"O valor de i é: {i}");
}
```

Análise do Exemplo:

* `int i = 0;`: A variável `i` é declarada e inicializada com `0`. Isso acontece apenas uma vez.

* `i < 10;`: Antes de cada iteração, o programa verifica se `i` é menor que `10`.

* `i++`: Ao final de cada iteração, o valor de `i` é incrementado em 1.

* `Console.WriteLine(...)`: Este é o corpo do laço, que é executado enquanto a condição `i < 10` for verdadeira.

## Casos de Uso e Variações

### Laço Infinito

É possível criar um laço infinito omitindo todas as três partes da declaração `for`. Nesses casos, é preciso ter um mecanismo de saída dentro do corpo do laço, como a instrução `break`.

```CSHARP
for (;;)
{
    Console.WriteLine("Este é um laço infinito! Pressione 's' para sair.");
    if (Console.ReadKey().KeyChar == 's')
    {
        break; // Encerra o laço
    }
    Console.WriteLine();
}
```

### Múltiplas Variáveis

Você pode inicializar e iterar múltiplas variáveis dentro de um laço `for`.

```CSHARP
for (int i = 0, j = 10; i <= 10; i++, j--)
{
    Console.WriteLine($"i = {i}, j = {j}");
}
```

### Omitindo Partes

Qualquer uma das partes do `for` (inicializador, condição ou iterador) pode ser omitida, desde que a lógica seja controlada de outra forma.

```CSHARP
int i = 0;
for (; i < 5; )
{
    Console.WriteLine(i);
    i++; // O iterador é movido para dentro do corpo do laço
}
```

O laço `for` é uma ferramenta poderosa e flexível para controlar a repetição de tarefas em seus programas C#.



# Laço de Repetição while

O laço `while` em C# é uma estrutura de controle que executa um bloco de código repetidamente enquanto uma determinada condição booleana for `true`. Diferente do laço `for`, o `while` é ideal para situações em que o número de iterações não é conhecido de antemão.

A principal característica do `while` é que a condição é testada antes da execução do bloco de código. Se a condição for `false` na primeira verificação, o corpo do laço nunca será executado.

## Sintaxe

A sintaxe do laço `while` é simples e direta:

```CSHARP
while (condição)
{
    // Bloco de código a ser executado
}
```

* `condição`: Uma expressão booleana (`true` ou `false`). O laço continua enquanto esta expressão for `true`.

### Exemplo Prático

Vamos supor que queremos ler a entrada do usuário até que ele digite a palavra "sair".

```CSHARP
string entrada = "";
while (entrada.ToLower() != "sair")
{
    Console.Write("Digite algo (ou 'sair' para terminar): ");
    entrada = Console.ReadLine();
    Console.WriteLine($"Você digitou: {entrada}");
}

Console.WriteLine("Programa encerrado.");
```

Análise do Exemplo:

1. A variável `entrada` é inicializada como uma string vazia.

2. A condição `entrada.ToLower() != "sair"` é verificada. Na primeira vez, `"" != "sair"` é `true`, então o laço começa.

3. Dentro do laço, o programa solicita a entrada do usuário e a armazena na variável `entrada`.

4. O laço se repete, e a condição é verificada novamente com o novo valor de `entrada`.

5. Quando o usuário finalmente digita "sair", a condição se torna `false`, e o laço é encerrado.

## Cuidado com Laços Infinitos

Um erro comum ao usar o `while` é criar um laço infinito. Isso acontece se a condição de parada nunca for alcançada. É crucial garantir que alguma variável dentro da condição seja modificada no corpo do laço para que, em algum momento, a condição se torne `false`.

Exemplo de laço infinito (EVITAR):

```CSHARP
int i = 0;
while (i < 10)
{
    // Erro: a variável 'i' nunca é incrementada.
    // Este laço executará para sempre.
    Console.WriteLine("Isso é um laço infinito!");
}
```

Para corrigir, basta adicionar o iterador:

```CSHARP
int i = 0;
while (i < 10)
{
    Console.WriteLine(i);
    i++; // Correção: garante que o laço terminará
}
```

O laço `while` é fundamental para algoritmos onde a repetição depende de um estado que muda durante a execução, como processamento de dados, interação com o usuário ou espera por um evento.



# Laço de Repetição do-while

O laço `do-while` é uma variação do laço `while`. A principal e mais importante diferença é que o `do-while` garante que o bloco de código seja executado pelo menos uma vez.

Isso ocorre porque a condição booleana é verificada ao final de cada iteração, e não no início.

## Sintaxe

A sintaxe do `do-while` reflete essa característica: o bloco `do` vem antes da verificação `while`.

```CSHARP
do
{
    // Bloco de código a ser executado
} while (condição);
```

* `do { ... }`: O bloco de código que será executado.

* `while (condição)`: A expressão booleana que é avaliada no final de cada iteração. Se for `true`, o laço continua; se for `false`, ele termina. Note o ponto e vírgula obrigatório no final.

### Exemplo Prático

O `do-while` é especialmente útil para menus de opções ou para validar a entrada do usuário, onde você precisa executar a ação (mostrar o menu, pedir a entrada) pelo menos uma vez.

Neste exemplo, o programa pede ao usuário para inserir um número entre 1 e 10. O laço continuará até que uma entrada válida seja fornecida.

```CSHARP
int numero;
do
{
    Console.Write("Digite um número entre 1 e 10: ");
    string entrada = Console.ReadLine();
    // Tenta converter a entrada para um inteiro.
    // int.TryParse retorna true se a conversão for bem-sucedida.
    int.TryParse(entrada, out numero);

    if (numero < 1 || numero > 10)
    {
        Console.WriteLine("Entrada inválida. Tente novamente.");
    }

} while (numero < 1 || numero > 10);

Console.WriteLine($"Ótimo! Você digitou o número válido: {numero}");
```

Análise do Exemplo:

1. O bloco `do` é executado imediatamente. O programa solicita um número sem qualquer verificação prévia.

2. A entrada do usuário é lida e o programa tenta convertê-la para um inteiro.

3. Ao final do bloco, a condição `while (numero < 1 || numero > 10)` é verificada.

4. Se o número estiver fora do intervalo desejado (ou se `TryParse` falhar, deixando `numero` como `0`), a condição será `true`, e o laço se repetirá.

5. O laço só termina quando o usuário digita um número válido entre 1 e 10.

## 

`while` vs. `do-while`: Qual Usar?

* Use `while` quando você não tem certeza se o laço precisa ser executado. A execução depende inteiramente da condição inicial. * Exemplo: Processar itens em uma lista. Se a lista estiver vazia, o laço não executa.

* Use `do-while` quando você precisa que o corpo do laço seja executado pelo menos uma vez, independentemente da condição. * Exemplo: Apresentar um menu de opções ao usuário. O menu deve ser exibido antes que o usuário possa fazer uma escolha.



# Funções (Métodos com Retorno)

Em programação, uma "função" é um bloco de código reutilizável que executa uma tarefa e retorna um valor. Em C#, o termo técnico é método com tipo de retorno. A principal finalidade de uma função é processar dados de entrada e produzir um resultado, sem (idealmente) causar efeitos colaterais em outras partes do programa.

## Declaração

A sintaxe para declarar um método com retorno é:

```CSHARP
[modificador_de_acesso] static [tipo_de_retorno] [NomeDaFuncao]([parametros])
{
    // Corpo da função
    return [valor_a_retornar];
}
```

* `[tipo_de_retorno]`: O tipo de dado que a função irá retornar (`int`, `string`, `bool`, ou um tipo complexo). Não pode ser `void`.

* `return`: A palavra-chave que envia o resultado de volta e encerra a função. O valor retornado deve ser compatível com o `tipo_de_retorno`.

### Exemplo: Função Pura

Uma função "pura" é aquela cujo resultado depende exclusivamente de seus parâmetros de entrada, sem interagir com ou modificar estados externos. Elas são previsíveis e fáceis de testar.

```CSHARP
// Função pura que calcula o preço com desconto
public static decimal CalcularPrecoFinal(decimal precoOriginal, decimal percentualDesconto)
{
    decimal valorDesconto = precoOriginal * (percentualDesconto / 100);
    return precoOriginal - valorDesconto;
}

// Uso
decimal preco = CalcularPrecoFinal(150.0m, 10.0m); // Retorna 135.0m
```

## Parâmetros Avançados

### 

Passagem por Referência: `ref` vs. `out`

Por padrão, os tipos de valor (como `int`, `double`, `bool`) são passados para métodos por valor (pass-by-value). Isso significa que o método recebe uma cópia da variável, e qualquer alteração dentro do método não afeta a variável original.

As palavras-chave `ref` e `out` mudam esse comportamento, permitindo passar a variável por referência (pass-by-reference). O método recebe uma referência à localização da variável na memória, permitindo que ele modifique o valor original. Embora pareçam semelhantes, eles têm propósitos e regras diferentes.

#### 

A Palavra-Chave `ref`

Usa-se `ref` quando você quer que um método leia e potencialmente modifique uma variável existente.

Contrato do `ref`:

1. A variável deve ser inicializada pelo código que chama o método antes de ser passada.

2. O método pode ler o valor do parâmetro antes de modificá-lo.

Caso de Uso: Ideal para quando uma função precisa alterar o estado de uma variável de entrada. Pense em um fluxo de dados bidirecional: o valor entra no método e pode sair modificado.

```CSHARP
// Função que adiciona juros a um saldo existente
public static void AdicionarJuros(ref decimal saldo, decimal taxaDeJuros)
{
    decimal juros = saldo * taxaDeJuros;
    saldo += juros; // Modifica a variável original
}

// Uso
decimal minhaPoupanca = 1000m;
AdicionarJuros(ref minhaPoupanca, 0.05m);
Console.WriteLine(minhaPoupanca); // Saída: 1050
```

#### 

A Palavra-Chave `out`

Usa-se `out` quando o propósito principal de um método é retornar múltiplos valores ou quando uma operação de "tentativa" (como `TryParse`) precisa retornar um status de sucesso (`bool`) e o resultado da operação.

Contrato do `out`:

1. A variável passada como `out` não precisa ser inicializada antes da chamada.

2. O método é obrigado a atribuir um valor ao parâmetro `out` antes de retornar.

3. O método não pode ler o valor do parâmetro `out` antes de atribuir um valor a ele.

Caso de Uso: Perfeito para quando uma função precisa "produzir" um valor sem ter um valor de entrada. O fluxo de dados é unidirecional: o valor apenas sai do método.

```CSHARP
// Função que tenta dividir e retorna o quociente e o resto
public static bool TentarDividir(int dividendo, int divisor, out int quociente, out int resto)
{
    quociente = 0;
    resto = 0;
    if (divisor == 0)
    {
        return false; // Falha na operação
    }

    quociente = dividendo / divisor;
    resto = dividendo % divisor;
    return true; // Sucesso
}

// Uso
if (TentarDividir(10, 3, out int q, out int r))
{
    Console.WriteLine($"Quociente: {q}, Resto: {r}"); // Saída: Quociente: 3, Resto: 1
}
```

### 

Tabela Comparativa: `ref` vs. `out`

| Característica |`ref` |`out` |
--------------------------------
| Propósito |Modificar uma variável existente. |Retornar um ou mais valores. |
| Inicialização |Obrigatória antes da chamada. |Não necessária antes da chamada. |
| Atribuição no Método |Opcional. |Obrigatória antes do retorno. |
| Fluxo de Dados |Bidirecional (Entrada e Saída). |Unidirecional (Apenas Saída). |

### Parâmetros Opcionais e Argumentos Nomeados

Você pode atribuir valores padrão aos parâmetros, tornando-os opcionais. Para evitar ambiguidade, você pode usar argumentos nomeados na chamada da função.

```CSHARP
// 'logCompleto' é um parâmetro opcional
public static void RegistrarLog(string mensagem, bool logCompleto = false)
{
    string timestamp = DateTime.Now.ToString();
    if (logCompleto)
    {
        Console.WriteLine($"[LOG COMPLETO - {timestamp}] {mensagem}");
    }
    else
    {
        Console.WriteLine($"[LOG - {timestamp}] {mensagem}");
    }
}

// Uso
RegistrarLog("Iniciando processo..."); // Usa o valor padrão (false)
RegistrarLog("Erro crítico!", true); // Passa o valor explicitamente
RegistrarLog(logCompleto: true, mensagem: "Ordem invertida com argumentos nomeados.");
```

## Funções Recursivas

Uma função recursiva é aquela que chama a si mesma. É uma técnica poderosa para resolver problemas que podem ser divididos em subproblemas menores e idênticos. É crucial ter uma condição de parada para evitar um loop infinito (stack overflow).

```CSHARP
// Calcula o fatorial de um número usando recursão
public static int Fatorial(int n)
{
    // Condição de parada
    if (n == 0)
    {
        return 1;
    }
    
    // Chamada recursiva
    return n * Fatorial(n - 1);
}

// Uso
int resultado = Fatorial(5); // 5 * 4 * 3 * 2 * 1 = 120
```

## 

Expression-Bodied Members (`=>`)

Para funções que contêm apenas uma única instrução `return`, você pode usar uma sintaxe mais concisa com `=>`.

```CSHARP
// Função de soma reescrita
public static int Somar(int a, int b) => a + b;

// Função Fatorial reescrita com expressão condicional ternária
public static int Fatorial(int n) => n == 0 ? 1 : n * Fatorial(n - 1);
```



# Procedimentos

Em C#, o termo "procedimento" é mais conhecido como um método que não retorna nenhum valor, indicado pela palavra-chave `void`. O propósito principal de um método `void` é executar uma ação e causar um efeito colateral (side effect), como modificar o estado de uma variável externa, imprimir algo no console, ou interagir com um banco de dados.

A principal característica é que eles executam uma tarefa, mas não retornam um valor para o código que os chamou.

## Declaração

A sintaxe para declarar um método `void` é a seguinte:

```CSHARP
[modificador_de_acesso] static void [NomeDoMetodo]([parametros])
{
    // Corpo do método: código a ser executado
}
```

* `[modificador_de_acesso]`: Define a visibilidade (`public`, `private`, etc.).

* `static`: Indica que o método pertence à própria classe e pode ser chamado sem criar uma instância.

* `void`: Palavra-chave que especifica que o método não retorna valor.

* `[NomeDoMetodo]`: O nome do método, que deve ser um verbo ou frase verbal que descreva a ação (ex: `CalcularImpostos`, `ImprimirRelatorio`).

* `[parametros]`: A lista de dados que o método recebe para trabalhar.

### Exemplo: Método com Parâmetros

Métodos `void` frequentemente usam parâmetros para direcionar sua ação.

```CSHARP
// Declaração de um método que saúda um usuário
public static void SaudarUsuario(string nome)
{
    Console.WriteLine($"Olá, {nome}! Bem-vindo ao sistema.");
}

// Chamada ao método
SaudarUsuario("Ana"); // Saída: Olá, Ana! Bem-vindo ao sistema.
```

## 

Modificando Dados Externos com `ref`

Mesmo sem retornar um valor, um método `void` pode modificar variáveis que foram passadas a ele por referência usando a palavra-chave `ref`. Isso permite que o método altere o valor da variável original.

Tip:

Atenção: A variável passada como `ref` deve ser inicializada antes da chamada do método.

```CSHARP
// Método que troca os valores de duas variáveis
public static void TrocarValores(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// Uso
int x = 5;
int y = 10;
Console.WriteLine($"Antes: x = {x}, y = {y}");

TrocarValores(ref x, ref y);

Console.WriteLine($"Depois: x = {x}, y = {y}"); // Saída: Depois: x = 10, y = 5
```

## 

A Instrução `return` em Métodos `void`

Embora métodos `void` não retornem um valor, você pode usar a instrução `return;` para encerrar a execução do método prematuramente. Isso é uma técnica de controle de fluxo valiosa, conhecida como early exit.

```CSHARP
public static void ProcessarPedido(int quantidade)
{
    if (quantidade <= 0)
    {
        Console.WriteLine("Erro: A quantidade deve ser positiva.");
        return; // Sai do método imediatamente
    }

    if (quantidade > 100)
    {
        Console.WriteLine("Erro: Pedido excede o limite de estoque.");
        return; // Outro ponto de saída
    }

    // Este código só será executado se as validações passarem
    Console.WriteLine($"Pedido de {quantidade} unidades processado com sucesso.");
}
```

Note:

Em C#, tanto os métodos que retornam valor (funções) quanto os que não retornam (procedimentos `void`) são chamados genericamente de métodos. A escolha entre um método `void` e um com retorno depende da sua intenção: você quer realizar uma ação (`void`) ou obter um valor (com retorno)?



# Structs

Tipos de dados estruturado, servem apenas para definir a estrutura

Sendo tipo de valor

Armazenam apenas outros tipos de dados, e é definido pela palavra:

```CSHARP
struct NomeDaEstrutura{
    //Aqui vai as propriedades da estrutura
}
```

Composto por metodos e propriedades

Nome sempre com letras maiuscula

* Igual para propriedades e métodos

Criado apartir da palavra `new`

* Neste momento que temos os valores iniciais das propriedades

Exemplo:

```CSHARP
struct Pessoa{
    public string nome;
}
Pessoa pessoa = new Pessoa();
pessoa.nome = "João";
Console.WriteLine(pessoa.nome);
```

Também podemos criar um construtor padrão para inicializar o objeto:

```CSHARP
struct Pessoa{
    public string nome;
    public int idade;
    public Pessoa(string nome){
        this.nome = nome;
    }
}
Pessoa pessoa = new Pessoa("João");
Console.WriteLine(pessoa.nome);
```

E assim criamos metodos dentro do struct:

```CSHARP
struct Pessoa{
    public string nome;
    public int idade;
    public void MostrarDados(){
        Console.WriteLine($"Nome: {nome} Idade: {idade}");
    }
}
Pessoa pessoa = new Pessoa("João", 20);
pessoa.MostrarDados();
```

Podemos também usar o método `ToString()` para retornar uma string com os dados do objeto:

```CSHARP
struct Pessoa{
    public string nome;
    public int idade;
    public override string ToString(){
        return $"Nome: {nome} Idade: {idade}";
    }
}
Pessoa pessoa = new Pessoa("João", 20);
Console.WriteLine(pessoa.ToString());
```



# Enums

Um Enum serve para fornecer uma melhor visualização do código e também facilitar a leitura e entendimento de um código.

Usados em listas curtas e Usados em dados fixos:

* Hard Coded

Note:

No .NET a conveção é usar o PascalCase e começar com a letra maiúscula E sempre

Exemplo:

```CSHARP
class Program {
    enum StatusPedido {
        AguardandoPagamento,
        Pago,
        Cancelado
    }
    
    static void Main(string[] args) 
    {
        StatusPedido statusAtual = StatusPedido.AguardandoPagamento;
        Console.WriteLine(statusAtual); // Aguardando Pagamento
    }
}
```



# Stack vs. Heap: Gerenciamento de Memória em C#

Todo programa .NET utiliza duas áreas de memória fundamentais para sua execução: a Stack (Pilha) e a Heap (Monte). Compreender como elas funcionam e o que é armazenado em cada uma é crucial para escrever código eficiente e prever seu comportamento, especialmente no que diz respeito a performance e ciclo de vida das variáveis.

## A Stack (Pilha)

A Stack é uma estrutura de dados do tipo LIFO (Last-In, First-Out), ou seja, o último item a entrar é o primeiro a sair. É uma área de memória extremamente rápida e eficiente, usada para gerenciar o fluxo de execução do programa.

O que é armazenado na Stack?

1. Tipos de Valor (`Value Types`): Variáveis locais de tipos como `int`, `double`, `bool`, `char`, e `structs` são armazenadas diretamente na Stack.

2. Parâmetros de Métodos: Os valores passados como argumentos para um método são colocados na Stack.

3. Referências a Objetos: Quando você cria um objeto (um tipo de referência), o objeto em si vai para a Heap, mas a variável que aponta para ele (a referência/ponteiro) é armazenada na Stack.

4. Controle de Execução: A Stack gerencia qual método está em execução no momento. Cada chamada de método cria um "quadro" (stack frame) que contém suas variáveis locais e parâmetros. Quando o método termina, seu quadro é removido da pilha.

Características Principais:

* Velocidade: Alocação e desalocação são instantâneas (apenas o ponteiro da Stack é movido).

* Tamanho Fixo: A memória para um quadro de pilha é alocada no início da chamada do método.

* Gerenciamento Automático: A memória é liberada automaticamente quando a variável sai de escopo (o método termina). O Garbage Collector não atua na Stack.

* Limitação de Tamanho: A Stack tem um tamanho limitado. Chamadas recursivas infinitas podem causar um `StackOverflowException`.

### Diagrama da Stack

```TEXT
// Código
void MetodoA() {
    int x = 10;
    MetodoB();
}

void MetodoB() {
    bool y = true;
}
```

```TEXT
      STACK (Durante a execução de MetodoB)
+--------------------+
| Frame do MetodoB:  |  <-- Topo da Stack
|   y = true         |
+--------------------+
| Frame do MetodoA:  |
|   x = 10           |
+--------------------+
| ... (outros frames) ...
+--------------------+
```

## A Heap (Monte)

A Heap é uma área de memória maior e mais flexível, usada para alocação dinâmica. É aqui que os objetos (instâncias de classes) residem.

O que é armazenado na Heap?

1. Instâncias de Tipos de Referência (`Reference Types`): Qualquer objeto criado com a palavra-chave `new` (como instâncias de `class`, `arrays`, `string`, `delegates`) é alocado na Heap.

Características Principais:

* Alocação Dinâmica: Objetos podem ser alocados e desalocados em qualquer ordem.

* Velocidade: A alocação na Heap é mais lenta que na Stack, pois o sistema precisa encontrar um bloco de memória livre que seja grande o suficiente.

* Gerenciamento pelo Garbage Collector (GC): A memória na Heap não é liberada automaticamente. O GC é um processo que roda em segundo plano, identifica objetos na Heap que não são mais referenciados por nenhuma variável na Stack e libera o espaço que eles ocupavam.

* Tamanho Maior: A Heap é muito maior que a Stack, limitada apenas pela memória virtual disponível no sistema.

## Exemplo Combinado: Stack e Heap em Ação

Vamos analisar um exemplo que usa ambos os tipos e visualizar a memória.

```CSHARP
public class Estudante // Reference Type
{
    public int Matricula { get; set; }
}

public void Executar()
{
    int idade = 25; // Value Type
    Estudante aluno = new Estudante(); // Reference Type
    aluno.Matricula = 101;
}
```

### Diagrama da Memória Durante a Execução

```TEXT
          STACK                                  HEAP
+-------------------------+          +----------------------------+
| Frame do método Executar: |
|                         |
|   idade = 25            |          // Objeto alocado na Heap
|                         |
|   aluno (ref: 0xA1B2)   |--------->+ Objeto Estudante (0xA1B2)  |
|                         |          |   - Matricula: 101         |
+-------------------------+          +----------------------------+
| ... (outros frames) ... |
+-------------------------+
```

Análise:

1. A variável `idade` (tipo `int`) é um tipo de valor, então seu dado (`25`) é armazenado diretamente na Stack.

2. A variável `aluno` é uma referência. Ela também fica na Stack, mas seu valor não é o objeto em si, e sim o endereço (`0xA1B2`) onde o objeto `Estudante` foi alocado na Heap.

3. O objeto `Estudante` real, com seu campo `Matricula`, reside na Heap.

## Tabela Comparativa

| Característica |Stack (Pilha) |Heap (Monte) |
-----------------------------------------------
| Velocidade |Muito Rápida |Mais Lenta |
| Gerenciamento |Automático (LIFO) |Garbage Collector (GC) |
| Armazena |Tipos de Valor, Referências |Instâncias de Tipos de Referência |
| Ciclo de Vida |Curto (limitado ao escopo do método) |Longo (até não ser mais referenciado) |
| Tamanho |Pequeno e Fixo (por thread) |Grande e Dinâmico |



# Tipos de Valor (Value Types)

No C#, todo tipo é classificado como um tipo de valor ou um tipo de referência. Entender a diferença é fundamental para prever o comportamento do seu código e gerenciar a memória de forma eficiente.

Tipos de valor são aqueles cujas variáveis contêm diretamente o seu dado. A variável e o valor são uma coisa só.

## Como Funciona a Memória?

Tipos de valor são, na maioria das vezes, armazenados em uma área da memória chamada Stack (Pilha). A Stack é uma estrutura de dados altamente eficiente, do tipo LIFO (Last-In, First-Out), que gerencia a memória de forma muito rápida. Quando uma variável de tipo de valor é declarada dentro de um método, um espaço é alocado na Stack para armazenar seu valor.

### Diagrama: Variável na Stack

Imagine a Stack como uma pilha de caixas. Cada vez que você declara uma variável, uma nova caixa é colocada no topo, contendo o valor.

```TEXT
      STACK
+------------------+
|                  |  <-- Topo da Stack
+------------------+
|   idade = 30     |
+------------------+
|   saldo = 150.75 |
+------------------+
| ...outras vars...|
+------------------+
```

## Comportamento na Atribuição

Esta é a característica mais importante dos tipos de valor. Quando você atribui uma variável de tipo de valor a outra, o valor é copiado. O resultado são duas variáveis completamente independentes, cada uma com sua própria cópia do dado.

### Exemplo de Código

```CSHARP
// 1. 'a' é criado na Stack com o valor 10.
int a = 10;

// 2. O valor de 'a' é COPIADO para a nova variável 'b'.
int b = a;

Console.WriteLine($"a: {a}, b: {b}"); // Saída: a: 10, b: 10

// 3. Modificamos apenas 'b'.
b = 20;

// 4. A variável 'a' permanece inalterada, pois elas são independentes.
Console.WriteLine($"Após a mudança, a: {a}, b: {b}"); // Saída: a: 10, b: 20
```

### Diagrama: Cópia de Valor

Após a atribuição `int b = a;`, a Stack fica assim:

```TEXT
      STACK
+------------------+
|                  |  <-- Topo da Stack
+------------------+
|      b = 10      |  (Cópia independente)
+------------------+
|      a = 10      |
+------------------+
| ...outras vars...|
+------------------+
```

Quando `b` é alterado para `20`, apenas a sua "caixa" na Stack é afetada.

## O Garbage Collector e a Stack

O Garbage Collector (Coletor de Lixo) do .NET é responsável por limpar a memória na Heap, mas ele não gerencia a Stack. A memória da Stack é liberada automaticamente quando uma variável sai de escopo (por exemplo, quando o método onde ela foi declarada termina sua execução). Esse gerenciamento automático é o que torna a alocação e desalocação na Stack extremamente rápidas.

## Exemplos de Tipos de Valor

* Tipos numéricos primitivos: `int`, `double`, `float`, `decimal`, `long`, `byte`, etc.

* `bool`: O tipo booleano `true`/`false`.

* `char`: Um único caractere Unicode.

* `struct`: Estruturas definidas pelo usuário. São a forma de criar seus próprios tipos de valor complexos.

* `enum`: Enumerações, que representam um conjunto de constantes nomeadas.



# Tipos de Referência (Reference Types)

Tipos de referência são um dos dois pilares fundamentais do sistema de tipos do C#. Diferente dos tipos de valor, uma variável de tipo de referência não armazena o dado diretamente. Em vez disso, ela armazena um endereço de memória (uma referência ou ponteiro) que aponta para o local onde o objeto real está armazenado. Esse local é uma área da memória chamada Heap.

## Como Funciona a Memória?

A gestão da memória para tipos de referência envolve duas áreas:

1. Stack: A variável em si é criada na Stack. Ela é leve e contém apenas o endereço de memória do objeto.

2. Heap: O objeto real, com todos os seus dados, é alocado na Heap. A Heap é uma área de memória maior e mais flexível, gerenciada por um processo chamado Garbage Collector (Coletor de Lixo).

### Diagrama: Variável e Objeto na Memória

Quando você cria um objeto, a variável na Stack aponta para o objeto na Heap.

```TEXT
      STACK                         HEAP
+------------------+      +-------------------------+
|                  |      |                         |
|  minhaConta      |----->|  Objeto Conta           |
| (Endereço: 0x2A) |      |  (Endereço: 0x2A)       |
|                  |      |  - Saldo: 1000          |
+------------------+      |  - Titular: "Ana"       |
|                  |      |                         |
+------------------+      +-------------------------+
```

## Comportamento na Atribuição

Esta é a diferença mais crucial. Quando você atribui uma variável de referência a outra, você não está copiando o objeto, mas sim copiando o endereço de memória.

O resultado é que ambas as variáveis passam a apontar para o mesmo objeto na Heap. Qualquer modificação feita através de uma variável será visível através da outra.

### Exemplo de Código

```CSHARP
// Vamos supor que temos uma classe simples
public class ContaBancaria
{
    public decimal Saldo { get; set; }
}

// 1. Criamos uma instância. 'contaA' aponta para um novo objeto.
var contaA = new ContaBancaria { Saldo = 1000 };

// 2. Copiamos a referência. Agora 'contaB' aponta para o MESMO objeto que 'contaA'.
var contaB = contaA;

Console.WriteLine($"Saldo (contaA): {contaA.Saldo}"); // Saída: 1000
Console.WriteLine($"Saldo (contaB): {contaB.Saldo}"); // Saída: 1000

// 3. Modificamos o objeto usando 'contaB'.
contaB.Saldo = 500;

// 4. A mudança é refletida em 'contaA', pois ambas apontam para o mesmo lugar.
Console.WriteLine($"Saldo (contaA) após mudança: {contaA.Saldo}"); // Saída: 500
Console.WriteLine($"Saldo (contaB) após mudança: {contaB.Saldo}"); // Saída: 500
```

### Diagrama: Cópia de Referência

Após `var contaB = contaA;`, a situação da memória é a seguinte:

```TEXT
      STACK                         HEAP
+------------------+      +-------------------------+
|                  |      |                         |
|      contaA      |----->|  Objeto Conta           |
| (Endereço: 0x5B) |      |  (Endereço: 0x5B)       |
+------------------+      |  - Saldo: 1000          |
|                  |      |                         |
|      contaB      |----->|                         |
| (Endereço: 0x5B) |      +-------------------------+
|                  |
+------------------+
```

## O Garbage Collector (GC)

Como a Heap é gerenciada dinamicamente, precisamos de um mecanismo para limpar objetos que não são mais necessários. É aqui que entra o Garbage Collector.

O GC periodicamente verifica a Heap em busca de objetos que não possuem mais nenhuma referência apontando para eles. Quando encontra esses objetos "órfãos", ele os remove e libera a memória para que possa ser reutilizada.

Se no nosso exemplo fizermos `contaA = null;` e `contaB = null;`, o objeto `ContaBancaria` na Heap se tornaria elegível para a coleta de lixo.

## Exemplos de Tipos de Referência

* `class`: O exemplo mais comum. Todas as classes que você cria são tipos de referência.

* `object`: O tipo base para todos os outros tipos no .NET.

* `string`: Embora às vezes se comporte como um tipo de valor (devido à sua imutabilidade), `string` é um tipo de referência.

* Arrays: Vetores e matrizes (ex: `int[]`, `string[]`) são sempre tipos de referência.

* Delegates e Interfaces.



# GUIDs

Imagine que você está em um evento muito grande, com milhares de pessoas. Para garantir que cada pessoa seja facilmente identificada e que não haja confusão, a organização decide dar a cada participante um crachá com um número de identificação completamente único. Não importa o quão grande o evento seja, ou mesmo se houver outros eventos semelhantes em outros lugares do mundo, o seu número de crachá será exclusivo.

No mundo da programação, especialmente em sistemas complexos e distribuídos, precisamos de algo parecido: identificadores que sejam praticamente garantidos como únicos, não apenas dentro do seu programa, mas globalmente. É aí que entram os GUIDs.

## O que são GUIDs?

GUID é a sigla para Globally Unique IDentifier (Identificador Globalmente Único). No contexto do C# e de muitas outras tecnologias, um GUID é um número de 128 bits que é gerado de uma forma que o torna extremamente improvável de ser duplicado.

Vamos desmistificar alguns termos:

* Bit: A menor unidade de informação em um computador, representando um 0 ou um 1.

* Byte: Um grupo de 8 bits.

* Integer (Número Inteiro): Um número sem casas decimais.

* 128-bit integer (16 bytes): Isso significa que um GUID é um número inteiro muito grande, composto por 128 "zeros e uns". Como cada byte tem 8 bits, 128 bits equivalem a 16 bytes (128 / 8 = 16). Essa quantidade massiva de bits permite uma gama gigantesca de combinações, tornando a chance de dois GUIDs serem idênticos por acaso praticamente nula.

Um GUID é frequentemente representado como uma sequência hexadecimal (base 16) de 32 dígitos, agrupados em blocos separados por hífens, como este exemplo: `044e69f7-fe93-4e98-ae0d-f650b37f31ff`.

## Como Gerar um GUID em C#

Em C#, a geração de um GUID é muito simples, graças à estrutura `Guid` e ao seu método `NewGuid()`.

```CSHARP
// Declara uma variável 'id' e atribui a ela um novo GUID gerado.
// 'var' é uma palavra-chave em C# que permite ao compilador inferir o tipo da variável
// com base no valor que está sendo atribuído a ela. Neste caso, o tipo será 'Guid'.
var id = Guid.NewGuid();

// O resultado será algo assim:
// → 044e69f7-fe93-4e98-ae0d-f650b37f31ff

// 'System.Console.WriteLine()' é um método padrão em C# usado para exibir
// informações no console (a janela de texto onde seu programa é executado).
// Aqui, ele converte o GUID para uma string e o imprime.
System.Console.WriteLine("" + id);
```

## Quando Usar GUIDs?

GUIDs são extremamente úteis em diversas situações, como:

* Identificadores de Banco de Dados: Em vez de usar números sequenciais (que podem ser adivinhados ou expor informações sobre o número de registros), GUIDs fornecem identificadores únicos e imprevisíveis para registros.

* Sistemas Distribuídos: Quando você tem dados sendo criados em diferentes servidores ou locais que precisam ser sincronizados, GUIDs garantem que cada item tenha um identificador único, evitando conflitos.

* Chaves de API ou Tokens: Para gerar chaves de acesso ou tokens temporários que precisam ser únicos e difíceis de adivinhar.

* Nomes de Arquivos Temporários: Para criar nomes de arquivos que são garantidos como únicos, evitando sobrescrever arquivos existentes.

Em resumo, sempre que você precisar de um identificador que seja globalmente único e que não dependa de um sistema centralizado para garantir sua exclusividade, um GUID é uma excelente escolha.



# Interpolação de Strings

Imagine que você está escrevendo uma carta e quer incluir informações específicas, como a data, o nome do destinatário e o valor de um produto. Em vez de escrever tudo manualmente cada vez, você usa "espaços em branco" ou "marcadores" na carta e depois preenche esses espaços com as informações corretas.

No mundo da programação, a interpolação de strings é exatamente isso: a capacidade de combinar texto fixo (a "carta") com valores de variáveis (as "informações específicas") para criar uma única frase ou mensagem. Em C#, existem algumas maneiras de fazer isso, cada uma com suas vantagens.

## 

1. Concatenação de Strings (`+`)

A forma mais básica de juntar strings é usando o operador de adição (`+`). É como colar pedaços de papel com fita adesiva.

```
// Declara uma variável 'price' do tipo double (número com casas decimais).
var price = 12.2;

// Concatena a string "O preço é " com o valor da variável 'price'.
// O C# automaticamente converte o número 'price' para texto (string) para que possa ser combinado.
var texto = "O preço é " + price;

// 'Console.WriteLine()' é um comando para exibir texto na tela (no console).
Console.WriteLine(texto); // Saída: O preço é 12.2
```

Explicação:

* `string` (cadeia de caracteres): Uma sequência de caracteres (letras, números, símbolos) usada para representar texto.

* `var` (palavra-chave): Permite que o compilador C# descubra o tipo da variável automaticamente com base no valor que você atribui a ela.

* `+` (operador de concatenação): Quando usado com strings, ele as une, criando uma nova string. Se um dos lados não for uma string, o C# tenta convertê-lo para string antes de unir.

Vantagens: Simples e fácil de entender para operações básicas.
Desvantagens: Pode se tornar difícil de ler e manter quando há muitas variáveis ou quando a string resultante é muito longa. Em cenários de alta performance com muitas concatenações em loop, pode ser menos eficiente.

## 

2. Formatação de Strings (`string.Format`)

O método `string.Format` oferece uma maneira mais estruturada de construir strings. Ele usa "marcadores de posição" numerados (`{0}`, `{1}`, etc.) que são preenchidos pelos valores das variáveis que você fornece.

```
var price = 10.2;
var productName = "Notebook";

// Usa string.Format para criar uma string formatada.
// {0} será substituído pelo primeiro argumento após a string de formato (price).
// {1} será substituído pelo segundo argumento (productName).
var textoFormatado = string.Format("O preço do {1} é {0:C} apenas na promoção!", price, productName);

Console.WriteLine(textoFormatado); // Saída (exemplo, pode variar com a cultura): O preço do Notebook é R$ 10,20 apenas na promoção!
```

Explicação:

* `string.Format()` (método): Uma função que permite criar strings complexas usando um padrão e substituindo marcadores de posição por valores.

* `{0}`, `{1}` (marcadores de posição): Indicam onde os valores das variáveis serão inseridos. O número dentro das chaves corresponde à posição do argumento na lista após a string de formato (começando do 0).

* `{0:C}` (especificador de formato): O `:C` é um "especificador de formato" que indica que o número deve ser formatado como uma moeda, usando o símbolo da moeda e o número de casas decimais apropriados para a cultura atual do sistema (por exemplo, R$ 10,20 no Brasil).

Vantagens: Melhor legibilidade que a concatenação para strings complexas, permite formatação de valores (como moeda, datas).
Desvantagens: Ainda pode ser um pouco verboso e os marcadores numerados podem dificultar a leitura se houver muitos.

## 

3. Interpolação de Strings (`$""`) - A Forma Moderna

Introduzida no C# 6, a interpolação de strings é a maneira mais legível e concisa de combinar strings e variáveis. Você prefixa a string com um cifrão (`$`) e pode inserir variáveis diretamente dentro das chaves `{}`.

```
var price = 1500.00;
var productName = "Smartphone";
var discount = 0.10; // 10% de desconto

// Calcula o preço com desconto
var finalPrice = price * (1 - discount);

// Usa a interpolação de strings ($"") para criar uma mensagem clara.
// As variáveis são inseridas diretamente dentro das chaves {}.
// Também podemos usar especificadores de formato, como {finalPrice:C} para moeda.
var mensagem = $"O {productName} custa {price:C}. Com {discount:P0} de desconto, o preço final é {finalPrice:C}.";

Console.WriteLine(mensagem); // Saída (exemplo): O Smartphone custa R$ 1.500,00. Com 10% de desconto, o preço final é R$ 1.350,00.
```

Explicação:

* `$""` (string interpolada): O `$` antes das aspas duplas indica que a string é uma string interpolada.

* `{variável}` (expressão): Dentro de uma string interpolada, você pode colocar o nome de uma variável ou até mesmo uma expressão (como `price * (1 - discount)`) diretamente dentro das chaves `{}`. O C# automaticamente converte o valor para texto.

* `{discount:P0}` (especificador de formato): O `:P0` formata o número como uma porcentagem (`P`) sem casas decimais (`0`).

Vantagens: Excelente legibilidade, concisa, fácil de usar, e permite a mesma flexibilidade de formatação que `string.Format`. É a abordagem recomendada para a maioria dos casos em C# moderno.

Em resumo, a interpolação de strings (`$""`) é a ferramenta mais poderosa e amigável para combinar texto e dados em C#. Ela torna seu código mais limpo e fácil de entender, especialmente quando você está construindo mensagens complexas.



# Comparar Strings

Imagine que você tem duas caixas de brinquedos e quer saber se elas são iguais ou se uma contém um tipo específico de brinquedo. No mundo da programação, comparar strings é muito parecido: você quer verificar se dois textos são idênticos, ou se um texto contém uma parte específica de outro texto. Em C#, temos métodos dedicados para isso.

## 

`CompareTo()`: Comparação "Dicionário"

O método `CompareTo()` é como organizar palavras em um dicionário. Ele compara a string atual com outra string que você fornece, caractere por caractere, para determinar a ordem lexicográfica (a ordem em que as palavras apareceriam em um dicionário).

Como funciona:

* Ele é um método que você chama a partir de uma string (por exemplo, `minhaString.CompareTo(outraString)`).

* Ele é case-sensitive (sensível a maiúsculas e minúsculas). Isso significa que "Maçã" é diferente de "maçã".

* Ele retorna um número inteiro: * `0`: Se as strings são exatamente iguais. * Um número menor que 0: Se a string atual vem antes da string comparada na ordem do dicionário. * Um número maior que 0: Se a string atual vem depois da string comparada na ordem do dicionário.

Exemplo de Código:

```
string palavra1 = "Banana";
string palavra2 = "banana";
string palavra3 = "Abacaxi";
string palavra4 = "Banana";

// Comparação case-sensitive
int resultado1 = palavra1.CompareTo(palavra2); // "Banana" vs "banana"
Console.WriteLine($"'Banana'.CompareTo('banana') retorna: {resultado1}");
// Saída: Um número diferente de 0 (porque 'B' é diferente de 'b')

int resultado2 = palavra1.CompareTo(palavra4); // "Banana" vs "Banana"
Console.WriteLine($"'Banana'.CompareTo('Banana') retorna: {resultado2}");
// Saída: 0 (porque são idênticas)

int resultado3 = palavra1.CompareTo(palavra3); // "Banana" vs "Abacaxi"
Console.WriteLine($"'Banana'.CompareTo('Abacaxi') retorna: {resultado3}");
// Saída: Um número maior que 0 (porque 'Banana' vem depois de 'Abacaxi')
```

Termos Técnicos:

* Lexicográfico: Refere-se à ordem alfabética ou de dicionário.

* Case-sensitive (sensível a maiúsculas e minúsculas): Significa que a comparação diferencia letras maiúsculas de minúsculas.

## 

`Contains()`: Verificando a Presença

O método `Contains()` é como verificar se uma caixa de brinquedos contém um brinquedo específico. Ele verifica se uma determinada sequência de caracteres (uma "substring") está presente dentro da string atual.

Como funciona:

* Ele é um método que você chama a partir de uma string (por exemplo, `minhaFrase.Contains(palavraChave)`).

* Ele também é case-sensitive.

* Ele retorna um valor booleano: * `true`: Se a substring for encontrada. * `false`: Se a substring não for encontrada.

Exemplo de Código:

```
string frase = "O rato roeu a roupa do rei de Roma.";
string palavraChave1 = "rato";
string palavraChave2 = "Rei"; // Com 'R' maiúsculo
string palavraChave3 = "gato";

bool contem1 = frase.Contains(palavraChave1);
Console.WriteLine($"A frase contém '{palavraChave1}'? {contem1}");
// Saída: True

bool contem2 = frase.Contains(palavraChave2);
Console.WriteLine($"A frase contém '{palavraChave2}'? {contem2}");
// Saída: False (porque 'Rei' com 'R' maiúsculo não está na frase, apenas 'rei' com 'r' minúsculo)

bool contem3 = frase.Contains(palavraChave3);
Console.WriteLine($"A frase contém '{palavraChave3}'? {contem3}");
// Saída: False
```

Termos Técnicos:

* Substring: Uma parte de uma string. Por exemplo, "rato" é uma substring de "O rato roeu...".

* Booleano: Um tipo de dado que pode ter apenas dois valores: `true` (verdadeiro) ou `false` (falso).

## Equals

Tip:

Serve não somente para strings

text.Equals(text2)

## Comparação Ignorando Maiúsculas/Minúsculas (Case-Insensitive)

Muitas vezes, você não quer que a comparação seja sensível a maiúsculas e minúsculas. Para isso, você pode converter ambas as strings para o mesmo caso (tudo maiúsculo ou tudo minúsculo) antes de comparar.

Exemplo para `CompareTo()` e `Contains()`:

```
string textoOriginal = "Olá Mundo";
string textoComparar = "olá mundo";

// Para CompareTo()
// Converte ambas para minúsculas antes de comparar
bool saoIguaisIgnorandoCase = (textoOriginal.ToLower().CompareTo(textoComparar.ToLower()) == 0);
Console.WriteLine($"'Olá Mundo' e 'olá mundo' são iguais (ignorando case)? {saoIguaisIgnorandoCase}");
// Saída: True

// Para Contains()
// Converte ambas para minúsculas antes de verificar
bool contemIgnorandoCase = textoOriginal.ToLower().Contains(textoComparar.ToLower());
Console.WriteLine($"'Olá Mundo' contém 'olá mundo' (ignorando case)? {contemIgnorandoCase}");
// Saída: True
```

Termos Técnicos:

* `ToLower()` (método): Um método de string que retorna uma nova string com todos os caracteres convertidos para minúsculas.

* `ToUpper()` (método): Um método de string que retorna uma nova string com todos os caracteres convertidos para maiúsculas.

Compreender como e quando usar `CompareTo()` e `Contains()` (e como lidar com a sensibilidade a maiúsculas e minúsculas) é fundamental para manipular textos de forma eficaz em seus programas C#.



# Início e Fim de Strings

Imagine que você tem uma lista de nomes de arquivos e quer encontrar todos os arquivos que começam com "relatorio" ou que terminam com ".pdf". Em programação, para fazer esse tipo de verificação em textos (strings), usamos métodos específicos que nos dizem se uma string começa ou termina com uma determinada sequência de caracteres.

## 

`StartsWith()`: Verificando o Início

O método `StartsWith()` é como perguntar: "Esta frase começa com esta palavra?". Ele verifica se a string atual começa com a substring especificada.

Como funciona:

* Você chama `StartsWith()` a partir de uma string, passando a substring que você quer verificar como argumento.

* Ele é case-sensitive (sensível a maiúsculas e minúsculas). Isso significa que "Relatorio" é diferente de "relatorio".

* Ele retorna um valor booleano: * `true`: Se a string começa com a substring. * `false`: Se a string não começa com a substring.

Exemplo de Código:

```
string nomeArquivo = "relatorio_vendas_2024.xlsx";

bool comecaComRelatorio = nomeArquivo.StartsWith("relatorio");
Console.WriteLine($"'{nomeArquivo}' começa com 'relatorio'? {comecaComRelatorio}");
// Saída: True

bool comecaComRelatorioMaiusculo = nomeArquivo.StartsWith("Relatorio");
Console.WriteLine($"'{nomeArquivo}' começa com 'Relatorio'? {comecaComRelatorioMaiusculo}");
// Saída: False (por causa do 'R' maiúsculo)

string url = "https://www.exemplo.com";
bool comecaComHttps = url.StartsWith("https://");
Console.WriteLine($"'{url}' começa com 'https://'? {comecaComHttps}");
// Saída: True
```

Termos Técnicos:

* Substring: Uma parte de uma string. Por exemplo, "relatorio" é uma substring de "relatorio_vendas_2024.xlsx".

* Booleano: Um tipo de dado que pode ter apenas dois valores: `true` (verdadeiro) ou `false` (falso).

* Case-sensitive (sensível a maiúsculas e minúsculas): Significa que a comparação diferencia letras maiúsculas de minúsculas.

## 

`EndsWith()`: Verificando o Fim

O método `EndsWith()` é o oposto de `StartsWith()`. Ele é como perguntar: "Esta frase termina com esta palavra?". Ele verifica se a string atual termina com a substring especificada.

Como funciona:

* Você chama `EndsWith()` a partir de uma string, passando a substring que você quer verificar como argumento.

* Ele também é case-sensitive.

* Ele retorna um valor booleano: * `true`: Se a string termina com a substring. * `false`: Se a string não termina com a substring.

Exemplo de Código:

```
string nomeArquivo = "documento_final.pdf";

bool terminaComPdf = nomeArquivo.EndsWith(".pdf");
Console.WriteLine($"'{nomeArquivo}' termina com '.pdf'? {terminaComPdf}");
// Saída: True

bool terminaComDoc = nomeArquivo.EndsWith(".doc");
Console.WriteLine($"'{nomeArquivo}' termina com '.doc'? {terminaComDoc}");
// Saída: False

string email = "usuario@dominio.com.br";
bool terminaComBr = email.EndsWith(".br");
Console.WriteLine($"'{email}' termina com '.br'? {terminaComBr}");
// Saída: True
```

## Comparação Ignorando Maiúsculas/Minúsculas (Case-Insensitive)

Assim como em outras comparações de strings, muitas vezes você pode querer verificar o início ou o fim de uma string sem se preocupar com a diferença entre letras maiúsculas e minúsculas. Para isso, você pode converter tanto a string original quanto a substring para o mesmo caso (tudo minúsculo ou tudo maiúsculo) antes de usar `StartsWith()` ou `EndsWith()`.

Exemplo:

```
string titulo = "A Grande Aventura";
string prefixo = "a grande"; // Minúsculo

// Verificação case-sensitive (retorna False)
bool comecaCaseSensitive = titulo.StartsWith(prefixo);
Console.WriteLine($"'{titulo}' começa com '{prefixo}' (case-sensitive)? {comecaCaseSensitive}");
// Saída: False

// Verificação case-insensitive (retorna True)
bool comecaCaseInsensitive = titulo.ToLower().StartsWith(prefixo.ToLower());
Console.WriteLine($"'{titulo}' começa com '{prefixo}' (case-insensitive)? {comecaCaseInsensitive}");
// Saída: True

string caminho = "/home/usuario/documentos/relatorio.PDF";
string extensao = ".pdf"; // Minúsculo

// Verificação case-sensitive (retorna False)
bool terminaCaseSensitive = caminho.EndsWith(extensao);
Console.WriteLine($"'{caminho}' termina com '{extensao}' (case-sensitive)? {terminaCaseSensitive}");
// Saída: False

// Verificação case-insensitive (retorna True)
bool terminaCaseInsensitive = caminho.ToLower().EndsWith(extensao.ToLower());
Console.WriteLine($"'{caminho}' termina com '{extensao}' (case-insensitive)? {terminaCaseInsensitive}");
// Saída: True
```

Termos Técnicos:

* `ToLower()` (método): Um método de string que retorna uma nova string com todos os caracteres convertidos para minúsculas.

* `ToUpper()` (método): Um método de string que retorna uma nova string com todos os caracteres convertidos para maiúsculas.

Dominar `StartsWith()` e `EndsWith()` é essencial para tarefas comuns de manipulação de strings, como validação de entrada de usuário, análise de nomes de arquivos e URLs, e filtragem de dados.



# Índices em Strings

Pense em uma fila de pessoas. Para saber quem é o primeiro, o segundo, e assim por diante, você atribui um número a cada posição. Em programação, as strings funcionam de forma parecida: cada caractere dentro de uma string tem uma posição, e essa posição é chamada de índice.

## O que é um Índice?

Um índice é um número inteiro que representa a posição de um caractere dentro de uma string. É como o endereço de cada letra. A característica mais importante dos índices na maioria das linguagens de programação (incluindo C#) é que eles são baseados em zero.

### Índices Baseados em Zero

Isso significa que:

* O primeiro caractere de uma string está no índice `0`.

* O segundo caractere está no índice `1`.

* O terceiro caractere está no índice `2`.

* E assim por diante.

Se uma string tem `N` caracteres, o último caractere estará no índice `N-1`.

Exemplo:

Para a string `"Hello"`:

* `H` está no índice `0`

* `e` está no índice `1`

* `l` está no índice `2`

* `l` está no índice `3`

* `o` está no índice `4`

Este diagrama Mermaid ilustra como os índices são usados para acessar caracteres individuais em uma string. Cada nó representa um passo lógico, mostrando a string original e como cada índice aponta para um caractere específico.

```MERMAID
graph TD
    A[String: Hello] --> B{Index 0};
    B --> C[Character: 'H'];
    A --> D{Index 1};
    D --> E[Character: 'e'];
    A --> F{Index 2};
    F --> G[Character: 'l'];
    A --> H{Index 3};
    H --> I[Character: 'l'];
    A --> J{Index 4};
    J --> K[Character: 'o'];
```

## Acessando Caracteres Usando Índices

Você pode acessar um caractere específico em uma string usando seu índice. Isso é útil quando você precisa trabalhar com uma parte exata do texto.

```
string productName = "Smartphone";
char firstLetter = productName[0]; // Accesses the character at index 0 (S)
char fifthLetter = productName[4]; // Accesses the character at index 4 (t)
char lastLetter = productName[productName.Length - 1]; // Accesses the last character (e)

Console.WriteLine($"First letter: {firstLetter}"); // Output: First letter: S
Console.WriteLine($"Fifth letter: {fifthLetter}"); // Output: Fifth letter: t
Console.WriteLine($"Last letter: {lastLetter}"); // Output: Last letter: e
```

## 

Encontrando o Índice de um Substring (`IndexOf`)

Frequentemente, você precisará saber onde uma sequência de caracteres (uma substring) começa dentro de uma string maior. O método `IndexOf()` é usado para isso. Ele retorna o índice da primeira ocorrência da substring que você está procurando.

* Se a substring for encontrada, ele retorna o índice inicial da primeira ocorrência.

* Se a substring não for encontrada, ele retorna `-1`.

```
string emailAddress = "user.name@example.com";

// Finding the index of the '@' symbol
int atSymbolIndex = emailAddress.IndexOf("@");
Console.WriteLine($"'@' symbol found at index: {atSymbolIndex}"); // Output: '@' symbol found at index: 9

// Finding the index of ".com"
int dotComIndex = emailAddress.IndexOf(".com");
Console.WriteLine($"'.com' found at index: {dotComIndex}"); // Output: '.com' found at index: 16

// Trying to find a substring that doesn't exist
int notFoundIndex = emailAddress.IndexOf("xyz");
Console.WriteLine($"'xyz' found at index: {notFoundIndex}"); // Output: 'xyz' found at index: -1

// Using the index to extract a part of the string
// For example, extracting the domain name
if (atSymbolIndex != -1)
{
    string domain = emailAddress.Substring(atSymbolIndex + 1);
    Console.WriteLine($"Domain: {domain}"); // Output: Domain: example.com
}
```

## 

`LastIndexOf()`: Encontrando a Última Ocorrência

Se você precisar encontrar a última ocorrência de um caractere ou substring, pode usar o método `LastIndexOf()`. Ele funciona de forma semelhante ao `IndexOf()`, mas busca do final para o início da string.

```
string filePath = "/home/user/documents/report.pdf";

// Finding the index of the last '/' to get the file name
int lastSlashIndex = filePath.LastIndexOf("/");
Console.WriteLine($"Last slash found at index: {lastSlashIndex}"); // Output: Last slash found at index: 20

if (lastSlashIndex != -1)
{
    string fileName = filePath.Substring(lastSlashIndex + 1);
    Console.WriteLine($"File Name: {fileName}"); // Output: File Name: report.pdf
}
```

Compreender os índices é fundamental para manipular e extrair informações de strings de forma eficaz em qualquer aplicação.



# Outros Métodos

Imagine que você é um editor de texto e precisa realizar diversas operações em frases e palavras: contar caracteres, substituir termos, inserir novas informações, remover trechos indesejados ou até mesmo dividir um parágrafo em sentenças. No C#, as strings são como esses textos, e a linguagem oferece um conjunto robusto de métodos para manipular e transformar esses dados de forma eficiente.

Este documento abordará alguns métodos de string fundamentais que complementam as operações já discutidas, permitindo um controle ainda maior sobre o conteúdo textual.

## 

1. Obtendo o Comprimento da String (`.Length`)

A propriedade `.Length` é como um contador de caracteres. Ela retorna o número total de caracteres em uma string, incluindo letras, números, símbolos e espaços.

```CSHARP
string productName = "Laptop Pro X";
int length = productName.Length; // Result: 12
Console.WriteLine($"Product Name: {productName}, Length: {length}");

string emptyString = "";
int emptyLength = emptyString.Length; // Result: 0
Console.WriteLine($"Empty String Length: {emptyLength}");
```

Termos Técnicos:

* Propriedade: Um membro de uma classe ou struct que fornece um mecanismo flexível para ler, gravar ou computar o valor de um campo privado.

## 

2. Substituindo Conteúdo (`.Replace()`)

O método `.Replace()` é como uma ferramenta de "localizar e substituir" em um editor de texto. Ele cria uma nova string onde todas as ocorrências de uma substring específica são substituídas por outra substring.

```CSHARP
string originalSentence = "The quick brown fox jumps over the lazy fox.";
string newSentence = originalSentence.Replace("fox", "dog"); // Result: "The quick brown dog jumps over the lazy dog."
Console.WriteLine($"Original: {originalSentence}");
Console.WriteLine($"Replaced: {newSentence}");

string productCode = "PROD-ABC-123";
string updatedCode = productCode.Replace("-", "_"); // Result: "PROD_ABC_123"
Console.WriteLine($"Original Code: {productCode}, Updated Code: {updatedCode}");
```

Termos Técnicos:

* Substring: Uma sequência contígua de caracteres dentro de uma string maior.

## 

3. Inserindo Conteúdo (`.Insert()`)

O método `.Insert()` permite que você adicione uma substring em uma posição específica dentro de uma string existente, criando uma nova string com o conteúdo inserido.

```CSHARP
string baseString = "Hello!";
string insertedString = baseString.Insert(5, " World"); // Inserts " World" at index 5. Result: "Hello World!"
Console.WriteLine($"Base String: {baseString}");
Console.WriteLine($"Inserted String: {insertedString}");

string url = "www.example.com";
string fullUrl = url.Insert(0, "https://"); // Inserts "https://" at the beginning (index 0). Result: "https://www.example.com"
Console.WriteLine($"Full URL: {fullUrl}");
```

Termos Técnicos:

* Índice: A posição baseada em zero de um caractere dentro de uma string.

## 

4. Removendo Conteúdo (`.Remove()`)

O método `.Remove()` é usado para criar uma nova string, removendo um número especificado de caracteres a partir de um índice inicial. Você pode remover até o final da string ou um número específico de caracteres.

```CSHARP
string originalText = "This is a sample text.";

// Remove from index 8 to the end
string removedToEnd = originalText.Remove(8); // Result: "This is "
Console.WriteLine($"Removed to End: {removedToEnd}");

// Remove 7 characters starting from index 8
string removedSpecific = originalText.Remove(8, 7); // Result: "This is text."
Console.WriteLine($"Removed Specific: {removedSpecific}");
```

## 

5. Removendo Espaços em Branco (`.Trim()`, `.TrimStart()`, `.TrimEnd()`)

Estes métodos são úteis para "limpar" strings, removendo espaços em branco (e outros caracteres de espaço, como tabulações e quebras de linha) do início, do fim ou de ambas as extremidades de uma string. Eles também retornam uma nova string.

```CSHARP
string paddedText = "   Some text with spaces   ";

string trimmedText = paddedText.Trim(); // Result: "Some text with spaces"
Console.WriteLine($"Original: '{paddedText}'");
Console.WriteLine($"Trimmed: '{trimmedText}'");

string trimmedStart = paddedText.TrimStart(); // Result: "Some text with spaces   "
Console.WriteLine($"Trimmed Start: '{trimmedStart}'");

string trimmedEnd = paddedText.TrimEnd(); // Result: "   Some text with spaces"
Console.WriteLine($"Trimmed End: '{trimmedEnd}'");
```

## 

6. Dividindo Strings (`.Split()`)

O método `.Split()` é como pegar uma tesoura e cortar uma string em pedaços menores, com base em um ou mais delimitadores (caracteres ou strings que indicam onde cortar). Ele retorna um array de strings.

```CSHARP
string csvData = "apple,banana,orange,grape";
string[] fruits = csvData.Split(','); // Splits by comma
Console.WriteLine("Fruits:");
foreach (string fruit in fruits)
{
    Console.WriteLine($"- {fruit.Trim()}"); // Using Trim() to remove potential spaces after comma
}

string sentence = "Hello World from C#";
string[] words = sentence.Split(' '); // Splits by space
Console.WriteLine("Words:");
foreach (string word in words)
{
    Console.WriteLine($"- {word}");
}
```

Termos Técnicos:

* Delimitador: Um caractere ou sequência de caracteres que marca o limite entre regiões ou elementos de dados.

* Array: Uma estrutura de dados que armazena uma coleção de itens do mesmo tipo em uma sequência contígua de locais de memória.

## 

7. Juntando Strings (`string.Join()`)

O método estático `string.Join()` é o inverso de `.Split()`. Ele pega uma coleção de strings (como um array) e as concatena em uma única string, inserindo um separador entre cada elemento.

```CSHARP
string[] parts = { "data", "science", "project" };
string fileName = string.Join("_", parts); // Result: "data_science_project"
Console.WriteLine($"File Name: {fileName}");

string[] tags = { "programming", "c#", "development" };
string tagList = string.Join(", ", tags); // Result: "programming, c#, development"
Console.WriteLine($"Tag List: {tagList}");
```

Termos Técnicos:

* Método Estático: Um método que pertence à própria classe, e não a uma instância específica da classe. Você o chama usando o nome da classe (ex: `string.Join`).

## Conclusão

Compreender e utilizar esses métodos de manipulação de strings é crucial para qualquer desenvolvedor C#. Eles fornecem as ferramentas necessárias para processar, formatar e extrair informações de dados textuais, que são onipresentes em quase todas as aplicações. A prática com esses métodos solidificará sua capacidade de trabalhar com strings de forma eficaz e elegante.



# Manipulando Strings: Formatação e Validação Adicional

Imagine que você está organizando uma planilha de dados e precisa garantir que todos os códigos de produto tenham o mesmo número de dígitos, preenchendo com zeros à esquerda se necessário. Ou talvez você esteja processando dados de entrada de usuários e precisa verificar se um campo de texto está realmente vazio, e não apenas cheio de espaços. No C#, além dos métodos de manipulação de texto que já vimos, existem outras ferramentas poderosas para formatar e validar strings, garantindo a consistência e a robustez dos seus dados.

Este documento abordará métodos adicionais que são cruciais para tarefas comuns de formatação e validação de strings.

## 

1. Preenchendo Strings (`.PadLeft()`, `.PadRight()`)

Estes métodos são como preencher um campo com caracteres específicos para atingir um comprimento total desejado. Eles são frequentemente usados para formatação de saída, como alinhar texto ou preencher números com zeros à esquerda.

### 

`.PadLeft()`: Preenche à Esquerda

Adiciona caracteres (por padrão, espaços) ao início de uma string até que ela atinja um comprimento total especificado.

```CSHARP
string productId = "123";
// Pad with spaces to a total length of 5
string paddedProductId = productId.PadLeft(5); // Result: "  123"
Console.WriteLine($"Padded Product ID (spaces): '{paddedProductId}'");

// Pad with zeros to a total length of 5
string zeroPaddedId = productId.PadLeft(5, '0'); // Result: "00123"
Console.WriteLine($"Padded Product ID (zeros): '{zeroPaddedId}'");

string amount = "45.75";
// Pad with spaces to a total length of 10 for alignment
string paddedAmount = amount.PadLeft(10); // Result: "    45.75"
Console.WriteLine($"Padded Amount: '{paddedAmount}'");
```

### 

`.PadRight()`: Preenche à Direita

Adiciona caracteres (por padrão, espaços) ao final de uma string até que ela atinja um comprimento total especificado.

```CSHARP
string itemName = "Pen";
// Pad with spaces to a total length of 10
string paddedItemName = itemName.PadRight(10); // Result: "Pen       "
Console.WriteLine($"Padded Item Name (spaces): '{paddedItemName}'");

string status = "Active";
// Pad with hyphens to a total length of 15
string paddedStatus = status.PadRight(15, '-'); // Result: "Active---------"
Console.WriteLine($"Padded Status: '{paddedStatus}'");
```

Termos Técnicos:

* Padding: O processo de adicionar caracteres a uma string para que ela atinja um comprimento específico.

## 

2. Verificando Strings Vazias ou Nulas (`string.IsNullOrEmpty()`, `string.IsNullOrWhiteSpace()`)

Esses métodos estáticos são essenciais para validar entradas de usuário e evitar erros de referência nula ou processamento de strings sem conteúdo significativo.

### 

`string.IsNullOrEmpty()`: Verifica Nulo ou Vazio

Retorna `true` se a string for `null` (não aponta para nenhum objeto) ou uma string vazia (`""`).

```CSHARP
string userName = null;
string email = "";
string address = "123 Main St";

bool isUserNameEmpty = string.IsNullOrEmpty(userName); // Result: true
Console.WriteLine($"Is UserName null or empty? {isUserNameEmpty}");

bool isEmailEmpty = string.IsNullOrEmpty(email); // Result: true
Console.WriteLine($"Is Email null or empty? {isEmailEmpty}");

bool isAddressEmpty = string.IsNullOrEmpty(address); // Result: false
Console.WriteLine($"Is Address null or empty? {isAddressEmpty}");
```

### 

`string.IsNullOrWhiteSpace()`: Verifica Nulo, Vazio ou Apenas Espaços

Retorna `true` se a string for `null`, vazia (`""`), ou consistir apenas em caracteres de espaço em branco (espaços, tabulações, quebras de linha, etc.). Este é geralmente o método preferido para validar entradas de texto, pois considera strings como `"   "` como inválidas.

```CSHARP
string input1 = null;
string input2 = "";
string input3 = "   "; // Only spaces
string input4 = "Hello";

bool isInput1Invalid = string.IsNullOrWhiteSpace(input1); // Result: true
Console.WriteLine($"Is Input1 null, empty or whitespace? {isInput1Invalid}");

bool isInput2Invalid = string.IsNullOrWhiteSpace(input2); // Result: true
Console.WriteLine($"Is Input2 null, empty or whitespace? {isInput2Invalid}");

bool isInput3Invalid = string.IsNullOrWhiteSpace(input3); // Result: true
Console.WriteLine($"Is Input3 null, empty or whitespace? {isInput3Invalid}");

bool isInput4Invalid = string.IsNullOrWhiteSpace(input4); // Result: false
Console.WriteLine($"Is Input4 null, empty or whitespace? {isInput4Invalid}");
```

Termos Técnicos:

* `null`: Um valor que indica que uma variável não está apontando para nenhum objeto na memória.

* Espaço em branco (Whitespace): Caracteres que representam espaço horizontal ou vertical, como espaço, tabulação, nova linha, etc.

## 

3. Convertendo para Array de Caracteres (`.ToCharArray()`)

O método `.ToCharArray()` é útil quando você precisa processar uma string caractere por caractere, ou quando uma API espera um array de caracteres em vez de uma string. Ele cria um novo array de caracteres a partir da string.

```CSHARP
string password = "P@ssw0rd!";
char[] passwordChars = password.ToCharArray();

Console.WriteLine("Password characters:");
foreach (char c in passwordChars)
{
    Console.Write($"{c} ");
}
Console.WriteLine(); // New line for formatting

// Example: Reversing a string using ToCharArray()
string originalWord = "developer";
char[] wordChars = originalWord.ToCharArray();
Array.Reverse(wordChars); // Reverses the array in place
string reversedWord = new string(wordChars); // Creates a new string from the char array
Console.WriteLine($"Original: {originalWord}, Reversed: {reversedWord}");
```

Termos Técnicos:

* Array de Caracteres (`char[]`): Uma coleção ordenada de caracteres individuais.

## Conclusão

Os métodos `PadLeft()`, `PadRight()`, `IsNullOrEmpty()`, `IsNullOrWhiteSpace()` e `ToCharArray()` são ferramentas valiosas no arsenal de qualquer desenvolvedor C#. Eles permitem um controle preciso sobre a formatação e a validação de strings, contribuindo para a criação de aplicações mais robustas e com melhor apresentação de dados. Dominar essas funcionalidades é um passo importante para se tornar proficiente na manipulação de texto em C#.



# Manipulação Avançada de Strings no C#

Imagine que você está trabalhando com dados complexos: talvez precise comparar nomes de usuários de forma que "joão" e "João" sejam considerados iguais, ou extrair partes de um log de sistema que contém múltiplos delimitadores, ou ainda otimizar o armazenamento de textos repetitivos. O C# oferece um conjunto de métodos de string mais avançados que permitem lidar com esses cenários, proporcionando maior controle e eficiência.

Este documento explora 15 métodos e conceitos úteis que aprofundam suas habilidades na manipulação de strings, indo além do básico.

## 

1. Comparação Avançada com `string.Equals()` e `string.Compare()`

Enquanto `==` e `CompareTo()` fazem comparações básicas, `string.Equals()` e `string.Compare()` com o enum `StringComparison` oferecem controle preciso sobre como as strings são comparadas, incluindo sensibilidade a maiúsculas/minúsculas e cultura.

### 

`string.Equals(string, StringComparison)`

Compara duas strings usando regras de comparação específicas.

```CSHARP
string user1 = "john.doe";
string user2 = "John.Doe";

// Case-sensitive comparison (default)
bool areEqualCaseSensitive = string.Equals(user1, user2, StringComparison.Ordinal); // Result: false
Console.WriteLine($"'{user1}' equals '{user2}' (Ordinal): {areEqualCaseSensitive}");

// Case-insensitive comparison
bool areEqualCaseInsensitive = string.Equals(user1, user2, StringComparison.OrdinalIgnoreCase); // Result: true
Console.WriteLine($"'{user1}' equals '{user2}' (OrdinalIgnoreCase): {areEqualCaseInsensitive}");

// Culture-sensitive comparison (e.g., for 'i' vs 'İ' in Turkish)
string turkishI = "istanbul";
string turkishCapitalI = "İstanbul";
bool cultureSensitive = string.Equals(turkishI, turkishCapitalI, StringComparison.CurrentCultureIgnoreCase); // Result: true (in Turkish culture)
Console.WriteLine($"'{turkishI}' equals '{turkishCapitalI}' (CurrentCultureIgnoreCase): {cultureSensitive}");
```

### 

`string.Compare(string, string, StringComparison)`

Compara duas strings e retorna um inteiro indicando sua ordem relativa, similar a `CompareTo()`, mas com opções de comparação.

```CSHARP
string city1 = "São Paulo";
string city2 = "Sao Paulo";

// Culture-sensitive comparison (might treat 'ã' differently)
int resultCulture = string.Compare(city1, city2, StringComparison.CurrentCulture); // Result depends on culture
Console.WriteLine($"Compare '{city1}' and '{city2}' (CurrentCulture): {resultCulture}");

// Ordinal comparison (byte-by-byte, 'ã' is different from 'a')
int resultOrdinal = string.Compare(city1, city2, StringComparison.Ordinal); // Result: non-zero
Console.WriteLine($"Compare '{city1}' and '{city2}' (Ordinal): {resultOrdinal}");
```

Termos Técnicos:

* `StringComparison` Enum: Uma enumeração que define as regras para comparações de strings (e.g., `Ordinal`, `OrdinalIgnoreCase`, `CurrentCulture`, `InvariantCulture`).

* Ordinal Comparison: Uma comparação byte-a-byte, sem considerar regras linguísticas ou culturais. É a mais rápida e segura para comparações de segurança (senhas, caminhos de arquivo).

* Culture-Sensitive Comparison: Uma comparação que leva em conta as regras linguísticas e culturais do sistema atual ou de uma cultura específica.

## 

2. Removendo Caracteres Específicos com `Trim(char[])`

O método `Trim()` que você já conhece remove espaços em branco. A sobrecarga `Trim(char[])` permite remover um conjunto específico de caracteres do início e do fim de uma string.

```CSHARP
string data = "###ProductCode-123###";
char[] trimChars = { '#' };
string cleanedData = data.Trim(trimChars); // Result: "ProductCode-123"
Console.WriteLine($"Original: '{data}', Cleaned: '{cleanedData}'");

string path = "/path/to/file/";
char[] slash = { '/' };
string cleanedPath = path.Trim(slash); // Result: "path/to/file"
Console.WriteLine($"Original Path: '{path}', Cleaned Path: '{cleanedPath}'");
```

## 

3. Divisão Avançada com `Split(char[], int, StringSplitOptions)`

O `Split()` básico divide por um delimitador. As sobrecargas permitem controlar o número máximo de substrings retornadas e como lidar com entradas vazias.

```CSHARP
string logEntry = "ERROR:::File not found:::2023-01-15";

// Split into at most 2 parts, removing empty entries
string[] parts = logEntry.Split(new[] { ":::" }, 2, StringSplitOptions.RemoveEmptyEntries);
// Result: ["ERROR", "File not found:::2023-01-15"]
Console.WriteLine("Log Parts (max 2):");
foreach (string part in parts)
{
    Console.WriteLine($"- {part}");
}

string csvLine = "apple,,orange,";
// Split and remove empty entries
string[] items = csvLine.Split(',', StringSplitOptions.RemoveEmptyEntries);
// Result: ["apple", "orange"]
Console.WriteLine("CSV Items (RemoveEmptyEntries):");
foreach (string item in items)
{
    Console.WriteLine($"- {item}");
}
```

Termos Técnicos:

* `StringSplitOptions` Enum: Controla o comportamento do método `Split()`, como `RemoveEmptyEntries` (ignora substrings vazias) ou `None` (inclui substrings vazias).

## 

4. Unindo Coleções com `string.Join(string, IEnumerable<string>)`

Enquanto `string.Join()` já foi abordado, a sobrecarga que aceita `IEnumerable<string>` é extremamente útil para unir qualquer coleção de strings (como `List<string>`, `HashSet<string>`) sem precisar convertê-las para um array primeiro.

```CSHARP
using System.Collections.Generic;

List<string> tags = new List<string> { "programming", "csharp", "backend" };
string tagString = string.Join("; ", tags); // Result: "programming; csharp; backend"
Console.WriteLine($"Joined Tags: {tagString}");

HashSet<string> uniqueUsers = new HashSet<string> { "alice", "bob", "charlie" };
string userList = string.Join(", ", uniqueUsers); // Result: "alice, bob, charlie" (order may vary)
Console.WriteLine($"Joined Users: {userList}");
```

Termos Técnicos:

* `IEnumerable<T>`: Uma interface que representa uma coleção de elementos que podem ser iterados (percorridos).

## 

5. Verificando Caracteres Únicos com `Contains(char)`

Embora `Contains(string)` verifique substrings, `Contains(char)` é uma sobrecarga mais eficiente para verificar a presença de um único caractere.

```CSHARP
string email = "user@example.com";
bool hasAtSymbol = email.Contains('@'); // Result: true
Console.WriteLine($"Email '{email}' contains '@'? {hasAtSymbol}");

string phoneNumber = "123-456-7890";
bool hasDash = phoneNumber.Contains('-'); // Result: true
Console.WriteLine($"Phone number '{phoneNumber}' contains '-'? {hasDash}");
```

## 

6. Encontrando Qualquer Caractere de um Conjunto (`IndexOfAny()`, `LastIndexOfAny()`)

Estes métodos são como procurar por qualquer um de vários itens em uma lista. Eles retornam o índice da primeira (ou última) ocorrência de qualquer caractere presente em um array de caracteres fornecido.

### 

`IndexOfAny(char[])`

```CSHARP
string text = "Hello, World! How are you?";
char[] delimiters = { ',', '!', '?' };
int firstDelimiterIndex = text.IndexOfAny(delimiters); // Result: 5 (index of ',')
Console.WriteLine($"First delimiter found at index: {firstDelimiterIndex}");
```

### 

`LastIndexOfAny(char[])`

```CSHARP
string textWithMultipleDelimiters = "Item1;Item2,Item3|Item4";
char[] separators = { ';', ',', '|' };
int lastSeparatorIndex = textWithMultipleDelimiters.LastIndexOfAny(separators); // Result: 17 (index of '|')
Console.WriteLine($"Last separator found at index: {lastSeparatorIndex}");
```

## 

7. Convertendo Parte da String para Array de Caracteres (`ToCharArray(int, int)`)

Enquanto `ToCharArray()` converte a string inteira, esta sobrecarga permite converter apenas uma porção da string para um array de caracteres.

```CSHARP
string fullAddress = "123 Main Street, Anytown";
// Get characters for "Main Street"
char[] streetChars = fullAddress.ToCharArray(4, 11); // Start at index 4, take 11 characters
string streetName = new string(streetChars); // Convert char array back to string
Console.WriteLine($"Street Name: {streetName}");
```

## 

8. Entendendo `string.Clone()` (Imutabilidade)

O método `Clone()` retorna uma nova referência para a mesma instância da string. Devido à imutabilidade das strings em C#, clonar uma string não cria uma cópia separada do conteúdo, mas sim uma nova referência para o mesmo objeto na memória. Isso é importante para entender o comportamento de strings.

```CSHARP
string originalString = "Immutable";
string clonedString = (string)originalString.Clone();

bool areSameReference = ReferenceEquals(originalString, clonedString); // Result: true
Console.WriteLine($"Are original and cloned strings the same reference? {areSameReference}");

// Modifying 'clonedString' actually creates a new string due to imutability
clonedString = clonedString + " Text";
Console.WriteLine($"Original: {originalString}, Cloned (modified): {clonedString}");
```

Termos Técnicos:

* Imutabilidade: Uma propriedade de um objeto cujo estado não pode ser modificado após sua criação.

* `ReferenceEquals()`: Um método estático que verifica se duas referências de objeto apontam para a mesma instância na memória.

## 

9. Copiando Conteúdo para Array de Caracteres (`CopyTo()`)

O método `CopyTo()` permite copiar uma parte ou a totalidade dos caracteres de uma string para um array de caracteres existente, a partir de um índice específico no array de destino.

```CSHARP
string source = "Hello World";
char[] destination = new char[10]; // Create a char array to copy into

// Copy 5 characters from 'source' starting at index 0, to 'destination' starting at index 0
source.CopyTo(0, destination, 0, 5); // Result: destination = ['H', 'e', 'l', 'l', 'o', ' ', ' ', ' ', ' ', ' ']
Console.WriteLine($"Copied characters: {new string(destination)}");
```

## 

10. Obtendo o Código Hash (`GetHashCode()`)

O método `GetHashCode()` retorna um código hash numérico para a string. Isso é fundamental para o funcionamento de coleções baseadas em hash, como `Dictionary<TKey, TValue>` e `HashSet<T>`, onde as strings são usadas como chaves. Strings iguais (com base em `Equals()`) devem ter o mesmo código hash.

```CSHARP
string key1 = "ProductA";
string key2 = "ProductA";
string key3 = "productA";

int hash1 = key1.GetHashCode();
int hash2 = key2.GetHashCode();
int hash3 = key3.GetHashCode();

Console.WriteLine($"Hash for '{key1}': {hash1}");
Console.WriteLine($"Hash for '{key2}': {hash2}");
Console.WriteLine($"Hash for '{key3}': {hash3}");
// hash1 and hash2 will be the same. hash3 will likely be different due to case-sensitivity.
```

Termos Técnicos:

* Código Hash: Um valor numérico gerado a partir de um objeto, usado para identificar o objeto em estruturas de dados baseadas em hash. Idealmente, objetos iguais devem ter o mesmo código hash.

## 

11. Normalização Unicode (`Normalize()`, `IsNormalized()`)

Caracteres Unicode podem ter múltiplas representações binárias (formas de composição). A normalização garante que strings com o mesmo significado tenham a mesma representação binária, o que é crucial para comparações e buscas corretas em sistemas que lidam com múltiplos idiomas.

### 

`Normalize()`

Retorna uma nova string que é a forma normalizada da string atual.

```CSHARP
string combinedChar = "e\u0301"; // 'e' followed by combining acute accent
string precomposedChar = "\u00E9"; // 'é' as a single character

Console.WriteLine($"Combined: {combinedChar}, Length: {combinedChar.Length}"); // Length: 2
Console.WriteLine($"Precomposed: {precomposedChar}, Length: {precomposedChar.Length}"); // Length: 1

// Normalize to Form C (Canonical Composition)
string normalizedCombined = combinedChar.Normalize(System.Text.NormalizationForm.FormC);
Console.WriteLine($"Normalized Combined: {normalizedCombined}, Length: {normalizedCombined.Length}"); // Length: 1, same as precomposed

bool areEqualAfterNormalize = string.Equals(normalizedCombined, precomposedChar); // Result: true
Console.WriteLine($"Are equal after normalization? {areEqualAfterNormalize}");
```

### 

`IsNormalized()`

Verifica se a string já está em uma forma de normalização específica.

```CSHARP
string text1 = "résumé"; // Already normalized (Form C)
string text2 = "re\u0301sume"; // 'e' followed by combining acute accent

bool isText1Normalized = text1.IsNormalized(System.Text.NormalizationForm.FormC); // Result: true
Console.WriteLine($"'{text1}' is normalized (FormC)? {isText1Normalized}");

bool isText2Normalized = text2.IsNormalized(System.Text.NormalizationForm.FormC); // Result: false
Console.WriteLine($"'{text2}' is normalized (FormC)? {isText2Normalized}");
```

Termos Técnicos:

* Unicode: Um padrão de codificação de caracteres que visa representar todos os caracteres de todos os sistemas de escrita do mundo.

* Normalização Unicode: O processo de transformar strings Unicode em uma forma canônica para garantir que strings com o mesmo significado tenham a mesma representação binária.

* `NormalizationForm` Enum: Define as diferentes formas de normalização Unicode (e.g., `FormC`, `FormD`).

## 

12. Comparação Ordinal Pura com `string.CompareOrdinal()`

Este método compara strings caractere por caractere, com base em seus valores Unicode (ordem binária), sem aplicar regras de cultura ou maiúsculas/minúsculas. É a comparação mais rápida e é usada quando a equivalência linguística não é um fator, como em hashes ou caminhos de arquivo.

```CSHARP
string path1 = "C:\\Users\\file.txt";
string path2 = "c:\\users\\file.txt";

// Ordinal comparison (case-sensitive, byte-by-byte)
int ordinalResult = string.CompareOrdinal(path1, path2); // Result: non-zero (due to 'C' vs 'c')
Console.WriteLine($"CompareOrdinal '{path1}' and '{path2}': {ordinalResult}");

string s1 = "apple";
string s2 = "Apple";
int ordinalResult2 = string.CompareOrdinal(s1, s2); // Result: non-zero
Console.WriteLine($"CompareOrdinal '{s1}' and '{s2}': {ordinalResult2}");
```

## 

13. Formatação Avançada com `string.Format` (Revisão de Especificadores)

Embora `string.Format` e interpolação de strings tenham sido introduzidos, a profundidade dos especificadores de formato é vasta. Aqui, focamos em alguns exemplos avançados para números e datas.

### Formatação Numérica

```CSHARP
double price = 12345.6789;
Console.WriteLine($"Currency (C): {string.Format("{0:C}", price)}"); // Result: R$12,345.68 (culture-dependent)
Console.WriteLine($"Number (N2): {string.Format("{0:N2}", price)}"); // Result: 12,345.68 (culture-dependent)
Console.WriteLine($"Percentage (P1): {string.Format("{0:P1}", 0.75)}"); // Result: 75.0%
Console.WriteLine($"Custom (000.00): {string.Format("{0:000.00}", 12.3)}"); // Result: 012.30
```

### Formatação de Data e Hora

```CSHARP
DateTime now = DateTime.Now;
Console.WriteLine($"Short Date (d): {string.Format("{0:d}", now)}"); // Result: 26/07/2025 (culture-dependent)
Console.WriteLine($"Long Date (D): {string.Format("{0:D}", now)}"); // Result: sábado, 26 de julho de 2025 (culture-dependent)
Console.WriteLine($"Full Date/Time (F): {string.Format("{0:F}", now)}"); // Result: sábado, 26 de julho de 2025 10:30:00 (culture-dependent)
Console.WriteLine($"Custom (yyyy-MM-dd HH:mm): {string.Format("{0:yyyy-MM-dd HH:mm}", now)}"); // Result: 2025-07-26 10:30
```

Termos Técnicos:

* Especificadores de Formato: Caracteres ou sequências de caracteres que controlam como um valor é convertido para sua representação de string (e.g., `C` para moeda, `N` para número, `d` para data curta).

## Conclusão

Dominar esses métodos e conceitos avançados de manipulação de strings no C# é um diferencial para qualquer desenvolvedor. Eles permitem escrever código mais robusto, eficiente e adaptável a diferentes cenários, desde a validação de dados até a internacionalização de aplicações. A prática contínua com esses recursos solidificará sua expertise em lidar com dados textuais de forma profissional.



# Mais Métodos e Conceitos

No desenvolvimento de software, a manipulação de texto é uma tarefa constante. À medida que os sistemas crescem em complexidade e performance se torna um fator crítico, é essencial ir além dos métodos básicos de string e explorar ferramentas mais poderosas e eficientes. Este documento apresenta uma seleção de métodos e conceitos avançados que permitem um controle mais granular e otimizado sobre as operações com strings no C#.

## 

1. Otimização de Memória: String Pooling (`string.Intern()`, `string.IsInterned()`)

Imagine que você tem uma biblioteca com muitos livros, e vários deles têm o mesmo título. Em vez de ter várias cópias físicas do mesmo título, a biblioteca decide ter apenas uma cópia e várias referências a ela. No C#, o string pooling (ou interning) funciona de forma semelhante para otimizar o uso de memória, especialmente para strings literais e strings frequentemente repetidas.

Quando uma string é interned, o Common Language Runtime (CLR) a armazena em um pool interno. Se outra string com o mesmo valor for criada, em vez de alocar nova memória, o CLR retorna uma referência à instância existente no pool.

### 

`string.Intern(string str)`

Adiciona a string especificada ao pool de interning. Se a string já estiver no pool, retorna a referência à instância existente.

### 

`string.IsInterned(string str)`

Verifica se a string especificada já está no pool de interning. Retorna a referência à instância interned se estiver, caso contrário, retorna `null`.

```CSHARP
string s1 = "Hello World";
string s2 = "Hello World";
string s3 = new StringBuilder().Append("Hello").Append(" World").ToString();

// s1 and s2 are string literals, they are automatically interned by the CLR
bool areSameReference1 = ReferenceEquals(s1, s2); // Result: true
Console.WriteLine($"s1 and s2 are same reference: {areSameReference1}");

// s3 is created at runtime, so it's a new object
bool areSameReference2 = ReferenceEquals(s1, s3); // Result: false
Console.WriteLine($"s1 and s3 are same reference (before intern): {areSameReference2}");

// Intern s3
string s3Interned = string.Intern(s3);

bool areSameReference3 = ReferenceEquals(s1, s3Interned); // Result: true
Console.WriteLine($"s1 and s3Interned are same reference (after intern): {areSameReference3}");

// Check if a string is interned
string internedCheck1 = string.IsInterned(s1); // Result: "Hello World"
string internedCheck2 = string.IsInterned(s3); // Result: "Hello World" (after s3 was interned)
string internedCheck3 = string.IsInterned("Another String"); // Result: null (if not interned yet)
Console.WriteLine($"Is s1 interned? {internedCheck1 != null}");
Console.WriteLine($"Is s3 interned? {internedCheck2 != null}");
Console.WriteLine($"Is 'Another String' interned? {internedCheck3 != null}");
```

Termos Técnicos:

* String Pooling (Interning): Um mecanismo de otimização de memória onde strings com o mesmo valor são armazenadas como uma única instância na memória.

* CLR (Common Language Runtime): O ambiente de execução do .NET que gerencia a execução de programas.

* `ReferenceEquals()`: Um método estático que verifica se duas referências de objeto apontam para a mesma instância na memória.

## 

2. Construção Eficiente de Strings: `StringBuilder`

Imagine que você está construindo uma parede tijolo por tijolo. Se você tivesse que demolir a parede inteira e reconstruí-la do zero a cada novo tijolo, seria muito ineficiente. Strings em C# são imutáveis, o que significa que cada operação que "modifica" uma string na verdade cria uma nova. Para cenários onde você precisa realizar muitas concatenações ou modificações em uma string, `StringBuilder` é a ferramenta ideal, pois ela permite a modificação eficiente de uma sequência de caracteres sem criar novas instâncias de string a cada operação.

```CSHARP
using System.Text;

StringBuilder sb = new StringBuilder();

sb.Append("Hello");
sb.Append(" World");
sb.AppendLine(" from StringBuilder!"); // Appends text and a new line
sb.AppendFormat("The current time is {0:HH:mm:ss}", DateTime.Now); // Appends formatted text

Console.WriteLine($"StringBuilder content: {sb.ToString()}");

sb.Insert(6, "Big "); // Insert "Big " at index 6
Console.WriteLine($"After Insert: {sb.ToString()}");

sb.Replace("World", "Universe"); // Replace "World" with "Universe"
Console.WriteLine($"After Replace: {sb.ToString()}");

sb.Remove(0, 6); // Remove 6 characters from the beginning
Console.WriteLine($"After Remove: {sb.ToString()}");

// Get the final string
string finalString = sb.ToString();
Console.WriteLine($"Final String: {finalString}");
```

Termos Técnicos:

* Mutabilidade: A capacidade de um objeto ter seu estado alterado após sua criação.

* `System.Text` Namespace: O namespace que contém classes para manipulação de caracteres e codificações de texto, incluindo `StringBuilder`.

## 

3. Comparação de Strings com Opções de Cultura (`string.Compare(string, string, bool, CultureInfo)`)

Embora `string.Compare` com `StringComparison` tenha sido abordado, a sobrecarga que aceita um `CultureInfo` permite especificar explicitamente as regras de comparação cultural, o que é vital para aplicações globalizadas.

```CSHARP
using System.Globalization;

string strA = "Straße";
string strB = "strasse";

// Case-insensitive comparison using German culture
int resultGerman = string.Compare(strA, strB, true, new CultureInfo("de-DE"));
Console.WriteLine($"Compare '{strA}' and '{strB}' (German, ignore case): {resultGerman}");
// In German, 'ß' is often treated as 'ss' for case-insensitive comparisons, so result might be 0.

string strC = "file";
string strD = "File";

// Case-sensitive comparison using InvariantCulture
int resultInvariant = string.Compare(strC, strD, false, CultureInfo.InvariantCulture);
Console.WriteLine($"Compare '{strC}' and '{strD}' (Invariant, case-sensitive): {resultInvariant}");
```

Termos Técnicos:

* `CultureInfo`: Uma classe que fornece informações sobre uma cultura específica, incluindo convenções de formatação de data, hora, números e regras de comparação de strings.

* `InvariantCulture`: Uma cultura que é independente de qualquer cultura específica. É usada para operações que devem produzir resultados consistentes, independentemente das configurações de cultura do usuário.

## 

4. Verificando o Tipo de Caractere (`char.IsDigit()`, `char.IsLetter()`, etc.)

Imagine que você está validando uma senha e precisa garantir que ela contenha pelo menos um número, uma letra e um símbolo. A classe `char` (que representa um único caractere) oferece métodos estáticos para verificar a categoria de um caractere, o que é muito útil para validação e análise de texto.

```CSHARP
string password = "P@ssw0rd1!";

bool hasDigit = false;
bool hasLetter = false;
bool hasSymbol = false;

foreach (char c in password)
{
    if (char.IsDigit(c))
    {
        hasDigit = true;
    }
    else if (char.IsLetter(c))
    {
        hasLetter = true;
    }
    else if (char.IsSymbol(c) || char.IsPunctuation(c))
    {
        hasSymbol = true;
    }
}

Console.WriteLine($"Password '{password}' has digit: {hasDigit}");
Console.WriteLine($"Password '{password}' has letter: {hasLetter}");
Console.WriteLine($"Password '{password}' has symbol/punctuation: {hasSymbol}");

// Other useful char methods:
Console.WriteLine($"Is ' ' whitespace? {char.IsWhiteSpace(' ')}");
Console.WriteLine($"Is 'A' upper? {char.IsUpper('A')}");
Console.WriteLine($"Is 'a' lower? {char.IsLower('a')}");
```

Termos Técnicos:

* `char` (tipo): Um tipo de dado que representa um único caractere Unicode.

* Métodos Estáticos da Classe `char`: Funções que operam em caracteres e são chamadas diretamente na classe `char` (e.g., `char.IsDigit()`).

## 

5. Removendo Caracteres Específicos com `TrimStart(char[])` e `TrimEnd(char[])`

Complementando o `Trim(char[])` já visto, estes métodos permitem remover um conjunto específico de caracteres apenas do início (`TrimStart`) ou apenas do final (`TrimEnd`) de uma string.

```CSHARP
string rawInput = "###DATA###";
char[] trimChars = { '#' };

string startTrimmed = rawInput.TrimStart(trimChars); // Result: "DATA###"
Console.WriteLine($"Trimmed Start: '{startTrimmed}'");

string endTrimmed = rawInput.TrimEnd(trimChars); // Result: "###DATA"
Console.WriteLine($"Trimmed End: '{endTrimmed}'");
```

## 

6. Verificando se a String é Numérica (`double.TryParse()`, `int.TryParse()`, etc.)

Em vez de apenas verificar se um caractere é um dígito, muitas vezes você precisa saber se uma string inteira pode ser convertida para um tipo numérico. Os métodos `TryParse()` são a maneira segura e eficiente de fazer isso, evitando exceções.

```CSHARP
string priceText = "123.45";
string quantityText = "50";
string invalidText = "abc";

// Try parsing to double
if (double.TryParse(priceText, out double price))
{
    Console.WriteLine($"Price parsed: {price}");
}
else
{
    Console.WriteLine($"Could not parse price: {priceText}");
}

// Try parsing to int
if (int.TryParse(quantityText, out int quantity))
{
    Console.WriteLine($"Quantity parsed: {quantity}");
}
else
{
    Console.WriteLine($"Could not parse quantity: {quantityText}");
}

// Invalid parse attempt
if (!int.TryParse(invalidText, out int parsedInvalid))
{
    Console.WriteLine($"Successfully failed to parse: {invalidText}");
}
```

Termos Técnicos:

* `TryParse()`: Um padrão de método em .NET que tenta converter uma string para um tipo específico e retorna um booleano indicando o sucesso, sem lançar uma exceção em caso de falha.

* `out` Keyword: Uma palavra-chave em C# usada para passar argumentos para métodos por referência, permitindo que o método retorne valores através desses argumentos.

## 

7. Comparação de Strings com RegEx (`Regex.IsMatch()`)

Para padrões de busca e validação mais complexos do que `Contains()` ou `StartsWith()`, Expressões Regulares (RegEx) são a ferramenta. `Regex.IsMatch()` verifica se uma string corresponde a um padrão RegEx.

```CSHARP
using System.Text.RegularExpressions;

string emailAddress = "test@example.com";
string invalidEmail = "test@example";

// Regex pattern for a simple email validation
string emailPattern = @"^[^@\s]+@[^@\s]+\.[^@\s]+$";

bool isValidEmail1 = Regex.IsMatch(emailAddress, emailPattern);
Console.WriteLine($"'{emailAddress}' is valid email: {isValidEmail1}");

bool isValidEmail2 = Regex.IsMatch(invalidEmail, emailPattern);
Console.WriteLine($"'{invalidEmail}' is valid email: {isValidEmail2}");

// Check for a specific format, e.g., a product code like ABC-1234
string productCode = "XYZ-9876";
string productPattern = @"^[A-Z]{3}-\d{4}$";
bool isProductCodeValid = Regex.IsMatch(productCode, productPattern);
Console.WriteLine($"'{productCode}' matches product pattern: {isProductCodeValid}");
```

Termos Técnicos:

* Expressão Regular (RegEx): Uma sequência de caracteres que define um padrão de busca. Usada para encontrar, substituir e validar texto que corresponde a esse padrão.

* `System.Text.RegularExpressions` Namespace: O namespace que contém classes para trabalhar com expressões regulares.

## 

8. Substituição com RegEx (`Regex.Replace()`)

Além de verificar, RegEx também pode ser usado para substituir partes de uma string que correspondem a um padrão.

```CSHARP
string logLine = "User: JohnDoe, IP: 192.168.1.100, Status: Success";
// Replace IP addresses with [REDACTED]
string redactedLog = Regex.Replace(logLine, @"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b", "[REDACTED]");
Console.WriteLine($"Redacted Log: {redactedLog}");

string phoneNumber = "(11) 98765-4321";
// Remove all non-digit characters
string cleanedPhoneNumber = Regex.Replace(phoneNumber, @"\D", ""); // \D matches any non-digit character
Console.WriteLine($"Cleaned Phone Number: {cleanedPhoneNumber}");
```

## 

9. Extração com RegEx (`Regex.Match()`, `Regex.Matches()`)

Para extrair informações específicas de uma string que seguem um padrão, `Regex.Match()` (para a primeira ocorrência) e `Regex.Matches()` (para todas as ocorrências) são poderosos.

```CSHARP
string textWithPrices = "Item A: $10.50, Item B: $25.00, Item C: $5.99";
string pricePattern = @"\$(\d+\.\d{2})"; // Pattern to capture prices like $XX.YY

// Find all matches
MatchCollection matches = Regex.Matches(textWithPrices, pricePattern);
Console.WriteLine("Extracted Prices:");
foreach (Match match in matches)
{
    // Group 1 contains the captured price without the dollar sign
    Console.WriteLine($"- {match.Groups[1].Value}");
}
```

## 

10. Verificando se a String é Nula ou Vazia de Forma Concisa (`string.IsNullOrEmpty()` com operador `??`)

Embora `string.IsNullOrEmpty()` tenha sido abordado, a combinação com o operador de coalescência nula (`??`) é uma prática comum para fornecer um valor padrão quando uma string é nula ou vazia.

```CSHARP
string userName = null;
string defaultName = "Guest";

string displayUserName = userName ?? defaultName; // If userName is null, use defaultName
Console.WriteLine($"Display User Name (null): {displayUserName}");

string email = "";
string defaultEmail = "no_email@example.com";

// This won't work directly with ?? for empty strings, as ?? only checks for null
string displayEmail = email ?? defaultEmail; // Result: "" (email is not null)
Console.WriteLine($"Display Email (empty, with ??): {displayEmail}");

// Correct way to handle null or empty
string finalEmail = string.IsNullOrEmpty(email) ? defaultEmail : email;
Console.WriteLine($"Display Email (empty, with IsNullOrEmpty): {finalEmail}");
```

Termos Técnicos:

* Operador de Coalescência Nula (`??`): Um operador que retorna o operando esquerdo se ele não for nulo; caso contrário, retorna o operando direito.

## 

11. Criando Strings a Partir de Caracteres Repetidos (`new string(char, int)`)

Um construtor de string útil para criar uma string composta por um caractere repetido um certo número de vezes.

```CSHARP
string separator = new string('-', 20); // Result: "--------------------"
Console.WriteLine(separator);

string padding = new string(' ', 10); // Result: "          "
Console.WriteLine($"Padded text: {padding}Hello");
```

## 

12. Comparando Strings para Igualdade de Conteúdo (`string.Equals(object)`)

Embora `string.Equals(string, StringComparison)` seja mais poderoso, a sobrecarga `string.Equals(object)` é a que é chamada quando você usa `myString.Equals(anotherObject)`. É importante entender que ela compara o conteúdo da string, não a referência, e é segura para usar com objetos que podem não ser strings.

```CSHARP
string s1 = "Test";
object o1 = "Test";
object o2 = new StringBuilder("Test").ToString();

bool equalsObject1 = s1.Equals(o1); // Result: true
Console.WriteLine($"s1 equals o1: {equalsObject1}");

bool equalsObject2 = s1.Equals(o2); // Result: true
Console.WriteLine($"s1 equals o2: {equalsObject2}");

object o3 = 123; // Not a string
bool equalsObject3 = s1.Equals(o3); // Result: false
Console.WriteLine($"s1 equals o3: {equalsObject3}");
```

## 

13. Obtendo um Substring de um Caractere (`string.Substring(int, int)` com `IndexOf`)

Uma aplicação prática de `Substring` e `IndexOf` é extrair texto entre dois delimitadores ou a partir de um delimitador até o final.

```CSHARP
string logMessage = "[INFO] User logged in at 2025-07-26";

// Extract message content (after first ']')
int startIndex = logMessage.IndexOf("]") + 2; // +2 to skip ']' and space
string messageContent = logMessage.Substring(startIndex);
Console.WriteLine($"Log Content: {messageContent}");

string dataRecord = "ID:123;Name:Alice;Status:Active";
// Extract Name
int nameStartIndex = dataRecord.IndexOf("Name:") + "Name:".Length;
int nameEndIndex = dataRecord.IndexOf(";", nameStartIndex);
string name = dataRecord.Substring(nameStartIndex, nameEndIndex - nameStartIndex);
Console.WriteLine($"Extracted Name: {name}");
```

## 

14. Verificando se a String é Vazia (`string.IsEmpty` - C# 11+)

Para versões mais recentes do C# (11 e superior), a propriedade `string.IsEmpty` foi introduzida para uma verificação mais clara e performática de strings vazias, sem a necessidade de verificar `null` separadamente.

```CSHARP
string emptyString = "";
string nonEmptyString = "data";

// Requires C# 11 or later
// bool isEmpty1 = emptyString.IsEmpty; // Result: true
// bool isEmpty2 = nonEmptyString.IsEmpty; // Result: false
// Console.WriteLine($"Is empty string empty? {isEmpty1}");
// Console.WriteLine($"Is non-empty string empty? {isEmpty2}");

// For older C# versions, use Length == 0
bool isEmptyLegacy1 = emptyString.Length == 0; // Result: true
bool isEmptyLegacy2 = nonEmptyString.Length == 0; // Result: false
Console.WriteLine($"Is empty string empty (legacy)? {isEmptyLegacy1}");
Console.WriteLine($"Is non-empty string empty (legacy)? {isEmptyLegacy2}");
```

Termos Técnicos:

* C# 11+: Indica que a funcionalidade está disponível a partir da versão 11 da linguagem C#.

## 

15. Usando `ReadOnlySpan<char>` para Performance (C# 7.2+)

Para operações de string de alta performance que não envolvem alocação de memória (como leitura de substrings sem copiá-las), `ReadOnlySpan<char>` é uma ferramenta avançada. Ele permite trabalhar com uma "visão" de uma parte da memória sem criar uma nova string.

```CSHARP
// This is an advanced topic for performance-critical scenarios.
// Requires .NET Core 2.1+ or .NET Standard 2.1+ and C# 7.2+

string largeLog = "[2025-07-26 10:30:00 INFO] User 'Alice' logged in from IP 192.168.1.10.";

// Get a span over the log message without allocating a new string
ReadOnlySpan<char> logSpan = largeLog.AsSpan();

// Find the start and end of the username
int userStartIndex = logSpan.IndexOf("User '") + "User '".Length;
int userEndIndex = logSpan.IndexOf("' logged");

if (userStartIndex != -1 && userEndIndex != -1)
{
    // Create a new span for the username (no allocation for the span itself)
    ReadOnlySpan<char> usernameSpan = logSpan.Slice(userStartIndex, userEndIndex - userStartIndex);
    Console.WriteLine($"Username (from Span): {usernameSpan.ToString()}"); // .ToString() allocates a string if needed
}

// Example: Parsing a date from a string without allocating substrings
string dateString = "2025-07-26";
ReadOnlySpan<char> dateSpan = dateString.AsSpan();

int year = int.Parse(dateSpan.Slice(0, 4));
int month = int.Parse(dateSpan.Slice(5, 2));
int day = int.Parse(dateSpan.Slice(8, 2));

Console.WriteLine($"Parsed Date (from Span): Year={year}, Month={month}, Day={day}");
```

Termos Técnicos:

* `ReadOnlySpan<T>`: Um tipo de referência que pode apontar para uma região contígua de memória. É usado para operações de alta performance que evitam alocações de memória desnecessárias.

* Alocação de Memória: O processo de reservar um espaço na memória do computador para armazenar dados.

## Conclusão

Este conjunto de métodos e conceitos avançados de string no C# equipa você com as ferramentas necessárias para lidar com cenários de manipulação de texto mais complexos e otimizados. Desde a gestão de memória com string pooling até a construção eficiente com `StringBuilder` e a performance de `ReadOnlySpan<char>`, dominar esses recursos é um passo significativo para se tornar um desenvolvedor C# proficiente e capaz de construir aplicações de alta qualidade.



# StringBuilder: Construindo Strings de Forma Eficiente no C#

Imagine que você está construindo uma casa e, a cada novo tijolo que você adiciona, você tivesse que demolir a parede inteira e reconstruí-la do zero, apenas para incluir o novo tijolo. Isso seria incrivelmente ineficiente e demorado, certo? No mundo da programação C#, as strings (`string`) funcionam de forma semelhante: elas são imutáveis.

Isso significa que, uma vez que uma string é criada, seu conteúdo não pode ser alterado. Quando você realiza uma operação que parece modificar uma string (como concatenar duas strings com o operador `+`), o que realmente acontece é que uma nova string é criada na memória com o resultado da operação, e a string original permanece intocada. Para poucas operações, isso não é um problema. Mas quando você precisa realizar muitas concatenações ou modificações em uma string, especialmente dentro de loops, essa criação constante de novas strings pode levar a um consumo excessivo de memória e impactar negativamente a performance da sua aplicação.

É aí que entra o `StringBuilder`.

## 

O que é `StringBuilder`?

`StringBuilder` é uma classe no C# (localizada no namespace `System.Text`) que representa uma sequência de caracteres mutável. Ao contrário da `string` imutável, um `StringBuilder` permite que você adicione, remova, substitua ou insira caracteres sem criar um novo objeto na memória a cada operação. Ele gerencia um buffer interno de caracteres que cresce dinamicamente conforme necessário, tornando-o muito mais eficiente para cenários de manipulação intensiva de strings.

## 

Por que usar `StringBuilder`?

O principal motivo para usar `StringBuilder` é a performance e a eficiência de memória, especialmente em situações onde:

* Você precisa concatenar um grande número de strings.

* Você está construindo uma string dentro de um loop.

* Você precisa realizar muitas operações de inserção, remoção ou substituição em uma string.

Ao usar `StringBuilder`, você evita a alocação desnecessária de memória e a cópia de dados que ocorrem com a manipulação de strings imutáveis, resultando em um código mais rápido e com menor pegada de memória.

## 

Métodos Comuns do `StringBuilder`

Vamos explorar os métodos mais utilizados da classe `StringBuilder`:

### 

1. `Append()`: Adicionando Texto

Adiciona uma representação de string de um objeto ou o conteúdo de outra string ao final da instância atual do `StringBuilder`.

```CSHARP
using System.Text;

StringBuilder logBuilder = new StringBuilder();
logBuilder.Append("User logged in.");
logBuilder.Append(" IP Address: ");
logBuilder.Append("192.168.1.100");

Console.WriteLine(logBuilder.ToString()); // Result: User logged in. IP Address: 192.168.1.100
```

### 

2. `AppendLine()`: Adicionando Texto com Nova Linha

Adiciona uma representação de string de um objeto ou o conteúdo de outra string, seguida por um terminador de linha, ao final da instância atual do `StringBuilder`.

```CSHARP
StringBuilder reportBuilder = new StringBuilder();
reportBuilder.AppendLine("Daily Sales Report");
reportBuilder.AppendLine("------------------");
reportBuilder.AppendLine("Product A: 150 units");
reportBuilder.AppendLine("Product B: 200 units");

Console.WriteLine(reportBuilder.ToString());
/* Result:
Daily Sales Report
------------------
Product A: 150 units
Product B: 200 units
*/
```

### 

3. `AppendFormat()`: Adicionando Texto Formatado

Adiciona uma string formatada ao final da instância atual do `StringBuilder`, usando a mesma sintaxe de formatação de `string.Format()`.

```CSHARP
StringBuilder messageBuilder = new StringBuilder();
double price = 99.99;
int quantity = 3;

messageBuilder.AppendFormat("Item: {0}, Price: {1:C}, Quantity: {2}", "Laptop", price, quantity);

Console.WriteLine(messageBuilder.ToString()); // Result: Item: Laptop, Price: $99.99, Quantity: 3 (currency symbol depends on culture)
```

### 

4. `Insert()`: Inserindo Texto

Insere uma representação de string de um objeto ou o conteúdo de outra string em uma posição específica dentro da instância atual do `StringBuilder`.

```CSHARP
StringBuilder sentenceBuilder = new StringBuilder("Hello World!");
sentenceBuilder.Insert(6, "Big "); // Insert "Big " at index 6

Console.WriteLine(sentenceBuilder.ToString()); // Result: Hello Big World!
```

### 

5. `Remove()`: Removendo Caracteres

Remove um número especificado de caracteres de uma posição inicial dentro da instância atual do `StringBuilder`.

```CSHARP
StringBuilder dataBuilder = new StringBuilder("This is some temporary data.");
dataBuilder.Remove(8, 10); // Remove 10 characters starting from index 8 ("some tempor")

Console.WriteLine(dataBuilder.ToString()); // Result: This is ary data.
```

### 

6. `Replace()`: Substituindo Texto

Substitui todas as ocorrências de uma substring por outra substring dentro da instância atual do `StringBuilder`.

```CSHARP
StringBuilder textBuilder = new StringBuilder("The quick brown fox jumps over the lazy fox.");
textBuilder.Replace("fox", "dog");

Console.WriteLine(textBuilder.ToString()); // Result: The quick brown dog jumps over the lazy dog.
```

### 

7. `ToString()`: Convertendo para `string`

Converte o conteúdo atual do `StringBuilder` em uma nova instância de `string`. Esta é a etapa final para obter a string imutável que você pode usar em outras partes do seu código ou exibir.

```CSHARP
StringBuilder finalMessageBuilder = new StringBuilder();
finalMessageBuilder.Append("Operation completed successfully.");

string finalResult = finalMessageBuilder.ToString();
Console.WriteLine(finalResult); // Result: Operation completed successfully.
```

## 

Quando usar `StringBuilder` vs. Concatenação de `string`

| Característica |`string` Concatenation (`+`) |`StringBuilder` |
-----------------------------------------------------------------
| Mutabilidade |Imutável (cria nova string a cada modificação) |Mutável (modifica o buffer interno) |
| Performance |Menor para muitas operações (criação de objetos e cópias) |Maior para muitas operações (modifica no lugar) |
| Uso de Memória |Maior (muitas strings intermediárias) |Menor (reutiliza o mesmo buffer) |
| Cenários Ideais |Poucas concatenações, strings pequenas, operações simples |Muitas concatenações, construção de strings em loops, strings grandes, modificações frequentes |

Regra Geral: Se você espera realizar 5 ou mais operações de concatenação ou modificação em uma string, considere usar `StringBuilder`. Para menos que isso, a concatenação simples de `string` pode ser mais legível e o impacto na performance é insignificante.

## Conclusão

`StringBuilder` é uma ferramenta poderosa e essencial no arsenal de qualquer desenvolvedor C# que lida com manipulação de texto. Compreender sua finalidade e saber quando utilizá-lo pode levar a melhorias significativas na performance e no uso de memória de suas aplicações, especialmente em cenários de alta demanda por processamento de strings. Ao dominar o `StringBuilder`, você escreve um código mais eficiente e robusto.



# Kata - Calculadora em C#

Bem-vindo ao nosso primeiro kata prático! Neste exercício, vamos construir uma calculadora simples usando C#. O objetivo é aplicar os conceitos fundamentais que aprendemos, como variáveis, tipos de dados, operadores, condicionais e funções, em um projeto real e funcional.

Este tutorial é voltado para iniciantes e explicará cada parte do código detalhadamente.

## O Código Completo

Aqui está o código completo do nosso arquivo `Program.cs`. Vamos analisá-lo passo a passo.

```
using System;

namespace Calculator
{
  class Program
  {
    static void Main(string[] args)
    {
      Menu();
    }

    static void Menu()
    {
      Console.Clear();
      
      Console.WriteLine("O QUE DESEJA FAZER?");
      Console.WriteLine("---------------------");
      Console.WriteLine("1 - Soma");
      Console.WriteLine("2 - Subtração");
      Console.WriteLine("3 - Divisão");
      Console.WriteLine("4 - Multiplicação");
      Console.WriteLine("5 - Sair");

      Console.WriteLine("---------=-=-=-=-=--");
      Console.WriteLine("SELECIONE UMA OPÇÃO > ");
      short res = short.Parse(Console.ReadLine());
      
      switch(res)
      {
        case 1:
          Sum(); break;
        case 2:
          Subtraction(); break;
        case 3:
          Division(); break;
        case 4:
          Multiplication(); break;
        case 5:
          System.Environment.Exit(0);
          break;
        default:
          Menu();
          break;
      }
    }

    static void Sum()
    {
      Console.Clear();

      Console.WriteLine("First value: ");
      double v1 = double.Parse(Console.ReadLine());

      Console.WriteLine("Second value: ");
      double v2 = double.Parse(Console.ReadLine());

      double result = v1 + v2;

      Console.Clear();

      Console.WriteLine(" ========= Result ========");
      Console.WriteLine($" {v1} + {v2}  =  {result}");
      Console.ReadKey();
      Menu();
    }

    static void Subtraction()
    {
      Console.Clear();

      Console.WriteLine("First value: ");
      double v1 = double.Parse(Console.ReadLine());

      Console.WriteLine("Second value: ");
      double v2 = double.Parse(Console.ReadLine());

      double result = v1 - v2;

      Console.Clear();
      Console.WriteLine(" ========= Result ========");
      Console.WriteLine($" {v1} - {v2}  =  {result}");
      Console.ReadKey();
      Menu();
    }

    static void Division()
    {
      Console.Clear();

      Console.WriteLine("First value: ");
      double v1 = double.Parse(Console.ReadLine());

      Console.WriteLine("Second value: ");
      double v2 = double.Parse(Console.ReadLine());

      double result = v1 / v2;

      Console.Clear();
      Console.WriteLine(" ========= Result ========");
      Console.WriteLine($" {v1} / {v2}  =  {result}");
      Console.ReadKey();
      Menu();
    }

    static void Multiplication()
    {
      Console.Clear();
      Console.WriteLine("First value: ");
      double v1 = double.Parse(Console.ReadLine());

      Console.WriteLine("Second value: ");
      double v2 = double.Parse(Console.ReadLine());

      double result = v1 * v2;

      Console.Clear();
      Console.WriteLine(" ========= Result ========");
      Console.WriteLine($" {v1} x {v2}  =  {result}");
      Console.ReadKey();
      Menu();
    }
  }
}
```

## Análise do Código

### Estrutura Básica

* `using System;`: Esta linha importa o namespace `System`, que contém classes fundamentais e tipos de dados que usamos em quase todos os programas C#, como `Console`, `String`, `Double`, etc.

* `namespace Calculator`: Um `namespace` é usado para organizar o código e evitar conflitos de nomes. Aqui, estamos criando um namespace chamado `Calculator` para o nosso projeto.

* `class Program`: Em C#, todo o código executável deve estar dentro de uma classe. A classe `Program` é o contêiner principal para o nosso código.

* `static void Main(string[] args)`: Este é o ponto de entrada do nosso programa. Quando o aplicativo é executado, o método `Main` é o primeiro a ser chamado. * `static`: Significa que o método pertence à classe `Program` e não a uma instância específica dela. * `void`: Indica que o método não retorna nenhum valor. * `string[] args`: É um array de strings que pode ser usado para passar argumentos de linha de comando para o programa (não estamos usando neste kata).

### 

O Menu Principal (`Menu` function)

O coração da nossa aplicação é a função `Menu`. Ela é responsável por interagir com o usuário.

```
static void Menu()
{
  Console.Clear();
  
  Console.WriteLine("O QUE DESEJA FAZER?");
  // ... (outras opções)

  Console.WriteLine("SELECIONE UMA OPÇÃO > ");
  short res = short.Parse(Console.ReadLine());
  
  switch(res)
  {
    // ...
  }
}
```

1. `Console.Clear()`: Limpa a tela do console, proporcionando uma interface mais limpa a cada vez que o menu é exibido.

2. `Console.WriteLine(...)`: Exibe as opções disponíveis para o usuário.

3. `Console.ReadLine()`: Lê a entrada do usuário a partir do console. O valor lido é sempre uma `string`.

4. `short.Parse(...)`: Como `ReadLine` retorna uma `string`, precisamos convertê-la para um tipo numérico para podermos usá-la em nossa lógica. `short.Parse` converte a string de entrada em um `short` (um tipo de número inteiro).

5. `switch(res)`: A estrutura `switch` é uma forma de controle de fluxo que permite executar diferentes blocos de código com base no valor de uma variável. É uma alternativa mais limpa a múltiplos `if-else if`.

* `case X:`: Cada `case` corresponde a um valor possível da variável `res`. Se `res` for `1`, o código dentro de `case 1:` será executado.

* `break;`: A palavra-chave `break` é usada para sair do `switch` após a execução de um `case`.

* `default:`: Se o valor de `res` não corresponder a nenhum dos `case`, o bloco `default` será executado. Em nosso caso, ele simplesmente chama o `Menu()` novamente.

* `System.Environment.Exit(0);`: No `case 5`, usamos este comando para encerrar a aplicação. O `0` indica que o programa terminou com sucesso.

### Funções de Operação (Sum, Subtraction, etc.)

Todas as funções de operação seguem um padrão semelhante. Vamos analisar a função `Sum()`:

```
static void Sum()
{
  Console.Clear();

  Console.WriteLine("First value: ");
  double v1 = double.Parse(Console.ReadLine());

  Console.WriteLine("Second value: ");
  double v2 = double.Parse(Console.ReadLine());

  double result = v1 + v2;

  Console.Clear();

  Console.WriteLine(" ========= Result ========");
  Console.WriteLine($" {v1} + {v2}  =  {result}");
  Console.ReadKey();
  Menu();
}
```

1. `Console.Clear()`: Limpa a tela para a nova "página" da operação.

2. `double.Parse(Console.ReadLine())`: Novamente, lemos a entrada do usuário e a convertemos. Desta vez, usamos `double.Parse` porque queremos trabalhar com números que podem ter casas decimais.

3. `double result = v1 + v2;`: Aqui está a lógica principal da função. Realizamos a soma dos dois números e armazenamos o resultado na variável `result`.

4. `Console.WriteLine($" {v1} + {v2}  =  {result}");`: Esta é uma string interpolada. O `$` no início da string nos permite incorporar variáveis diretamente no texto usando chaves `{}`. É uma forma moderna e legível de formatar strings.

5. `Console.ReadKey()`: Pausa a execução do programa e espera que o usuário pressione qualquer tecla. Isso é útil para que o usuário possa ver o resultado antes que o programa limpe a tela e volte ao menu.

6. `Menu()`: Após a operação ser concluída e o usuário pressionar uma tecla, chamamos a função `Menu()` novamente, criando um loop que permite ao usuário realizar outra operação ou sair.

## Conceitos-Chave Aplicados

* Funções: Organizamos nosso código em funções reutilizáveis (`Menu`, `Sum`, `Subtraction`, etc.), tornando o código mais limpo e fácil de manter.

* Tipos de Dados: Usamos `short` para a opção do menu e `double` para os valores dos cálculos, escolhendo os tipos apropriados para cada tarefa.

* Conversão de Tipos (Parsing): Convertemos a entrada do usuário de `string` para tipos numéricos usando `short.Parse` and `double.Parse`.

* Controle de Fluxo: Usamos a estrutura `switch` para tomar decisões com base na entrada do usuário.

* Entrada e Saída: Utilizamos a classe `Console` para interagir com o usuário, exibindo informações (`WriteLine`) e lendo dados (`ReadLine`).

* Recursão (Leve): A função `Menu` chama a si mesma no `default` do `switch`, e as funções de operação chamam `Menu` no final. Isso cria um ciclo de vida para a aplicação.

## Desafios para Expansão

Agora que você entende o código, aqui estão alguns desafios para você tentar:

1. Adicionar Potenciação: Crie uma nova opção no menu e uma função `Power()` que calcula `v1` elevado a `v2`. (Dica: você pode usar `Math.Pow(v1, v2)`).

2. Tratamento de Erros: O que acontece se o usuário digitar "abc" em vez de um número? O programa irá quebrar. Pesquise sobre `try-catch` em C# para lidar com essas exceções e exibir uma mensagem de erro amigável.

3. Raiz Quadrada: Adicione uma opção para calcular a raiz quadrada de um número. (Dica: `Math.Sqrt(v1)`).

4. Histórico de Operações: Como você poderia armazenar e exibir as últimas 5 operações que o usuário realizou?

Parabéns por concluir este kata! Você deu um passo importante na sua jornada de aprendizado de C#.



# Kata - Conversor de Tipos via Linha de Comando

Neste kata, vamos explorar um caso de uso um pouco mais avançado: a criação de uma ferramenta de linha de comando (CLI) em C#. Esta aplicação irá converter um valor de um tipo de dado para outro, com base nos argumentos fornecidos pelo usuário ao executar o programa.

Vamos abordar conceitos como manipulação de argumentos de linha de comando, dicionários para armazenar parâmetros, tratamento de erros robusto com `try-catch` e a diferença crucial entre `Parse` e `Convert`.

## O Código Completo

Este é o código do nosso `Program.cs`. Ele é projetado para ser executado via `dotnet run` com parâmetros específicos.

```
using System;
using System.Collections.Generic;

namespace AtividadeSemana1
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                ShowHelp();
                return;
            }

            var parameters = ParseArguments(args);

            if (!ValidateParameters(parameters))
            {
                Console.WriteLine("Erro: Parametros 'valor', 'tipoEntrada' e 'tipoSaida' sao obrigatorios.");
                Console.WriteLine("Uso: dotnet run valor=<valor> tipoEntrada=<tipo> tipoSaida=<tipo>");
                return;
            }

            string valorStr = parameters["valor"];
            string tipoEntrada = parameters["tipoentrada"].ToLower();
            string tipoSaida = parameters["tiposaida"].ToLower();

            try
            {
                object valorEntrada = ParseInputValue(valorStr, tipoEntrada);
                object valorSaida = ConvertValue(valorEntrada, tipoSaida, valorStr);
                PrintResult(valorStr, tipoEntrada, valorSaida, tipoSaida);
            }
            catch (ArgumentException ex)
            {
                Console.WriteLine($"Erro: {ex.Message}");
            }
            catch (InvalidCastException ex)
            {
                Console.WriteLine($"Erro de conversao: {ex.Message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ocorreu um erro inesperado: {ex.Message}");
            }
        }

        static void ShowHelp()
        {
            Console.WriteLine("=== Conversor de Tipos ===");
            Console.WriteLine("Por favor, forneca os parametros no formato chave=valor.");
            Console.WriteLine("Uso: dotnet run valor=<valor> tipoEntrada=<tipo> tipoSaida=<tipo>");
            Console.WriteLine("Exemplo: dotnet run valor=123.45 tipoEntrada=double tipoSaida=int");
            Console.WriteLine("Tipos suportados: int, double, float, bool, string, short");
        }

        static Dictionary<string, string> ParseArguments(string[] args)
        {
            var parameters = new Dictionary<string, string>();
            foreach (var arg in args)
            {
                var parts = arg.Split('=', 2);
                if (parts.Length == 2)
                {
                    parameters[parts[0].ToLower()] = parts[1];
                }
            }
            return parameters;
        }

        static bool ValidateParameters(Dictionary<string, string> parameters)
        {
            return parameters.ContainsKey("valor") &&
                   parameters.ContainsKey("tipoentrada") &&
                   parameters.ContainsKey("tiposaida");
        }

        
        static object ParseInputValue(string valorStr, string tipoEntrada)
        {
            try
            {
                return tipoEntrada switch
                {
                    "int" => int.Parse(valorStr),
                    "double" => double.Parse(valorStr),
                    "float" => float.Parse(valorStr),
                    "bool" => bool.Parse(valorStr),
                    "string" => valorStr,
                    "short" => short.Parse(valorStr),
                    _ => throw new ArgumentException($"Tipo de entrada desconhecido: {tipoEntrada}")
                };
            }
            catch (Exception ex)
            {
                throw new ArgumentException($"Ao processar o valor de entrada '{valorStr}': {ex.Message}", ex);
            }
        }

        static object ConvertValue(object valorEntrada, string tipoSaida, string valorStr)
        {
            try
            {
                return tipoSaida switch
                {
                    "int" => Convert.ToInt32(valorEntrada),
                    "double" => Convert.ToDouble(valorEntrada),
                    "float" => Convert.ToSingle(valorEntrada),
                    "bool" => Convert.ToBoolean(valorEntrada),
                    "string" => Convert.ToString(valorEntrada),
                    "short" => Convert.ToInt16(valorEntrada),
                    _ => throw new ArgumentException($"Tipo de saida desconhecido: {tipoSaida}")
                };
            }
            catch (Exception ex)
            {
                throw new InvalidCastException($"Nao foi possivel converter '{valorStr}' ({valorEntrada.GetType().Name}) para {tipoSaida}: {ex.Message}", ex);
            }
        }

        static void PrintResult(string valorStr, string tipoEntrada, object valorSaida, string tipoSaida)
        {
            Console.WriteLine("=== Resultado da Conversao ===" elytra.platform.documentation.core.content.format.MarkdownFile@527144b2);
            Console.WriteLine($"Entrada: [{valorStr}] ({tipoEntrada})");
            Console.WriteLine($"Saida:   [{valorSaida}] ({tipoSaida})");
        }
    }
}
```

## Análise do Código

### 

`Main`: O Ponto de Entrada e Orquestrador

O método `Main` agora tem mais responsabilidades:

1. Verificar Argumentos: `if (args.Length == 0)` checa se o programa foi executado sem nenhum argumento. Se for o caso, exibe uma mensagem de ajuda (`ShowHelp()`) e encerra.

2. Analisar Argumentos: `ParseArguments(args)` é chamado para processar os argumentos da linha de comando.

3. Validar Parâmetros: `ValidateParameters(parameters)` garante que todos os parâmetros necessários (`valor`, `tipoEntrada`, `tipoSaida`) foram fornecidos.

4. Executar a Conversão: O bloco `try-catch` é o núcleo da lógica. Ele tenta analisar o valor de entrada, convertê-lo para o tipo de saída e imprimir o resultado. Se qualquer etapa falhar, uma exceção é capturada e uma mensagem de erro é exibida.

### 

`ParseArguments`: Processando a Entrada do Usuário

```
static Dictionary<string, string> ParseArguments(string[] args)
{
    var parameters = new Dictionary<string, string>();
    foreach (var arg in args)
    {
        var parts = arg.Split('=', 2);
        if (parts.Length == 2)
        {
            parameters[parts[0].ToLower()] = parts[1];
        }
    }
    return parameters;
}
```

Esta função transforma um array de strings como `["valor=123", "tipoEntrada=int"]` em um `Dictionary<string, string>`. Um dicionário é uma coleção de pares chave-valor.

* `arg.Split('=', 2)`: Divide cada argumento no caractere `=`, no máximo em 2 partes. Isso garante que, se o valor contiver um `=`, ele não será dividido novamente (ex: `valor=chave=valor`).

* `parameters[parts[0].ToLower()] = parts[1]`: Adiciona a chave (em minúsculas) e o valor ao dicionário.

### 

`ParseInputValue` vs. `ConvertValue`

O programa usa duas funções distintas para a conversão, e a diferença é fundamental:

1. `ParseInputValue`: Usa métodos como `int.Parse(string)`. O objetivo do `Parse` é converter uma representação em string de um valor para o seu tipo de dado correspondente. Ele só funciona de `string` para outro tipo.

2. `ConvertValue`: Usa a classe `Convert`, com métodos como `Convert.ToInt32(object)`. A classe `Convert` é mais flexível. Ela pode converter um valor de qualquer tipo base para outro tipo, desde que uma conversão válida exista. Por exemplo, pode converter um `double` para um `int`, um `bool` para uma `string`, etc.

Em nosso fluxo, primeiro usamos `Parse` para tirar o valor da `string` inicial e, em seguida, usamos `Convert` para realizar a conversão entre os tipos de dados reais (ex: de `double` para `int`).

Ambas as funções usam uma expressão `switch` (uma forma mais concisa do `switch` tradicional) para selecionar a operação correta com base no tipo de entrada/saída.

### 

Tratamento de Erros (`try-catch`)

Este programa é muito mais robusto que a calculadora porque ele antecipa falhas.

* `try { ... }`: O código que pode gerar um erro é colocado dentro do bloco `try`.

* `catch (ArgumentException ex)`: Captura erros relacionados a argumentos inválidos, como um tipo de entrada/saída desconhecido.

* `catch (InvalidCastException ex)`: Captura erros que ocorrem quando a conversão entre dois tipos não é possível (por exemplo, converter a string `"abc"` para `int`).

* `catch (Exception ex)`: Uma cláusula genérica que captura qualquer outro erro inesperado, evitando que o programa "quebre" abruptamente.

## Conceitos-Chave Aplicados

* Argumentos de Linha de Comando: Leitura e processamento de `string[] args` no método `Main`.

* Dicionários (`Dictionary<TKey, TValue>`): Uma estrutura de dados poderosa para armazenar e acessar dados por meio de uma chave única.

* Tratamento de Exceções: Uso de `try-catch` para criar um programa resiliente que lida com entradas inválidas e erros de conversão.

* Expressões `switch`: Uma sintaxe moderna e concisa para controle de fluxo.

* Diferença entre `Parse` e `Convert`: Compreensão de duas maneiras fundamentais de realizar conversões de tipo em C#.

## Como Executar

Para testar este programa, você o executaria a partir do seu terminal, na pasta do projeto, da seguinte forma:

```BASH
# Exemplo 1: Convertendo um double para um int
dotnet run valor=123.45 tipoEntrada=double tipoSaida=int

# Exemplo 2: Convertendo uma string para um booleano
dotnet run valor=true tipoEntrada=string tipoSaida=bool

# Exemplo de erro
dotnet run valor=texto tipoEntrada=string tipoSaida=int
```

Este kata demonstra como construir aplicações de console interativas e robustas, um pilar fundamental da programação em muitas linguagens, incluindo C#.



# Kata - Editor de Texto Simples de Console

Neste kata, construiremos uma aplicação de console fundamental: um editor de texto simples. Este projeto nos permitirá explorar a manipulação de arquivos em C#, uma habilidade essencial para qualquer desenvolvedor. A aplicação será capaz de criar, salvar e abrir arquivos de texto diretamente do terminal.

Vamos focar em conceitos como entrada e saída do console, leitura e escrita de arquivos com `StreamReader` and `StreamWriter`, e a importância do bloco `using` para gerenciar recursos de forma segura.

## O Código Completo

Este é o código do nosso `Program.cs`. Ele estrutura o editor de texto em um menu interativo.

```
using System;
using System.IO;

namespace TextEditor
{
  public class Program
  {
    public static void Main(string[] args)
    {
      Menu();
    }

    static void Menu()
    {
      Console.Clear();
      Console.WriteLine("O que voce deseja fazer?");
      Console.WriteLine("1 - Abrir arquivo");
      Console.WriteLine("2 - Criar novo arquivo");
      Console.WriteLine("0 - Sair");
      short option = short.Parse(Console.ReadLine());

      switch (option)
      {
        case 0:
          System.Environment.Exit(0);
          break;
        case 1:
          Open();
          break;
        case 2:
          Edit();
          break;
        default:
          Menu();
          break;
      }
    }

    private static void Open()
    {
      Console.Clear();
      Console.WriteLine("Qual caminho do arquivo?");
      string path = Console.ReadLine();

      using (var file = new StreamReader(path))
      {
        string text = file.ReadToEnd();
        Console.WriteLine(text);
      }
      
      Console.WriteLine("");
      Console.ReadLine();
      Menu();
    }

    private static void Edit()
    {
      Console.Clear();
      Console.WriteLine("Digite seu texto abaixo (ESC para sair)");
      Console.WriteLine("--------------------------------");

      string text = "";

      do
      {
        text += Console.ReadLine();
        text += Environment.NewLine;
      } while (Console.ReadKey().Key != ConsoleKey.Escape);
      
      Save(text);
    }
    
    static void Save(string text) 
    {
      Console.Clear();
      Console.WriteLine("Qual caminho para salvar o arquivo? \n");
      var path = Console.ReadLine();
      
      
      // CRIA E JÁ FECHA O OBJETO - É BOM PARA HANDLER COM ARQUIVOS
      using (var file = new StreamWriter(path ?? string.Empty))
      {
        file.Write(text);
      }

      Console.WriteLine($"Arquivo salvo em {path} com sucesso!");
      Console.ReadLine(); 
      Menu();
    }
  }
}
```

## Análise do Código

### 

`Main` e `Menu`: Navegação Central

O ponto de entrada `Main` simplesmente chama o método `Menu`, que atua como o coração da nossa aplicação.

* `Console.Clear()`: Limpa a tela do console para uma apresentação mais limpa.

* Loop de Menu: O `Menu` exibe as opções, lê a entrada do usuário com `Console.ReadLine()` e usa uma instrução `switch` para direcionar o fluxo do programa. Note que, após cada ação (`Open`, `Edit`), o `Menu` é chamado novamente, criando um loop que mantém a aplicação em execução até que o usuário escolha sair.

* Saída Segura: `System.Environment.Exit(0)` é usado para encerrar a aplicação de forma limpa quando o usuário digita '0'.

### 

`Open`: Lendo Arquivos

```
private static void Open()
{
    // ...
    string path = Console.ReadLine();

    using (var file = new StreamReader(path))
    {
        string text = file.ReadToEnd();
        Console.WriteLine(text);
    }
    // ...
}
```

Esta função é responsável por abrir e exibir o conteúdo de um arquivo de texto.

* `StreamReader`: Esta classe do `System.IO` é projetada para ler caracteres de um fluxo (neste caso, um arquivo).

* Bloco `using`: Este é um dos conceitos mais importantes aqui. O `using` garante que o objeto `file` (que representa o arquivo no sistema operacional) seja "descartado" (`Dispose`) corretamente, mesmo que ocorram erros. Isso significa que o arquivo será fechado, liberando o recurso para outros programas. É a maneira padrão e segura de trabalhar com recursos como arquivos e conexões de rede.

* `ReadToEnd()`: Lê todo o conteúdo do arquivo, do início ao fim, e o retorna como uma única `string`.

### 

`Edit` e `Save`: Criando e Escrevendo em Arquivos

O processo de criação é dividido em duas partes: `Edit` para capturar a entrada e `Save` para escrevê-la no disco.

```
private static void Edit()
{
    // ...
    string text = "";
    do
    {
        text += Console.ReadLine();
        text += Environment.NewLine;
    } while (Console.ReadKey().Key != ConsoleKey.Escape);
    
    Save(text);
}
```

* Captura de Múltiplas Linhas: O loop `do-while` é uma forma inteligente de capturar texto. Ele continua adicionando linhas à variável `text` até que a tecla `ESC` seja pressionada. `Console.ReadKey()` intercepta a próxima tecla pressionada sem exigir que o usuário pressione Enter.

* `Environment.NewLine`: Garante que as quebras de linha sejam corretas para o sistema operacional em que o programa está sendo executado (seja `\n` no Linux/macOS ou `\r\n` no Windows).

```
static void Save(string text) 
{
    // ...
    var path = Console.ReadLine();
    
    using (var file = new StreamWriter(path ?? string.Empty))
    {
        file.Write(text);
    }
    // ...
}
```

* `StreamWriter`: O oposto do `StreamReader`, esta classe é usada para escrever strings em um fluxo/arquivo. Se o arquivo não existir no `path` especificado, ele será criado. Se já existir, seu conteúdo será sobrescrito.

* Segurança com `using`: Assim como no `Open`, o `using` garante que o arquivo seja fechado e salvo corretamente após a escrita.

## Conceitos-Chave Aplicados

* Entrada e Saída do Console: Uso intensivo de `Console.WriteLine`, `Console.ReadLine` e `Console.ReadKey` para criar uma interface de usuário interativa.

* Manipulação de Arquivos (`System.IO`): Utilização das classes `StreamReader` e `StreamWriter` para operações de leitura e escrita em arquivos.

* Gerenciamento de Recursos com `using`: Aplicação da instrução `using` para garantir que os recursos do sistema (arquivos) sejam liberados de forma segura e automática.

* Estruturas de Controle: Uso de `switch` para navegação no menu e `do-while` para captura de entrada de texto.

* Tratamento de Strings: Concatenação de strings para construir o conteúdo do arquivo e uso de `Environment.NewLine` para compatibilidade entre sistemas operacionais.

## Como Executar

Para testar este programa, você precisa navegar até a pasta do projeto no seu terminal e usar o comando `dotnet run`:

```BASH
# Navegue até o diretório do projeto
cd projects/TextEditor/TextEditor

# Execute a aplicação
dotnet run
```

A partir daí, o menu interativo irá guiá-lo para criar, abrir ou salvar seus arquivos de texto.



# References

This page contains a curated list of high-quality resources for learning and mastering C# and the .NET ecosystem.

## Official Documentation

* Microsoft C# Docs: The official and most comprehensive source for C# documentation. It includes tutorials, language references, and how-to guides. * [C# Documentation Home](https://docs.microsoft.com/en-us/dotnet/csharp/) * [C# Language Reference](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/) * [.NET Documentation](https://docs.microsoft.com/en-us/dotnet/)

## Books

* C# in Depth by Jon Skeet: An essential book for intermediate to advanced developers looking to understand the nuances of the C# language and its evolution.

## Online Courses & Tutorials

* Microsoft Learn: An interactive platform with free tutorials and learning paths for C#, .NET, and Azure. * [Take your first steps with C#](https://learn.microsoft.com/en-us/training/paths/csharp-first-steps/)

## Community & Code

* .NET Foundation: An independent organization to foster open development and collaboration around the .NET ecosystem. * [Official Website](https://dotnetfoundation.org/)

* .NET Source Code: Browsing the source code of the .NET runtime and libraries is an excellent way to learn how things work under the hood. * [dotnet/runtime on GitHub](https://github.com/dotnet/runtime)



