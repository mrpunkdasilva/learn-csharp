<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#214C69"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-08-28T15:07:24.665808792"><title>Tipos Complexos | Learn C#</title><script type="application/json" id="virtual-toc-data">[{"id":"a-divis-o-fundamental-valor-vs-refer-ncia","level":0,"title":"A Divisão Fundamental: Valor vs. Referência","anchor":"#a-divis-o-fundamental-valor-vs-refer-ncia"},{"id":"tipos-de-valor-em-detalhe","level":0,"title":"Tipos de Valor em Detalhe","anchor":"#tipos-de-valor-em-detalhe"},{"id":"tipos-de-refer-ncia-em-detalhe","level":0,"title":"Tipos de Referência em Detalhe","anchor":"#tipos-de-refer-ncia-em-detalhe"},{"id":"o-problema-da-obsess-o-primitiva-primitive-obsession","level":0,"title":"O Problema da \"Obsessão Primitiva\" (Primitive Obsession)","anchor":"#o-problema-da-obsess-o-primitiva-primitive-obsession"},{"id":"record-uma-alternativa-moderna-para-imutabilidade","level":0,"title":"record: Uma Alternativa Moderna para Imutabilidade","anchor":"#record-uma-alternativa-moderna-para-imutabilidade"},{"id":"tabela-resumo-class-vs-struct","level":0,"title":"Tabela Resumo: class vs. struct","anchor":"#tabela-resumo-class-vs-struct"},{"id":"refer-ncias-oficiais-da-microsoft","level":0,"title":"Referências Oficiais da Microsoft","anchor":"#refer-ncias-oficiais-da-microsoft"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Tipos Complexos | Learn C#"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Learn C# Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/complextypes.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Tipos Complexos | Learn C#"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/complextypes.html#webpage",
    "url": "writerside-documentation/complextypes.html",
    "name": "Tipos Complexos | Learn C#",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Learn C# Help"
}</script><!-- End Schema.org --></head><body data-id="ComplexTypes" data-main-title="Tipos Complexos" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="OPP.md|O Paradigma da Programação Orientada a Objetos (POO)"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Learn C#  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ComplexTypes" id="ComplexTypes.md">Tipos Complexos</h1><p id="-4bgny_3">Enquanto os <span id="-4bgny_15">tipos primitivos</span> (como <code class="code" id="-4bgny_16">int</code>, <code class="code" id="-4bgny_17">bool</code>, <code class="code" id="-4bgny_18">double</code>) representam valores &uacute;nicos e simples, a verdadeira for&ccedil;a de uma linguagem orientada a objetos como o C# reside na capacidade de criar <span class="control" id="-4bgny_19">Tipos Complexos</span>. Estes s&atilde;o tipos de dados que n&oacute;s, desenvolvedores, definimos para modelar os conceitos do mundo real, como um <code class="code" id="-4bgny_20">Cliente</code>, um <code class="code" id="-4bgny_21">Pedido</code> ou um <code class="code" id="-4bgny_22">Produto</code>.</p><p id="-4bgny_4">Um tipo complexo &eacute; uma estrutura de dados que agrupa m&uacute;ltiplos valores (sejam eles primitivos ou outros tipos complexos) e, crucialmente, pode conter <span class="control" id="-4bgny_23">comportamento</span> associado a esses dados (atrav&eacute;s de m&eacute;todos).</p><aside class="prompt" data-type="tip" data-title="" id="-4bgny_5"><p id="-4bgny_24"><span class="control" id="-4bgny_25">Disserta&ccedil;&atilde;o</span>: O salto dos tipos primitivos para os complexos &eacute; o que nos permite passar de simples c&aacute;lculos para a cria&ccedil;&atilde;o de <span class="control" id="-4bgny_26">modelos de dom&iacute;nio</span> ricos e expressivos. Em vez de trabalhar com um emaranhado de n&uacute;meros e textos soltos, come&ccedil;amos a trabalhar com <code class="code" id="-4bgny_27">Faturas</code> que sabem como se calcular, com <code class="code" id="-4bgny_28">Usu&aacute;rios</code> que sabem como se validar e com <code class="code" id="-4bgny_29">Ve&iacute;culos</code> que sabem como se mover. A cria&ccedil;&atilde;o de tipos complexos &eacute; a ess&ecirc;ncia de traduzir um problema de neg&oacute;cio em c&oacute;digo robusto, compreens&iacute;vel e de f&aacute;cil manuten&ccedil;&atilde;o.</p></aside><p id="-4bgny_6">No C#, os tipos complexos se dividem em duas categorias fundamentais, cuja compreens&atilde;o &eacute; absolutamente cr&iacute;tica: <span class="control" id="-4bgny_30">Tipos de Valor</span> (<span class="emphasis" id="-4bgny_31">Value Types</span>) e <span class="control" id="-4bgny_32">Tipos de Refer&ecirc;ncia</span> (<span class="emphasis" id="-4bgny_33">Reference Types</span>).</p><section class="chapter"><h2 id="a-divis-o-fundamental-valor-vs-refer-ncia" data-toc="a-divis-o-fundamental-valor-vs-refer-ncia">A Divis&atilde;o Fundamental: Valor vs. Refer&ecirc;ncia</h2><p id="-4bgny_34">A diferen&ccedil;a entre tipos de valor e de refer&ecirc;ncia est&aacute; em <span class="control" id="-4bgny_37">onde e como</span> seus dados s&atilde;o armazenados na mem&oacute;ria.</p><ul class="list _bullet" id="-4bgny_35"><li class="list__item" id="-4bgny_38"><p id="-4bgny_40"><span class="control" id="-4bgny_41">Tipos de Valor (<code class="code" id="-4bgny_45">struct</code>, <code class="code" id="-4bgny_46">enum</code>)</span>: Uma vari&aacute;vel de um tipo de valor cont&eacute;m <span class="control" id="-4bgny_42">diretamente</span> seus dados. Quando voc&ecirc; atribui uma vari&aacute;vel de valor a outra, o valor &eacute; <span class="control" id="-4bgny_43">copiado</span>. Elas geralmente vivem em uma &aacute;rea da mem&oacute;ria chamada <span class="control" id="-4bgny_44">Stack (Pilha)</span>, que &eacute; muito r&aacute;pida e gerenciada de forma eficiente.</p></li><li class="list__item" id="-4bgny_39"><p id="-4bgny_47"><span class="control" id="-4bgny_48">Tipos de Refer&ecirc;ncia (<code class="code" id="-4bgny_54">class</code>, <code class="code" id="-4bgny_55">record</code>, <code class="code" id="-4bgny_56">string</code>, arrays)</span>: Uma vari&aacute;vel de um tipo de refer&ecirc;ncia <span class="control" id="-4bgny_49">n&atilde;o</span> cont&eacute;m o objeto em si. Em vez disso, ela cont&eacute;m uma <span class="control" id="-4bgny_50">refer&ecirc;ncia</span> (um endere&ccedil;o, como um ponteiro) para o local na mem&oacute;ria onde o objeto real est&aacute; armazenado. O objeto em si vive em uma &aacute;rea da mem&oacute;ria chamada <span class="control" id="-4bgny_51">Heap (Monte)</span>. Quando voc&ecirc; atribui uma vari&aacute;vel de refer&ecirc;ncia a outra, apenas a <span class="control" id="-4bgny_52">refer&ecirc;ncia &eacute; copiada</span>, n&atilde;o o objeto. Ambas as vari&aacute;veis passam a apontar para o <span class="control" id="-4bgny_53">mesmo objeto</span>.</p></li></ul><section class="chapter"><h3 id="diagrama-de-mem-ria-stack-vs-heap" data-toc="diagrama-de-mem-ria-stack-vs-heap">Diagrama de Mem&oacute;ria: Stack vs. Heap</h3><p id="-4bgny_57">Este diagrama visualiza a diferen&ccedil;a. <code class="code" id="-4bgny_60">myPoint</code> (um <code class="code" id="-4bgny_61">struct</code>) vive inteiramente na Stack. <code class="code" id="-4bgny_62">myCustomer</code> (uma <code class="code" id="-4bgny_63">class</code>) &eacute; apenas um ponteiro na Stack que aponta para o objeto real no Heap.</p></section></section><section class="chapter"><h2 id="tipos-de-valor-em-detalhe" data-toc="tipos-de-valor-em-detalhe">Tipos de Valor em Detalhe</h2><section class="chapter"><h3 id="struct-criando-tipos-de-valor-leves" data-toc="struct-criando-tipos-de-valor-leves"><code class="code" id="-4bgny_70">struct</code>: Criando Tipos de Valor Leves</h3><p id="-4bgny_67">Um <code class="code" id="-4bgny_71">struct</code> &eacute; ideal para representar pequenos grupos de dados que t&ecirc;m sem&acirc;ntica de valor, ou seja, onde a identidade do objeto n&atilde;o importa tanto quanto seus valores. Pense em um ponto, uma cor ou uma quantia monet&aacute;ria.</p><ul class="list _bullet" id="-4bgny_68"><li class="list__item" id="-4bgny_72"><p id="-4bgny_73"><span class="control" id="-4bgny_74">Analogia</span>: Um <code class="code" id="-4bgny_75">struct</code> &eacute; como uma nota autoadesiva (Post-it&reg;). Se voc&ecirc; tem uma nota com &quot;Comprar p&atilde;o&quot; e a copia para outra nota, agora voc&ecirc; tem duas notas independentes. Amassar ou rasgar uma n&atilde;o afeta a outra.</p></li></ul><section class="chapter"><h4 id="exemplo-pr-tico-modelando-dinheiro" data-toc="exemplo-pr-tico-modelando-dinheiro">Exemplo Pr&aacute;tico: Modelando Dinheiro</h4><div class="code-block" data-lang="csharp">
// A struct is a value type. When you copy it, you get a new independent instance.
public struct Money
{
    public decimal Amount { get; }
    public string Currency { get; }

    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }
}

public void TestValueTypeCopy()
{
    var price1 = new Money(100, &quot;USD&quot;);
    var price2 = price1; // The entire content of price1 is COPIED into price2.

    // Because they are independent copies, changing one does not affect the other.
    // (Note: Money is immutable here, but if it were mutable, this would be the behavior).
}
</div></section></section><section class="chapter"><h3 id="enum-para-constantes-nomeadas" data-toc="enum-para-constantes-nomeadas"><code class="code" id="-4bgny_82">enum</code>: Para Constantes Nomeadas</h3><p id="-4bgny_78">Um <code class="code" id="-4bgny_83">enum</code> (enumera&ccedil;&atilde;o) &eacute; um tipo de valor especial que permite definir um conjunto de constantes nomeadas, melhorando a legibilidade do c&oacute;digo.</p><ul class="list _bullet" id="-4bgny_79"><li class="list__item" id="-4bgny_84"><p id="-4bgny_85"><span class="control" id="-4bgny_86">Analogia</span>: Os naipes de um baralho (Copas, Ouros, Paus, Espadas) ou os dias da semana. S&atilde;o um conjunto finito e bem conhecido de op&ccedil;&otilde;es.</p></li></ul><div class="code-block" data-lang="csharp">
// Using an enum makes the code much more readable than using numbers (0, 1, 2, 3).
public enum OrderStatus
{
    Pending,
    Processing,
    Shipped,
    Delivered,
    Cancelled
}

public class Order
{
    public int Id { get; set; }
    public OrderStatus Status { get; set; }

    public void Ship()
    {
        if (Status == OrderStatus.Processing)
        {
            Status = OrderStatus.Shipped;
            // ... logic to ship the order
        }
    }
}
</div></section></section><section class="chapter"><h2 id="tipos-de-refer-ncia-em-detalhe" data-toc="tipos-de-refer-ncia-em-detalhe">Tipos de Refer&ecirc;ncia em Detalhe</h2><section class="chapter"><h3 id="class-a-espinha-dorsal-da-oop" data-toc="class-a-espinha-dorsal-da-oop"><code class="code" id="-4bgny_92">class</code>: A Espinha Dorsal da OOP</h3><p id="-4bgny_89">Uma <code class="code" id="-4bgny_93">class</code> &eacute; o bloco de constru&ccedil;&atilde;o mais comum para tipos de refer&ecirc;ncia. &Eacute; usada para modelar entidades complexas que t&ecirc;m identidade, estado (que pode mudar ao longo do tempo) e comportamento.</p><ul class="list _bullet" id="-4bgny_90"><li class="list__item" id="-4bgny_94"><p id="-4bgny_95"><span class="control" id="-4bgny_96">Analogia</span>: Uma <code class="code" id="-4bgny_97">class</code> &eacute; como um link para um documento no Google Docs. Se eu te enviar o link, n&oacute;s dois estamos olhando e editando o <span class="control" id="-4bgny_98">mesmo documento</span>. Se eu mudar algo, voc&ecirc; ver&aacute; a mudan&ccedil;a instantaneamente, porque ambos temos uma refer&ecirc;ncia para o mesmo objeto.</p></li></ul><section class="chapter"><h4 id="exemplo-pr-tico-modelando-um-cliente" data-toc="exemplo-pr-tico-modelando-um-cliente">Exemplo Pr&aacute;tico: Modelando um Cliente</h4><div class="code-block" data-lang="csharp">
// A class is a reference type.
public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; }
    public List&lt;Order&gt; Orders { get; private set; } = new List&lt;Order&gt;();

    public void AddOrder(Order order)
    {
        Orders.Add(order);
    }
}

public void TestReferenceTypeCopy()
{
    var customer1 = new Customer { Id = 1, Name = &quot;Bob&quot; };
    var customer2 = customer1; // Only the REFERENCE (address) is copied.
                               // Both variables now point to the SAME object in the heap.

    // If we change the object using one variable...
    customer2.Name = &quot;Robert&quot;;

    // The change is visible through the other variable, because it's the same object.
    Console.WriteLine(customer1.Name); // Outputs &quot;Robert&quot;
}
</div></section></section></section><section class="chapter"><h2 id="o-problema-da-obsess-o-primitiva-primitive-obsession" data-toc="o-problema-da-obsess-o-primitiva-primitive-obsession">O Problema da &quot;Obsess&atilde;o Primitiva&quot; (Primitive Obsession)</h2><p id="-4bgny_101">Este &eacute; um <span class="emphasis" id="-4bgny_106">code smell</span> (um mau cheiro no c&oacute;digo) muito comum, onde usamos tipos primitivos para representar conceitos de dom&iacute;nio que s&atilde;o, na verdade, mais complexos.</p><ul class="list _bullet" id="-4bgny_102"><li class="list__item" id="-4bgny_107"><p id="-4bgny_110">Usar <code class="code" id="-4bgny_111">string</code> para um e-mail ou CPF.</p></li><li class="list__item" id="-4bgny_108"><p id="-4bgny_112">Usar <code class="code" id="-4bgny_113">decimal</code> para dinheiro sem a moeda.</p></li><li class="list__item" id="-4bgny_109"><p id="-4bgny_114">Usar <code class="code" id="-4bgny_115">int</code> para um ID de produto.</p></li></ul><p id="-4bgny_103"><span class="control" id="-4bgny_116">Por que isso &eacute; ruim?</span></p><ol class="list _decimal" id="-4bgny_104" type="1"><li class="list__item" id="-4bgny_117"><p id="-4bgny_120"><span class="control" id="-4bgny_121">Perda de Significado</span>: Um m&eacute;todo <code class="code" id="-4bgny_122">Process(string, string, decimal)</code> n&atilde;o diz nada. <code class="code" id="-4bgny_123">Process(EmailAddress, PostalCode, Money)</code> &eacute; auto-documentado.</p></li><li class="list__item" id="-4bgny_118"><p id="-4bgny_124"><span class="control" id="-4bgny_125">Aus&ecirc;ncia de Valida&ccedil;&atilde;o</span>: Qualquer <code class="code" id="-4bgny_126">string</code> pode ser passada como um e-mail, mesmo que seja inv&aacute;lida. A l&oacute;gica de valida&ccedil;&atilde;o fica espalhada por toda a aplica&ccedil;&atilde;o.</p></li><li class="list__item" id="-4bgny_119"><p id="-4bgny_127"><span class="control" id="-4bgny_128">Comportamento Desassociado</span>: Voc&ecirc; n&atilde;o pode fazer <code class="code" id="-4bgny_129">money.Add(otherMoney)</code> se <code class="code" id="-4bgny_130">money</code> for apenas um <code class="code" id="-4bgny_131">decimal</code>. A l&oacute;gica de neg&oacute;cio n&atilde;o tem um lugar para morar.</p></li></ol><section class="chapter"><h3 id="a-solu-o-crie-pequenos-tipos-complexos-value-objects" data-toc="a-solu-o-crie-pequenos-tipos-complexos-value-objects">A Solu&ccedil;&atilde;o: Crie Pequenos Tipos Complexos (Value Objects)</h3><p id="-4bgny_132">A solu&ccedil;&atilde;o &eacute; criar pequenos <code class="code" id="-4bgny_134">structs</code> ou <code class="code" id="-4bgny_135">classes</code>/<code class="code" id="-4bgny_136">records</code> que encapsulam o valor e o comportamento do conceito de dom&iacute;nio. Estes s&atilde;o frequentemente chamados de <span class="control" id="-4bgny_137">Value Objects</span>.</p><section class="chapter"><h4 id="exemplo-de-string-para-emailaddress" data-toc="exemplo-de-string-para-emailaddress">Exemplo: De <code class="code" id="-4bgny_144">string</code> para <code class="code" id="-4bgny_145">EmailAddress</code></h4><p id="-4bgny_139"><span class="control" id="-4bgny_146">Antes (Ruim):</span></p><div class="code-block" data-lang="csharp">
public class UserRegistration
{
    public void Register(string email, string password)
    {
        if (!email.Contains(&quot;@&quot;)) // Validation is scattered
        {
            throw new ArgumentException(&quot;Invalid email format&quot;);
        }
        // ... register user
    }
}
</div><p id="-4bgny_141"><span class="control" id="-4bgny_147">Depois (Bom):</span></p><div class="code-block" data-lang="csharp">
// A Value Object representing an email address.
public record EmailAddress
{
    public string Value { get; }

    public EmailAddress(string value)
    {
        // Validation is centralized in the constructor. 
        // It's impossible to create an invalid EmailAddress.
        if (string.IsNullOrWhiteSpace(value) || !value.Contains(&quot;@&quot;))
        {
            throw new ArgumentException(&quot;Invalid email format&quot;);
        }
        Value = value;
    }
}

public class UserRegistration
{
    // The method signature is now clear and type-safe.
    public void Register(EmailAddress email, string password)
    {
        // No need for validation here. We KNOW the email is valid.
        // ... register user
    }
}
</div></section></section></section><section class="chapter"><h2 id="record-uma-alternativa-moderna-para-imutabilidade" data-toc="record-uma-alternativa-moderna-para-imutabilidade"><code class="code" id="-4bgny_153">record</code>: Uma Alternativa Moderna para Imutabilidade</h2><p id="-4bgny_149">Introduzido em C# 9, um <code class="code" id="-4bgny_154">record</code> &eacute; um tipo de refer&ecirc;ncia (ou valor, com <code class="code" id="-4bgny_155">record struct</code>) que o compilador otimiza para <span class="control" id="-4bgny_156">imutabilidade</span> e <span class="control" id="-4bgny_157">compara&ccedil;&otilde;es baseadas em valor</span>. Ele gera automaticamente construtores, propriedades, m&eacute;todos de igualdade (<code class="code" id="-4bgny_158">Equals</code>, <code class="code" id="-4bgny_159">GetHashCode</code>) e um <code class="code" id="-4bgny_160">ToString()</code> leg&iacute;vel.</p><p id="-4bgny_150">&Eacute; a escolha perfeita para DTOs e Value Objects.</p><div class="code-block" data-lang="csharp">
// Verbose class definition
public class ProductDtoOld
{
    public int Id { get; init; }
    public string Name { get; init; }
    public decimal Price { get; init; }
}

// Concise and powerful record definition
// This one line generates code equivalent to the class above, plus value-based equality and more.
public record ProductDto(int Id, string Name, decimal Price);
</div></section><section class="chapter"><h2 id="tabela-resumo-class-vs-struct" data-toc="tabela-resumo-class-vs-struct">Tabela Resumo: <code class="code" id="-4bgny_164">class</code> vs. <code class="code" id="-4bgny_165">struct</code></h2><div class="table-wrapper"><table class="wide" id="-4bgny_162"><thead><tr class="ijRowHead" id="-4bgny_166"><th id="-4bgny_172"><p>Caracter&iacute;stica</p></th><th id="-4bgny_173"><p><code class="code" id="-4bgny_175">class</code> (Tipo de Refer&ecirc;ncia)</p></th><th id="-4bgny_174"><p><code class="code" id="-4bgny_176">struct</code> (Tipo de Valor)</p></th></tr></thead><tbody><tr id="-4bgny_167"><td id="-4bgny_177"><p><span class="control" id="-4bgny_180">Armazenamento</span></p></td><td id="-4bgny_178"><p>A refer&ecirc;ncia fica na Stack, o objeto fica no <span class="control" id="-4bgny_181">Heap</span>.</p></td><td id="-4bgny_179"><p>Geralmente armazenado inteiramente na <span class="control" id="-4bgny_182">Stack</span>.</p></td></tr><tr id="-4bgny_168"><td id="-4bgny_183"><p><span class="control" id="-4bgny_186">Atribui&ccedil;&atilde;o</span></p></td><td id="-4bgny_184"><p>Copia a <span class="control" id="-4bgny_187">refer&ecirc;ncia</span>. Ambas as vari&aacute;veis apontam para o mesmo objeto.</p></td><td id="-4bgny_185"><p>Copia a <span class="control" id="-4bgny_188">inst&acirc;ncia inteira</span>. Cria um objeto independente.</p></td></tr><tr id="-4bgny_169"><td id="-4bgny_189"><p><span class="control" id="-4bgny_192">Valor Padr&atilde;o</span></p></td><td id="-4bgny_190"><p><code class="code" id="-4bgny_193">null</code> (nenhum objeto)</p></td><td id="-4bgny_191"><p><code class="code" id="-4bgny_194">0</code>, <code class="code" id="-4bgny_195">false</code>, etc., para cada membro (objeto &quot;zerado&quot;).</p></td></tr><tr id="-4bgny_170"><td id="-4bgny_196"><p><span class="control" id="-4bgny_199">Heran&ccedil;a</span></p></td><td id="-4bgny_197"><p>Suporta heran&ccedil;a de outras classes.</p></td><td id="-4bgny_198"><p>N&atilde;o pode herdar de outra classe (mas pode implementar interfaces).</p></td></tr><tr id="-4bgny_171"><td id="-4bgny_200"><p><span class="control" id="-4bgny_203">Uso Ideal</span></p></td><td id="-4bgny_201"><p>Entidades com identidade, estado mut&aacute;vel e comportamento complexo (<code class="code" id="-4bgny_204">Customer</code>, <code class="code" id="-4bgny_205">Order</code>).</p></td><td id="-4bgny_202"><p>Objetos pequenos e imut&aacute;veis com sem&acirc;ntica de valor (<code class="code" id="-4bgny_206">Point</code>, <code class="code" id="-4bgny_207">Money</code>, <code class="code" id="-4bgny_208">Color</code>).</p></td></tr></tbody></table></div></section><section class="chapter"><h2 id="refer-ncias-oficiais-da-microsoft" data-toc="refer-ncias-oficiais-da-microsoft">Refer&ecirc;ncias Oficiais da Microsoft</h2><ul class="list _bullet" id="-4bgny_209"><li class="list__item" id="-4bgny_210"><p id="-4bgny_213"><a href="https://learn.microsoft.com/pt-br/dotnet/csharp/fundamentals/types/classes-structs-records" id="-4bgny_214" data-external="true" rel="noopener noreferrer" target="_blank">Classes, structs e records (Guia de Programa&ccedil;&atilde;o C#)</a></p></li><li class="list__item" id="-4bgny_211"><p id="-4bgny_215"><a href="https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/builtin-types/value-types" id="-4bgny_216" data-external="true" rel="noopener noreferrer" target="_blank">Tipos de Valor (Refer&ecirc;ncia de C#)</a></p></li><li class="list__item" id="-4bgny_212"><p id="-4bgny_217"><a href="https://learn.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/reference-types" id="-4bgny_218" data-external="true" rel="noopener noreferrer" target="_blank">Tipos de Refer&ecirc;ncia (Refer&ecirc;ncia de C#)</a></p></li></ul></section><div class="last-modified">28 August 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="modificators.html" class="navigation-links__prev">Modificadores de Acesso</a><a href="using-and-disposing.html" class="navigation-links__next">Gerenciando Recursos com IDisposable</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>