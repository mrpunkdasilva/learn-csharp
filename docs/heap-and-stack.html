<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#214C69"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-08-28T15:07:24.353696962"><title>Stack vs. Heap: Gerenciamento de Mem&oacute;ria em C# | Learn C#</title><script type="application/json" id="virtual-toc-data">[{"id":"a-stack-pilha","level":0,"title":"A Stack (Pilha)","anchor":"#a-stack-pilha"},{"id":"a-heap-monte","level":0,"title":"A Heap (Monte)","anchor":"#a-heap-monte"},{"id":"exemplo-combinado-stack-e-heap-em-a-o","level":0,"title":"Exemplo Combinado: Stack e Heap em Ação","anchor":"#exemplo-combinado-stack-e-heap-em-a-o"},{"id":"tabela-comparativa","level":0,"title":"Tabela Comparativa","anchor":"#tabela-comparativa"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Stack vs. Heap: Gerenciamento de Mem&oacute;ria em C# | Learn C#"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Learn C# Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/heap-and-stack.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Stack vs. Heap: Gerenciamento de Mem&oacute;ria em C# | Learn C#"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/heap-and-stack.html#webpage",
    "url": "writerside-documentation/heap-and-stack.html",
    "name": "Stack vs. Heap: Gerenciamento de Mem&oacute;ria em C# | Learn C#",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Learn C# Help"
}</script><!-- End Schema.org --></head><body data-id="Heap-and-Stack" data-main-title="Stack vs. Heap: Gerenciamento de Memória em C#" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Fundamentos///Tipos de Valor"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Learn C#  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Heap-and-Stack" id="Heap-and-Stack.md">Stack vs. Heap: Gerenciamento de Memória em C#</h1><p id="-g9p7ba_3">Todo programa .NET utiliza duas &aacute;reas de mem&oacute;ria fundamentais para sua execu&ccedil;&atilde;o: a <span class="control" id="-g9p7ba_8">Stack (Pilha)</span> e a <span class="control" id="-g9p7ba_9">Heap (Monte)</span>. Compreender como elas funcionam e o que &eacute; armazenado em cada uma &eacute; crucial para escrever c&oacute;digo eficiente e prever seu comportamento, especialmente no que diz respeito a performance e ciclo de vida das vari&aacute;veis.</p><section class="chapter"><h2 id="a-stack-pilha" data-toc="a-stack-pilha">A Stack (Pilha)</h2><p id="-g9p7ba_10">A Stack &eacute; uma estrutura de dados do tipo <span class="control" id="-g9p7ba_16">LIFO (Last-In, First-Out)</span>, ou seja, o &uacute;ltimo item a entrar &eacute; o primeiro a sair. &Eacute; uma &aacute;rea de mem&oacute;ria extremamente r&aacute;pida e eficiente, usada para gerenciar o fluxo de execu&ccedil;&atilde;o do programa.</p><p id="-g9p7ba_11"><span class="control" id="-g9p7ba_17">O que &eacute; armazenado na Stack?</span></p><ol class="list _decimal" id="-g9p7ba_12" type="1"><li class="list__item" id="-g9p7ba_18"><p id="-g9p7ba_22"><span class="control" id="-g9p7ba_23">Tipos de Valor (<code class="code" id="-g9p7ba_29">Value Types</code>):</span> Vari&aacute;veis locais de tipos como <code class="code" id="-g9p7ba_24">int</code>, <code class="code" id="-g9p7ba_25">double</code>, <code class="code" id="-g9p7ba_26">bool</code>, <code class="code" id="-g9p7ba_27">char</code>, e <code class="code" id="-g9p7ba_28">structs</code> s&atilde;o armazenadas diretamente na Stack.</p></li><li class="list__item" id="-g9p7ba_19"><p id="-g9p7ba_30"><span class="control" id="-g9p7ba_31">Par&acirc;metros de M&eacute;todos:</span> Os valores passados como argumentos para um m&eacute;todo s&atilde;o colocados na Stack.</p></li><li class="list__item" id="-g9p7ba_20"><p id="-g9p7ba_32"><span class="control" id="-g9p7ba_33">Refer&ecirc;ncias a Objetos:</span> Quando voc&ecirc; cria um objeto (um tipo de refer&ecirc;ncia), o objeto em si vai para a Heap, mas a <span class="control" id="-g9p7ba_34">vari&aacute;vel que aponta para ele</span> (a refer&ecirc;ncia/ponteiro) &eacute; armazenada na Stack.</p></li><li class="list__item" id="-g9p7ba_21"><p id="-g9p7ba_35"><span class="control" id="-g9p7ba_36">Controle de Execu&ccedil;&atilde;o:</span> A Stack gerencia qual m&eacute;todo est&aacute; em execu&ccedil;&atilde;o no momento. Cada chamada de m&eacute;todo cria um &quot;quadro&quot; (<span class="emphasis" id="-g9p7ba_37">stack frame</span>) que cont&eacute;m suas vari&aacute;veis locais e par&acirc;metros. Quando o m&eacute;todo termina, seu quadro &eacute; removido da pilha.</p></li></ol><p id="-g9p7ba_13"><span class="control" id="-g9p7ba_38">Caracter&iacute;sticas Principais:</span></p><ul class="list _bullet" id="-g9p7ba_14"><li class="list__item" id="-g9p7ba_39"><p id="-g9p7ba_43"><span class="control" id="-g9p7ba_44">Velocidade:</span> Aloca&ccedil;&atilde;o e desaloca&ccedil;&atilde;o s&atilde;o instant&acirc;neas (apenas o ponteiro da Stack &eacute; movido).</p></li><li class="list__item" id="-g9p7ba_40"><p id="-g9p7ba_45"><span class="control" id="-g9p7ba_46">Tamanho Fixo:</span> A mem&oacute;ria para um quadro de pilha &eacute; alocada no in&iacute;cio da chamada do m&eacute;todo.</p></li><li class="list__item" id="-g9p7ba_41"><p id="-g9p7ba_47"><span class="control" id="-g9p7ba_48">Gerenciamento Autom&aacute;tico:</span> A mem&oacute;ria &eacute; liberada automaticamente quando a vari&aacute;vel sai de escopo (o m&eacute;todo termina). O Garbage Collector <span class="control" id="-g9p7ba_49">n&atilde;o atua</span> na Stack.</p></li><li class="list__item" id="-g9p7ba_42"><p id="-g9p7ba_50"><span class="control" id="-g9p7ba_51">Limita&ccedil;&atilde;o de Tamanho:</span> A Stack tem um tamanho limitado. Chamadas recursivas infinitas podem causar um <code class="code" id="-g9p7ba_52">StackOverflowException</code>.</p></li></ul><section class="chapter"><h3 id="diagrama-da-stack" data-toc="diagrama-da-stack">Diagrama da Stack</h3><div class="code-block" data-lang="none">
// Código
void MetodoA() {
    int x = 10;
    MetodoB();
}

void MetodoB() {
    bool y = true;
}
</div><div class="code-block" data-lang="none">
      STACK (Durante a execução de MetodoB)
+--------------------+
| Frame do MetodoB:  |  &lt;-- Topo da Stack
|   y = true         |
+--------------------+
| Frame do MetodoA:  |
|   x = 10           |
+--------------------+
| ... (outros frames) ...
+--------------------+
</div></section></section><section class="chapter"><h2 id="a-heap-monte" data-toc="a-heap-monte">A Heap (Monte)</h2><p id="-g9p7ba_55">A Heap &eacute; uma &aacute;rea de mem&oacute;ria maior e mais flex&iacute;vel, usada para aloca&ccedil;&atilde;o din&acirc;mica. &Eacute; aqui que os objetos (inst&acirc;ncias de classes) residem.</p><p id="-g9p7ba_56"><span class="control" id="-g9p7ba_60">O que &eacute; armazenado na Heap?</span></p><ol class="list _decimal" id="-g9p7ba_57" type="1"><li class="list__item" id="-g9p7ba_61"><p id="-g9p7ba_62"><span class="control" id="-g9p7ba_63">Inst&acirc;ncias de Tipos de Refer&ecirc;ncia (<code class="code" id="-g9p7ba_69">Reference Types</code>):</span> Qualquer objeto criado com a palavra-chave <code class="code" id="-g9p7ba_64">new</code> (como inst&acirc;ncias de <code class="code" id="-g9p7ba_65">class</code>, <code class="code" id="-g9p7ba_66">arrays</code>, <code class="code" id="-g9p7ba_67">string</code>, <code class="code" id="-g9p7ba_68">delegates</code>) &eacute; alocado na Heap.</p></li></ol><p id="-g9p7ba_58"><span class="control" id="-g9p7ba_70">Caracter&iacute;sticas Principais:</span></p><ul class="list _bullet" id="-g9p7ba_59"><li class="list__item" id="-g9p7ba_71"><p id="-g9p7ba_75"><span class="control" id="-g9p7ba_76">Aloca&ccedil;&atilde;o Din&acirc;mica:</span> Objetos podem ser alocados e desalocados em qualquer ordem.</p></li><li class="list__item" id="-g9p7ba_72"><p id="-g9p7ba_77"><span class="control" id="-g9p7ba_78">Velocidade:</span> A aloca&ccedil;&atilde;o na Heap &eacute; mais lenta que na Stack, pois o sistema precisa encontrar um bloco de mem&oacute;ria livre que seja grande o suficiente.</p></li><li class="list__item" id="-g9p7ba_73"><p id="-g9p7ba_79"><span class="control" id="-g9p7ba_80">Gerenciamento pelo Garbage Collector (GC):</span> A mem&oacute;ria na Heap n&atilde;o &eacute; liberada automaticamente. O GC &eacute; um processo que roda em segundo plano, identifica objetos na Heap que n&atilde;o s&atilde;o mais referenciados por nenhuma vari&aacute;vel na Stack e libera o espa&ccedil;o que eles ocupavam.</p></li><li class="list__item" id="-g9p7ba_74"><p id="-g9p7ba_81"><span class="control" id="-g9p7ba_82">Tamanho Maior:</span> A Heap &eacute; muito maior que a Stack, limitada apenas pela mem&oacute;ria virtual dispon&iacute;vel no sistema.</p></li></ul></section><section class="chapter"><h2 id="exemplo-combinado-stack-e-heap-em-a-o" data-toc="exemplo-combinado-stack-e-heap-em-a-o">Exemplo Combinado: Stack e Heap em A&ccedil;&atilde;o</h2><p id="-g9p7ba_83">Vamos analisar um exemplo que usa ambos os tipos e visualizar a mem&oacute;ria.</p><div class="code-block" data-lang="csharp">
public class Estudante // Reference Type
{
    public int Matricula { get; set; }
}

public void Executar()
{
    int idade = 25; // Value Type
    Estudante aluno = new Estudante(); // Reference Type
    aluno.Matricula = 101;
}
</div><section class="chapter"><h3 id="diagrama-da-mem-ria-durante-a-execu-o" data-toc="diagrama-da-mem-ria-durante-a-execu-o">Diagrama da Mem&oacute;ria Durante a Execu&ccedil;&atilde;o</h3><div class="code-block" data-lang="none">
          STACK                                  HEAP
+-------------------------+          +----------------------------+
| Frame do método Executar: |
|                         |
|   idade = 25            |          // Objeto alocado na Heap
|                         |
|   aluno (ref: 0xA1B2)   |---------&gt;+ Objeto Estudante (0xA1B2)  |
|                         |          |   - Matricula: 101         |
+-------------------------+          +----------------------------+
| ... (outros frames) ... |
+-------------------------+
</div><p id="-g9p7ba_87"><span class="control" id="-g9p7ba_89">An&aacute;lise:</span></p><ol class="list _decimal" id="-g9p7ba_88" type="1"><li class="list__item" id="-g9p7ba_90"><p id="-g9p7ba_93">A vari&aacute;vel <code class="code" id="-g9p7ba_94">idade</code> (tipo <code class="code" id="-g9p7ba_95">int</code>) &eacute; um tipo de valor, ent&atilde;o seu dado (<code class="code" id="-g9p7ba_96">25</code>) &eacute; armazenado diretamente na Stack.</p></li><li class="list__item" id="-g9p7ba_91"><p id="-g9p7ba_97">A vari&aacute;vel <code class="code" id="-g9p7ba_98">aluno</code> &eacute; uma refer&ecirc;ncia. Ela tamb&eacute;m fica na Stack, mas seu valor n&atilde;o &eacute; o objeto em si, e sim o <span class="control" id="-g9p7ba_99">endere&ccedil;o</span> (<code class="code" id="-g9p7ba_100">0xA1B2</code>) onde o objeto <code class="code" id="-g9p7ba_101">Estudante</code> foi alocado na Heap.</p></li><li class="list__item" id="-g9p7ba_92"><p id="-g9p7ba_102">O objeto <code class="code" id="-g9p7ba_103">Estudante</code> real, com seu campo <code class="code" id="-g9p7ba_104">Matricula</code>, reside na Heap.</p></li></ol></section></section><section class="chapter"><h2 id="tabela-comparativa" data-toc="tabela-comparativa">Tabela Comparativa</h2><div class="table-wrapper"><table class="wide" id="-g9p7ba_105"><thead><tr class="ijRowHead" id="-g9p7ba_106"><th id="-g9p7ba_112"><p>Caracter&iacute;stica</p></th><th id="-g9p7ba_113"><p>Stack (Pilha)</p></th><th id="-g9p7ba_114"><p>Heap (Monte)</p></th></tr></thead><tbody><tr id="-g9p7ba_107"><td id="-g9p7ba_115"><p><span class="control" id="-g9p7ba_118">Velocidade</span></p></td><td id="-g9p7ba_116"><p>Muito R&aacute;pida</p></td><td id="-g9p7ba_117"><p>Mais Lenta</p></td></tr><tr id="-g9p7ba_108"><td id="-g9p7ba_119"><p><span class="control" id="-g9p7ba_122">Gerenciamento</span></p></td><td id="-g9p7ba_120"><p>Autom&aacute;tico (LIFO)</p></td><td id="-g9p7ba_121"><p>Garbage Collector (GC)</p></td></tr><tr id="-g9p7ba_109"><td id="-g9p7ba_123"><p><span class="control" id="-g9p7ba_126">Armazena</span></p></td><td id="-g9p7ba_124"><p>Tipos de Valor, Refer&ecirc;ncias</p></td><td id="-g9p7ba_125"><p>Inst&acirc;ncias de Tipos de Refer&ecirc;ncia</p></td></tr><tr id="-g9p7ba_110"><td id="-g9p7ba_127"><p><span class="control" id="-g9p7ba_130">Ciclo de Vida</span></p></td><td id="-g9p7ba_128"><p>Curto (limitado ao escopo do m&eacute;todo)</p></td><td id="-g9p7ba_129"><p>Longo (at&eacute; n&atilde;o ser mais referenciado)</p></td></tr><tr id="-g9p7ba_111"><td id="-g9p7ba_131"><p><span class="control" id="-g9p7ba_134">Tamanho</span></p></td><td id="-g9p7ba_132"><p>Pequeno e Fixo (por thread)</p></td><td id="-g9p7ba_133"><p>Grande e Din&acirc;mico</p></td></tr></tbody></table></div></section><div class="last-modified">14 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="enums.html" class="navigation-links__prev">Enums</a><a href="value-types.html" class="navigation-links__next">Tipos de Valor (Value Types)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>